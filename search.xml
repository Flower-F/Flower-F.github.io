<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>闭包在内存中真的不会被回收吗</title>
    <url>/2022/03/11/did-closure-not-be-recoveried/</url>
    <content><![CDATA[<p>今天看到了一个很有趣的问题，关于闭包在内存中是否真的不会被回收，所以我也来写篇小短文谈谈我的理解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCounter()());</span><br><span class="line"><span class="built_in">console</span>.log(getCounter()());</span><br><span class="line"><span class="built_in">console</span>.log(getCounter()());</span><br></pre></td></tr></table></figure>

<p>先看一段代码。</p>
<p>众所周知这道题的答案是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>然而其实不是！！！</strong></p>
<p>这道题的正确答案是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>的确，在 <code>getCounter</code> 函数中创建了函数 <code>counter</code>，而且在函数 <code>counter</code> 中也的的确确访问了 <code>getCounter</code> 中的变量 <code>a</code>。根据经验，此处一定会形成闭包毋庸置疑，因为 <code>getCounter</code> 的词法作用域被它内部的函数 <code>counter</code> 的词法作用域引用了。</p>
<p>我们也可以根据控制台的打印结果看出来这里确实形成了闭包。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220311204446.png"></p>
<p>问题在于<strong>执行上下文</strong>。</p>
<p>从闭包的具体实现上来说，对于函数 <code>counter</code> 而言，闭包对象 <code>Closure (getCounter)</code> 存在于自身的 <code>[[Scopes]]</code> 属性中。也就是说，只要函数体 <code>getCounter</code> 在内存中持久存在，闭包就会持久存在。而<strong>如果函数体被回收，闭包对象同样会被回收。</strong></p>
<p>在预解析阶段，函数声明会创建一个函数体，并在代码中持久存在。但是<strong>并非所有的函数体都能够持久存在。</strong>在上面的示例中，<code>counter</code> 函数是在 <code>getCounter</code> 函数的执行上下文中声明的，当执行上下文执行完毕，执行上下文就会被回收，那么在 <code>getCounter</code> 执行上下文中声明的 <code>counter</code> 函数也会被回收。所以显然由 <code>counter</code> 与 <code>getCounter</code> 产生的闭包也会被回收，我们每次执行 <code>getCounter()()</code>，实际上创建了不同的闭包对象。</p>
<p>而我们平常见到的闭包版本，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCounter = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(myCounter());</span><br><span class="line"><span class="built_in">console</span>.log(myCounter());</span><br><span class="line"><span class="built_in">console</span>.log(myCounter());</span><br></pre></td></tr></table></figure>

<p>显然对于函数 <code>counter</code> 的引用会一直保存在内存中，所以我们总能访问到 <code>counter</code> 函数。</p>
<p>回到开头的问题，答案就是：闭包对象并非不能被垃圾回收机制回收，具体仍然需要视情况而定。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2022/02/20/js-clone/</url>
    <content><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object.assign()</span><br></pre></td></tr></table></figure>

<p>不会拷贝对象的继承属性、不会拷贝对象的不可枚举属性、可以拷贝 Symbol 类型的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br></pre></td></tr></table></figure>

<p>还有 concat、slice、拓展运算符均可以实现浅拷贝。</p>
<p>手工实现浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> object) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>乞丐版：JSON.stringify()</p>
<p>存在的问题：（可以结合之前文章的手写 JSON.stringify() 看）</p>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，拷贝后整个键值对消失</li>
<li>拷贝后 Date 引用类型变为字符串（调用了 toJSON）</li>
<li>无法拷贝不可枚举的属性</li>
<li>无法拷贝对象的原型链</li>
<li>拷贝 RegExp 会变为空对象</li>
<li>对象中含有 NaN、Infinity，拷贝结果会变为 null</li>
<li>无法拷贝循环引用</li>
</ul>
<p>手写深拷贝：</p>
<p>首先要了解一个方法：<code>Object. getOwnPropertyDescriptors()</code>，这个方法用于获得属性的特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(person);</span><br><span class="line"><span class="built_in">console</span>.log(desc);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220220203637.png"></p>
<p>还有一个是 Reflect.ownKeys()，它返回一个由目标对象自身的属性键组成的数组。返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> ((<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; obj !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 防止内存泄漏</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 特判 Date 和 RegExp，返回一个新对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj?.constructor === <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj?.constructor === <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到属性值和属性的描述</span></span><br><span class="line">  <span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承原型链，包括其 descriptors</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), desc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 hash，用于后续检测循环引用</span></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有键值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">&#x27;function&#x27;</span> ? deepClone(obj[key], hash) : obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证代码</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">  <span class="attr">boolean</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">unf</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">nul</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>) &#125;,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  <span class="attr">reg</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;/我是正则/ig&#x27;</span>),</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;我是 Symbol&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;innumerable&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;不可枚举&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj = <span class="built_in">Object</span>.create(obj, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line">obj.loop = obj; <span class="comment">// 循环引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cloneObj = deepClone(obj);</span><br><span class="line">cloneObj.arr.push(<span class="number">1234</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 历史</title>
    <url>/2022/02/16/http-history/</url>
    <content><![CDATA[<h1 id="五层-amp-七层"><a href="#五层-amp-七层" class="headerlink" title="五层 &amp; 七层"></a>五层 &amp; 七层</h1><p>五层：物理、链路、网络、传输、应用<br>七层：物理、链路、网络、传输、会话、表示、应用</p>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h1 id="URI-amp-URL"><a href="#URI-amp-URL" class="headerlink" title="URI &amp; URL"></a>URI &amp; URL</h1><ul>
<li>Uniform Resource Identifier，统一资源标识符，可以唯一标记互联网资源</li>
<li>Uniform Resource Locator，统一资源定位符，也就是地址，它是 URI 的子集</li>
</ul>
<p>只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL</p>
<h1 id="HTTP-特征"><a href="#HTTP-特征" class="headerlink" title="HTTP 特征"></a>HTTP 特征</h1><ul>
<li>支持客户端-服务器模式</li>
<li>简单快速：客户端向服务端请求只需要传送请求方法和路径。因为协议简单，所以服务器规模小所以通信速度很快</li>
<li>灵活可拓展：HTTP 允许传输任意类型的数据对象，由 Content-Type 标记类型</li>
<li>无连接：每次连接只处理一个请求，服务器处理完请求，并收到客户端的应答后，就断开连接</li>
<li>无状态：没有记忆能力</li>
</ul>
<h1 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h1><p>HTTP 协议由三大部分组成：</p>
<ul>
<li>起始行：描述请求或响应的基本信息</li>
<li>header</li>
<li>body：实际传输的数据，不一定是纯文本，也可以是视频、图片等</li>
</ul>
<p>header 和 body 之间会有一个空行，header 不能为空，body 可以为空</p>
<h1 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h1><p>起始行包括三个字段：请求方法、URL、HTTP 版本号</p>
<h1 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h1><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><p>特性：</p>
<ul>
<li>只有一个请求行，没有请求头和请求体</li>
<li>请求方法只有 GET</li>
</ul>
<p>缺点：</p>
<ul>
<li>响应只有 HTML 文档，文件格式只局限于 ASCII 编码</li>
</ul>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>特性：</p>
<ul>
<li>引入了请求头和请求体，增加了状态码，支持多种文档类型</li>
<li>使用短连接，每次发送数据都要经过三次握手和四次挥手，效率低</li>
<li>header 中只使用 If-Modified-Since 和 Expires 作为缓存</li>
</ul>
<p>缺点：</p>
<ul>
<li>只提供了基本的认证，用户名和密码都没有加密</li>
<li>不支持断点续传</li>
<li>每个 IP 只能有一个域名</li>
<li>在同一个 TCP 连接里面，请求顺序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，也就是所谓的队头阻塞</li>
<li>需要在响应头设置 Content-Length，然后浏览器再根据设置的数据大小来接收数据，对于动态生成的数据无能为力</li>
</ul>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>特性：</p>
<ul>
<li>使用摘要算法（MD5，加密不可逆，较为安全，只能通过暴力匹配破解）进行身份验证</li>
<li>引入了 cookie</li>
<li>默认使用持久连接，对应请求头 keep-alive</li>
<li>新增 E-tag、If-Match、If-None-Match 等缓存</li>
<li>支持断点续传，对应请求头 Range</li>
<li>因为虚拟机的发展，一个 IP 支持多个域名</li>
</ul>
<p>缺点：</p>
<ul>
<li>同时开启多条 TCP 连接时，连接之间会互相竞争带宽</li>
<li>队头阻塞</li>
<li>TCP 的慢启动</li>
<li>请求头重复携带</li>
</ul>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>特性：</p>
<ul>
<li>彻底的二进制协议，头和体都是二进制（HTTP 1.1 的头必须是 ASCII 编码）</li>
<li>多路复用。在一个连接中，客户端和服务器都可以同时发送多个请求或回应，而且不需要按照顺序发送</li>
<li>数据流概念。HTTP 2 的数据包是不按顺序发送的，同一个连接中的数据包可能来源于不同的请求，所以需要对数据包做标记，指明属于哪个请求</li>
<li>头部压缩，因为 HTTP 无状态，每次请求都必须带上所有的信息，所以很多的请求字段都是重复的，比如 User-Agent。一模一样的内容每次请求都要携带会浪费带宽，影响速度。通过 gzip 或者 compress 压缩头后再发送。另一方面，客户端和服务端都维护一张头信息表，部分字段会存储到表中，生成一个索引，以后相同的就只发送索引，不发生字段，这也叫 HPACK 算法。</li>
<li>允许服务器主动推送。HTTP 2 允许服务器未经请求，主动向客户端推送一些必要资源。</li>
</ul>
<p>缺点：</p>
<p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p>
<h2 id="HTTP-3-（QUIC）"><a href="#HTTP-3-（QUIC）" class="headerlink" title="HTTP 3 （QUIC）"></a>HTTP 3 （QUIC）</h2><p>特性：</p>
<ul>
<li>Quick UDP Internet Connection</li>
<li>基于 UDP 实现了类似 TCP 的流量控制、可靠传输机制</li>
<li>继承了 TLS</li>
<li>使用了 HTTP 2 的多路复用，再加上使用了 UDP，真正解决了对头阻塞问题</li>
<li>快速握手，快速启动。因为基于 UDP</li>
</ul>
<p>缺点：</p>
<ul>
<li>服务端和客户端对 HTTP 3 的支持还不完善</li>
<li>可能会存在安全性问题</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>react 核心原理</title>
    <url>/2022/02/16/react-core/</url>
    <content><![CDATA[<p>本文是 <a href="https://pomb.us/build-your-own-react/">Build Your Own React</a> 的翻译兼阅读笔记</p>
<h1 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h1><p>React 的每一个 element 包含的内容为 type 和 props。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>, <span class="comment">// 一个特殊属性，通常是很多 elements 组成的数组</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把上述内容渲染为 dom，我们需要以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line"><span class="comment">// 把 props 的所有属性传递给节点</span></span><br><span class="line">node.title = element.props.title;</span><br><span class="line"><span class="comment">// 因为这里的 child 比较简单，所以我们用 textNode 代替</span></span><br><span class="line"><span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">textNode.nodeValue = element.props.children;</span><br><span class="line"><span class="comment">// 把 child 作为 node 的孩子</span></span><br><span class="line">node.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 node 插入容器</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">container.appendChild(node);</span><br></pre></td></tr></table></figure>

<p>这里默认 <code>dom</code> 代表真实的 dom 元素，而 <code>element</code> 代表 react 元素</p>
<p>现在让我们尝试创造一个自己的 createElement。我们需要做的就是把 JSX 转换为一个 object。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比方说，</p>
<p>createElement(“div”) 结果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123; <span class="attr">children</span>: [] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createElement(“div”, null, a) 结果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;ype: &quot;</span>div<span class="string">&quot;,</span></span><br><span class="line"><span class="string">  props: &#123; children: [a] &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>createElement(“div”, null, a, b) 结果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123; <span class="attr">children</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到 children 其实不一定是 object 类型，我们需要为 children 再创建一个特殊类型 TEXT_ELEMENT。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时修改 createElement 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function"><span class="params">child</span> =&gt;</span> (</span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span> ? child : createTextElement(child)</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更有逼格而且摆脱 React 的束缚，我们要起一个很装逼的名字 ———— Didact。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>, <span class="comment">// type</span></span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">&quot;foo&quot;</span>&#125;, <span class="comment">// props</span></span><br><span class="line">  <span class="comment">// children</span></span><br><span class="line">  Didact.createElement(<span class="string">&#x27;a&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;bar&#x27;</span>), </span><br><span class="line">  Didact.createElement(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">ReactDOM.render(element, container);</span><br></pre></td></tr></table></figure>

<h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =  element.type === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span> ? <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    : <span class="built_in">document</span>.createElem(element.type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个函数，用于判断键值是否为 children</span></span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&#x27;children&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props).filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = element.props.name;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归渲染</span></span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> render(child, dom));</span><br><span class="line"></span><br><span class="line">  container.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/didact-2-k6rbj">目前前两步的代码在 codesandbox 的地址</a></p>
<h1 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h1><p>目前代码其实有一个很大的问题，一旦开始 render，就会不停递归直至渲染完整棵树。如果这棵树非常大的话，他就会长时间占用主线程，导致卡顿。这时候如果浏览器希望做一些更高优先级的事情，比如先去接收用户的输入，将会无法进行，直至渲染完成。</p>
<p>所以我们需要把渲染流程分成多个小单元，在我们渲染完成每一个小单元之后，我们可以让浏览器打断我们的渲染，只要它有别的高优先级任务需要完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>; <span class="comment">// 下一个单元是否需要渲染</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">// 是否应该让路</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当下一个单元需要被渲染，且不需要让路的时候，就继续渲染</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    <span class="comment">// performUnitOfWork 会执行当前的渲染，并返回下一个 unit</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当主线程空闲的时候浏览器会执行回调函数 workLoop</span></span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次执行</span></span><br><span class="line">requestIdleCallback(workLoop);</span><br></pre></td></tr></table></figure>

<p>需要注意的是 React 现在不再使用 <code>requestIdleCallback</code> 了。取而代之的是 <code>scheduler package</code>，但这对于我们理解原理没有太大影响。</p>
<p>requestIdleCallback 还会给我们一个 deadline 参数，我们可以用它来检查在浏览器需要再次获得主线程的控制权之前，我们还能剩下多少时间。</p>
<h1 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h1><p>为了组织 unit 的结构我们需要一个数据结构叫做 fiber tree。</p>
<p>每一个元素会拥有一个 fiber，而每一个 fiber 会成为 work 的一个 unit。</p>
<p>比如说我们要渲染一棵如下的树：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123303.png"></p>
<p>在渲染的时候我们会创建 root fiber，并把它设置为 nextUnitOfWork。剩下我们需要在 performUnitOfWork 函数中对 fiber 做以下三件事：</p>
<ol>
<li>把节点挂载到 dom 树</li>
<li>为节点的 child 创建 fiber</li>
<li>选择下一个 unit</li>
</ol>
<p>使用 fiber 数据结构的目的就是为了更简单地找到下一个 unit。所以每一个 fiber 和它的第一个孩子、以及紧邻它的兄弟之间都会直接相连。如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123804.png"></p>
<p>当我们完成了 fiber 上的渲染任务，如果这个 fiber 有 child，这个 child 就会成为下一个 unit。比如说对于上面的例子，div 渲染完成后就轮到 h1 了。</p>
<p>如果当前 fiber 没有 child，就会把紧贴的兄弟节点作为下一个 unit。比如上面例子中的 p，它没有 child 了，所以会把兄弟 a 作为下一个 unit。</p>
<p>如果当前 fiber 没有 child，也没有 sibling，我们就去找它的 uncle，也就是 parent 的兄弟。比如说 a，既没有 child 也没有下一个兄弟了，只能回去找它爹 h1 的兄弟 h2。</p>
<p>同理，如果它爹也没有兄弟，就继续找它爹的爹，如此遍历直到我们到达 root。当到达 root 也就意味着完成了 render。</p>
<p>现在我们将其编写成代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container, <span class="comment">// 初始化设置为 root</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">// 是否应该让路</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当下一个单元需要被渲染，且不需要让路的时候，就继续渲染</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    <span class="comment">// performUnitOfWork 会执行当前的渲染，并返回下一个 unit</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当主线程空闲的时候浏览器会执行回调函数 workLoop</span></span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. create a new fiber for each child</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.type,</span><br><span class="line">      <span class="attr">props</span>: element.props,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 fiber 挂载到树上，具体要作为 child 还是 sibling 取决于它是第一个节点还是后来的节点</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. search and return the next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h1><p>现在我们又遇到了一个新问题，现在我们每个 unit 渲染时都会把一个 dom 挂载到树上，而浏览器可以随时打断我们的渲染。这也就意味着，如果只有部分 unit 完成了渲染，用户将看到不完整的 UI。这不是我们所想要的。</p>
<p>所以我们需要把挂载 dom 的部分从原来的 render 代码中删除。取而代之的持续追踪 fiber 的根，我们将其命名为 wipRoot。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当我们完成渲染之后，也就是没有 next unit 的时候，我们直接把整棵树挂载到 dom 上。</p>
<p>这一阶段我们叫做 commitRoot。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  domParent.appendChild(fiber.dom);</span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reconciliation-调和"><a href="#Reconciliation-调和" class="headerlink" title="Reconciliation 调和"></a>Reconciliation 调和</h1><p>目前为止我们的所有操作都是针对于添加节点到 dom 中，那么如果我们要删除或更新节点呢？</p>
<p>这时候我们就需要比对 fiber 中元素和当前元素的情况。</p>
<p>所以我们需要一个变量来存储最新 commit 的 fiber，我们将其称为 currentRoot。</p>
<p>我们还要给每个 fiber 提供一个候选项 alternate，这个是一个直达旧的 fiber 的 link。</p>
<p>我们设置一个函数 reconcileChildren，用来调和旧的 fiber 和新的 react elements。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate?.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">       <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type === oldFiber.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新旧节点类型相同，对 element 创建新的 fiber，并且复用旧的 dom，但是用的是 element 上的 props</span></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">// 更新节点属性</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: oldFiber.type, <span class="comment">/// 复用</span></span><br><span class="line">        <span class="attr">props</span>: element.props, <span class="comment">// 用新的</span></span><br><span class="line">        <span class="attr">dom</span>: oldFiber.dom, <span class="comment">// 复用</span></span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&#x27;UPDATE&#x27;</span>, <span class="comment">// 这个属性会在  commit 的时候用到</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于需要生成新 DOM 节点的 fiber，我们标记 effectTag 为 PLACEMENT</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// 添加新节点</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: element.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&#x27;PLACEMENT&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于需要删除的节点，我们不会生成 fiber，而是会在 oldFiber 上添加标记。当我们 commit 整棵 fiber 树的时候，并不会遍历旧的 fiber，而是把 fiber 的变更提交上去。</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// 删除旧节点</span></span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代整个 react elements 的同时，我们也要迭代旧的 fiber 节点，即 wipFiber.alternate。</p>
<p>现在我们要比较 oldFiber 和 element 之间的差异。</p>
<p>比较的步骤如下：</p>
<ul>
<li>新旧节点类型相同，复用旧的 dom，只修改上面的属性。</li>
<li>节点类型不同，而且有新的 element，我们需要创建一个新的 dom 节点</li>
<li>类型不同，且 oldFiber 存在，需要删除旧节点</li>
</ul>
<p>React 会通过属性 key 来优化调和步骤，key 可以用来检查 elements 数组中的子组件是否仅仅只是更换了位置。</p>
<p>因此我们需要一个数组来保存要移除的 dom 节点。</p>
<p>修改 render 函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>修改 commitWork 函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果标记为 PLACEMENT，那么在其父亲节点的 DOM 节点上添加该 fiber 的 DOM。</span></span><br><span class="line">  <span class="comment">// 如果标记为 DELETION，则删除节点</span></span><br><span class="line">  <span class="comment">// 如果标记为 UPDATE，我们需要更新已经存在的旧 DOM 节点的属性值</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&#x27;PLACEMENT&#x27;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们实现 updateDom 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除旧属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps).filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加新属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps).filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = nextProps.name;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种比较特殊的属性值是事件监听，这里假设以 on 开头的就是事件监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br></pre></td></tr></table></figure>

<p>对于事件监听我们需要做以下处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除原来的事件</span></span><br><span class="line"><span class="built_in">Object</span>.keys(prevProps).filter(isEvent)</span><br><span class="line">  .filter(<span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.removeEventListener(eventType, prevProps.name);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加新的事件监听</span></span><br><span class="line"><span class="built_in">Object</span>.keys(nextProps).filter(isEvent)</span><br><span class="line">  .filter(isNew(prevProps, nextProps))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.addEventListener(eventType, nextProps.name);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Function-Components"><a href="#Function-Components" class="headerlink" title="Function Components"></a>Function Components</h1><p>下一步我们要支持函数组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Didact.render(element, container);</span><br></pre></td></tr></table></figure>

<p>这个 jsx 语法应该被转换为以下的 js 语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Hi &quot;</span>,</span><br><span class="line">    props.name</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>函数组件与之前的语法有两个不同之处：</p>
<ul>
<li>函数组件的 fiber 没有 dom</li>
<li>子节点由函数运行得到，而不是直接从 props 获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 fiber 类型为函数时，我们使用不同的函数来进行更新。在 updateHostComponent 我们按照之前的方法更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunctionComponent = fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line"><span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">  updateFunctionComponent(fiber);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  updateHostComponent(fiber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数组件中我们通过执行函数来获得 children。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前面的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>fiber.type 就是 App 函数，当执行函数的时候，就会返回 h1 元素。</p>
<p>一旦我们拿到了这个子节点，剩下的调和就跟之前一致，我们不需要修改任何东西了。</p>
<p>接下来修改 commitWork 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找 dom 节点的父节点的时候我们需要往上遍历 fiber 节点，直到找到有 dom 节点的 fiber 节点</span></span><br><span class="line">​  <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&#x27;PLACEMENT&#x27;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&#x27;UPDATE&#x27;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&#x27;DELETION&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 移除节点也同样需要找到该 fiber 下第一个有 dom 节点的 fiber 节点</span></span><br><span class="line">    domParent.removeChild(fiber, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>最后一步我们来给函数组件添加 state。我们把示例组件设置为经典的计数器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">      Count: &#123;state&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.hooks = [];</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对应的 fiber 上加上 hooks 数组以支持我们在同一个函数组件中多次调用 useState。然后我们记录当前 hook 的序号。</p>
<p>当函数组件调用 useState，我们查看 fiber 对应的 alternate 字段下的旧 fiber 是否存在旧 hook、以及hook 的序号用以记录是该组件下的第几个 useState。</p>
<p>如果存在旧的 hook，我们将旧的 hook 值拷贝一份到新的 hook。 如果不存在，就将 state 初始化。</p>
<p>然后在 fiber 上添加新 hook，hook 序号会进行自增，然后返回状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.state : initial,</span><br><span class="line">    <span class="attr">queue</span>: [], <span class="comment">// 添加一个队列，用于存储 action</span></span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下一次渲染的时候，我们才会执行 action，我们把所有的 action 从旧的 hook 队列中取出，然后将其一个个调用得到新的 hook state，因此最后返回的 state 就已经是更新好的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = oldHook ? oldHook.queue : [];</span><br><span class="line">actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  hook.state = action(hook.state)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  hook.queue.push(action);</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: currentRoot.dom,</span><br><span class="line">    <span class="attr">props</span>: currentRoot.props,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">  deletions = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useState 还需要返回一个可以更新状态的函数，我们定义 setState，它接收一个 action。（在 Counter 的例子中， action 是自增 state 的函数）</p>
<p>最终完整的 mini-react 代码链接在 <a href="https://codesandbox.io/s/didact-8-21ost">https://codesandbox.io/s/didact-8-21ost</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>使用原生 js 实现拖拽排序</title>
    <url>/2022/02/16/js-dnd/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;draggable&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;draggable&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;draggable&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;draggable&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.draggable</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">cursor</span>: move;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.draggable</span><span class="selector-class">.dragging</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> draggables = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.draggable&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> containers = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.container&quot;</span>);</span><br><span class="line"></span><br><span class="line">draggables.forEach(<span class="function">(<span class="params">draggable</span>) =&gt;</span> &#123;</span><br><span class="line">  draggable.addEventListener(<span class="string">&quot;dragstart&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;start&quot;);</span></span><br><span class="line">    draggable.classList.add(<span class="string">&quot;dragging&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  draggable.addEventListener(<span class="string">&quot;dragend&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;end&quot;);</span></span><br><span class="line">    draggable.classList.remove(<span class="string">&quot;dragging&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">containers.forEach(<span class="function">(<span class="params">container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在框框内的时候就是 drag over</span></span><br><span class="line">  container.addEventListener(<span class="string">&quot;dragover&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;over&quot;);</span></span><br><span class="line">    e.preventDefault(); <span class="comment">// 关闭禁止 cursor</span></span><br><span class="line">    <span class="keyword">const</span> afterElement = getDragAfterElement(container, e.clientY);</span><br><span class="line">    <span class="comment">// console.log(afterElement);</span></span><br><span class="line">    <span class="keyword">const</span> draggable = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.dragging&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afterElement) &#123;</span><br><span class="line">      container.appendChild(draggable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      container.insertBefore(draggable, afterElement);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDragAfterElement</span>(<span class="params">container, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> draggableElements = [</span><br><span class="line">    ...container.querySelectorAll(<span class="string">&quot;.draggable:not(.dragging)&quot;</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> draggableElements.reduce(</span><br><span class="line">    <span class="function">(<span class="params">closest, child</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> box = child.getBoundingClientRect();</span><br><span class="line">      <span class="keyword">const</span> offset = y - box.top - box.height / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// console.log(offset);</span></span><br><span class="line">      <span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset &gt; closest.offset) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          offset,</span><br><span class="line">          <span class="attr">element</span>: child,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">offset</span>: <span class="built_in">Number</span>.NEGATIVE_INFINITY,</span><br><span class="line">    &#125;</span><br><span class="line">  ).element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 手写复习</title>
    <url>/2022/02/11/js-handwrite/</url>
    <content><![CDATA[<p>题目列表来源于：<br><a href="https://bigfrontend.dev/">https://bigfrontend.dev/</a></p>
<h1 id="参数定长柯里化"><a href="#参数定长柯里化" class="headerlink" title="参数定长柯里化"></a>参数定长柯里化</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)	<span class="comment">// 10</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)	<span class="comment">// 10</span></span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)	<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>实现一个函数同时可以求解上述表达式。</p>
<p>先要实现原函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其进行柯里化，目标是将它的参数<strong>展开</strong>，所以柯里化的过程实际上可以理解为一个递归展开参数的过程。展开的便捷就是当前参数个数等于函数需要的参数，不过为了确保完整性把 === 改成了 &gt;= 而已。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// fn.length 表示的是 fn 需要的参数个数</span></span><br><span class="line">  <span class="comment">// 当前函数的参数个数大于或等于原函数时，直接执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;args&quot;</span>, args);</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// args2 是即将出现的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;args2&quot;</span>, args2);</span><br><span class="line">    <span class="keyword">return</span> curry(fn, ...args, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)(2, 3)</span></span><br><span class="line"><span class="comment">// args []，刚开始参数个数为零</span></span><br><span class="line"><span class="comment">// args2 [ 1 ]，即将出现参数 1</span></span><br><span class="line"><span class="comment">// args [ 1 ]，拼接后获得参数 1</span></span><br><span class="line"><span class="comment">// args2 [ 2, 3 ]，即将出现参数 [2, 3]</span></span><br><span class="line"><span class="comment">// args [ 1, 2, 3 ]，拼接后获得参数 [1, 2, 3]，完成任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1, 2)(3)</span></span><br><span class="line"><span class="comment">// args []</span></span><br><span class="line"><span class="comment">// args2 [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// args [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// args2 [ 3 ]</span></span><br><span class="line"><span class="comment">// args [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> join = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span>_<span class="subst">$&#123;b&#125;</span>_<span class="subst">$&#123;c&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedJoin = curry(join);</span><br><span class="line"></span><br><span class="line">curriedJoin(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#x27;1_2_3&#x27;</span></span><br><span class="line">curriedJoin(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#x27;1_2_3&#x27;</span></span><br><span class="line">curriedJoin(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// &#x27;1_2_3&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="参数不定长柯里化"><a href="#参数不定长柯里化" class="headerlink" title="参数不定长柯里化"></a>参数不定长柯里化</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收第一次参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收第二次参数</span></span><br><span class="line">  <span class="keyword">const</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    args.push(...arguments);</span><br><span class="line">    <span class="comment">// 递归获取剩下的所有参数</span></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-Array-prototype-flat"><a href="#实现-Array-prototype-flat" class="headerlink" title="实现 Array.prototype.flat()"></a>实现 Array.prototype.flat()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr, depth = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> depth &gt; <span class="number">0</span> ?</span><br><span class="line">    arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(cur)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...prev, ...flat(cur, depth - <span class="number">1</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> [...prev, cur];</span><br><span class="line">    &#125;, []) : arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-throttle"><a href="#实现-throttle" class="headerlink" title="实现 throttle()"></a>实现 throttle()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-debounce"><a href="#实现-debounce" class="headerlink" title="实现 debounce()"></a>实现 debounce()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-shuffle"><a href="#实现-shuffle" class="headerlink" title="实现 shuffle()"></a>实现 shuffle()</h1><p>Fisher-Yates shuffle 算法</p>
<p>每次删除一个数字，并将删除的数字移至数组末尾，即将每个被删除数字与最后一个未删除的数字进行交换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解密消息"><a href="#解密消息" class="headerlink" title="解密消息"></a>解密消息</h1><p>在一个字符串的二维数组中，有一个隐藏字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I B C A L K A</span><br><span class="line">D R F C A E A</span><br><span class="line">G H O E L A D</span><br></pre></td></tr></table></figure>

<p>可以按照如下步骤找出隐藏消息</p>
<ol>
<li>从左上开始，向右下前进</li>
<li>无法前进的时候，向右上前进</li>
<li>无法前进的时候，向右下前进</li>
<li>重复 2 和 3</li>
<li>无法前进的时候，经过的字符就就是隐藏信息</li>
</ol>
<p>比如上面的二维数组的话，隐藏消息就是 IROCLED</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[][]&#125;</span> <span class="variable">message</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (message.length === <span class="number">0</span> || message[<span class="number">0</span>].length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> top = <span class="literal">true</span>; <span class="comment">// 表示目前正在向 i 增大方向行进，对应图中的向下行进</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (j &lt; message[<span class="number">0</span>].length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top) &#123;</span><br><span class="line">      res += message[i++][j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res += message[i--][j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i === message.length - <span class="number">1</span>) &#123;</span><br><span class="line">      top = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">      top = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><p>题目链接：<br><a href="https://leetcode-cn.com/problems/first-bad-version/">https://leetcode-cn.com/problems/first-bad-version/</a></p>
<p>二分基础题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>version number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>isBadVersion()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>n Total versions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;integer&#125;</span> </span>The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">      <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">          <span class="comment">// 满足条件，寻找最左满足，因此收缩右边界</span></span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">          ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;    </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实现-pipe"><a href="#实现-pipe" class="headerlink" title="实现 pipe()"></a>实现 pipe()</h1><p><code>pipe</code> 会传入一个数组，数组中每一项是一个函数。<code>pipe</code> 会依次执行里面的多个函数，最后返回结果。假设每个函数都有且仅有一个参数。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipe([</span><br><span class="line">  times(2),</span><br><span class="line">  times(3)</span><br><span class="line">])  </span><br><span class="line">// x * 2 * 3</span><br><span class="line"></span><br><span class="line">pipe([</span><br><span class="line">  times(2),</span><br><span class="line">  plus(3),</span><br><span class="line">  times(4)</span><br><span class="line">]) </span><br><span class="line">// (x * 2 + 3) * 4</span><br><span class="line"></span><br><span class="line">pipe([</span><br><span class="line">  times(2),</span><br><span class="line">  subtract(3),</span><br><span class="line">  divide(4)</span><br><span class="line">]) </span><br><span class="line">// (x * 2 - 3) / 4</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;(arg: any) =&gt; any&gt;&#125;</span> </span>funcs </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;(arg: any) =&gt; any&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pipe</span>(<span class="params">funcs</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">acc, func</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> func.call(<span class="built_in">this</span>, acc);</span><br><span class="line">		&#125;, arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h1><p>若 stack2 为空，则直接输入栈顶元素；否则，先把 stack1 的所有元素倒进 stack2 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* you can use this Class which is bundled together with your code</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Stack &#123;</span></span><br><span class="line"><span class="comment">  push(element) &#123; // add element to stack &#125;</span></span><br><span class="line"><span class="comment">  peek() &#123; // get the top element &#125;</span></span><br><span class="line"><span class="comment">  pop() &#123; // remove the top element&#125;</span></span><br><span class="line"><span class="comment">  size() &#123; // count of element &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// add new element to the rare</span></span><br><span class="line">    <span class="built_in">this</span>.stack1.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// get the head element</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.stack1.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return count of element</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1.length + <span class="built_in">this</span>.stack2.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// remove the head element</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.stack1.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-memo"><a href="#实现-memo" class="headerlink" title="实现 memo()"></a>实现 memo()</h1><p>对同一个函数，当传入相同参数的时候，直接返回上一次的结果而不经过计算。要求允许传入第二个参数决定缓存 key 的生成方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">func</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;(args:[]) =&gt; string &#125;</span>  </span>[resolver] - cache key generator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params">func, resolver = (...args) =&gt; args.join(<span class="string">&#x27;_&#x27;</span>)</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = resolver(...args);</span><br><span class="line">    <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> val = func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    cache.set(key, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现类似-jQuery-的-DOM-wrapper"><a href="#实现类似-jQuery-的-DOM-wrapper" class="headerlink" title="实现类似 jQuery 的 DOM wrapper"></a>实现类似 jQuery 的 DOM wrapper</h1><p>实现自己的 <code>$()</code>，只需要支持 <code>css(propertyName: string, value: any)</code> 即可。如下面所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#button&#x27;</span>)</span><br><span class="line">  .css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>)</span><br><span class="line">  .css(<span class="string">&#x27;backgroundColor&#x27;</span>, <span class="string">&#x27;#000&#x27;</span>)</span><br><span class="line">  .css(<span class="string">&#x27;fontWeight&#x27;</span>, <span class="string">&#x27;bold&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">css</span>: <span class="function"><span class="keyword">function</span>(<span class="params">property, value</span>) </span>&#123;</span><br><span class="line">      elem.style[property] = value;</span><br><span class="line">      <span class="comment">// 最后返回原对象，因为需要支持链式调用</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现基本的-Event-Emitter"><a href="#实现基本的-Event-Emitter" class="headerlink" title="实现基本的 Event Emitter"></a>实现基本的 Event Emitter</h1><p>要求满足的条件为：</p>
<p>构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> Emitter()</span><br></pre></td></tr></table></figure>

<p>支持事件订阅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sub1  = emitter.subscribe(<span class="string">&#x27;event1&#x27;</span>, callback1)</span><br><span class="line"><span class="keyword">const</span> sub2 = emitter.subscribe(<span class="string">&#x27;event2&#x27;</span>, callback2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个callback可以重复订阅同一个事件</span></span><br><span class="line"><span class="keyword">const</span> sub3 = emitter.subscribe(<span class="string">&#x27;event1&#x27;</span>, callback1)</span><br></pre></td></tr></table></figure>

<p><code>emit(eventName, ...args)</code> 可以用来触发 callback</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">emitter.emit(<span class="string">&#x27;event1&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// callback1 会被调用两次</span></span><br></pre></td></tr></table></figure>

<p><code>subscribe()</code> 返回一个含有 <code>release()</code> 的对象，可以用来取消订阅。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sub1.release()</span><br><span class="line">sub3.release()</span><br><span class="line"><span class="comment">// 现在即使&#x27;event1&#x27;被触发, </span></span><br><span class="line"><span class="comment">// callback1 也不会被调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscriptions = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.subscriptions.has(eventName)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subscriptions.set(eventName, <span class="keyword">new</span> <span class="built_in">Set</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取具体的事件列表</span></span><br><span class="line">    <span class="keyword">const</span> subscriptions = <span class="built_in">this</span>.subscriptions.get(eventName);</span><br><span class="line">    <span class="comment">// 这里之所以要把 callback 放进一个 obj 里面，是因为题目允许重复订阅同一个事件</span></span><br><span class="line">    <span class="comment">// 以 obj 作为键值，不会重复</span></span><br><span class="line">    <span class="keyword">const</span> callbackObj = &#123;</span><br><span class="line">      callback</span><br><span class="line">    &#125;</span><br><span class="line">    subscriptions.add(callbackObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 取消订阅</span></span><br><span class="line">      <span class="attr">release</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        subscriptions.delete(callbackObj);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.size === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.subscriptions.delete(eventName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">  	<span class="keyword">const</span> subscriptions = <span class="built_in">this</span>.subscriptions.get(eventName);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions) &#123;</span><br><span class="line">      subscriptions.forEach(<span class="function"><span class="params">callbackObj</span> =&gt;</span> &#123;</span><br><span class="line">        callbackObj.callback.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模拟-Map"><a href="#模拟-Map" class="headerlink" title="模拟 Map"></a>模拟 Map</h1><p>JavaScript中有 Map，我们可以用任何 data 做 key，包括 DOM 元素。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(domNode, somedata)</span><br></pre></td></tr></table></figure>

<p>如果运行的 JavaScript 不支持 Map，我们如何能让上述代码工作？</p>
<p>方法是使用对象来模拟一个 map。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeStore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nodes = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">node, value</span>)</span> &#123;</span><br><span class="line">   node.storeKey = <span class="built_in">Symbol</span>();</span><br><span class="line">   <span class="built_in">this</span>.nodes[node.storeKey] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;any&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.nodes[node.storeKey];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nodes.hasOwnProperty(node.storeKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在相同结构的树上寻找对应的节点"><a href="#在相同结构的树上寻找对应的节点" class="headerlink" title="在相同结构的树上寻找对应的节点"></a>在相同结构的树上寻找对应的节点</h1><p>给定两个<strong>完全一样</strong>的 DOM Tree A 和 B，以及 A 中的元素 a，请找到 B 中对应的元素 b。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;HTMLElement&#125;</span> <span class="variable">rootA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;HTMLElement&#125;</span> <span class="variable">rootB</span></span> - rootA and rootB are clone of each other</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;HTMLElement&#125;</span> <span class="variable">nodeA</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> findCorrespondingNode = <span class="function">(<span class="params">rootA, rootB, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (rootA === target) &#123;</span><br><span class="line">    <span class="keyword">return</span> rootB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// children 是一个 DOM 的 api，表示所有的子节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rootA.children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = findCorrespondingNode(rootA.children[i], rootB.children[i], target);</span><br><span class="line">    <span class="comment">// 注意这里必须要判断 res 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="检测-data-type"><a href="#检测-data-type" class="headerlink" title="检测 data type"></a>检测 data type</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectType</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Object</span>.prototype.toString.call(data).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> res.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify()"></a>实现 JSON.stringify()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> undefinedOptions = [<span class="string">&#x27;undefined&#x27;</span>, <span class="string">&#x27;function&#x27;</span>, <span class="string">&#x27;symbol&#x27;</span>];</span><br><span class="line">  <span class="keyword">const</span> stringOptions = [<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;boolean&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (undefinedOptions.includes(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span> || data === -<span class="literal">Infinity</span> || data === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 number 和 boolean</span></span><br><span class="line">  <span class="keyword">if</span> (stringOptions.includes(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;data&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理字符串</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&quot;<span class="subst">$&#123;data&#125;</span>&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;bigint&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;stringify 无法序列化 bigint 数据类型&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 剩下的就是 object 类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若存在 toJSON 函数，如 Date()，直接调用</span></span><br><span class="line">  <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> stringify(data.toJSON());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// undefined、function 以及 symbol 变为 null</span></span><br><span class="line">      <span class="keyword">if</span> (undefinedOptions.includes(<span class="keyword">typeof</span> item)) &#123;</span><br><span class="line">        result[index] = <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[index] = stringify(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理普通对象</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 键值不能为 symbol</span></span><br><span class="line">    <span class="comment">// 值忽略 undefined、function 以及 symbol</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> key !== <span class="string">&#x27;symbol&#x27;</span> &amp;&amp; !undefinedOptions.includes(<span class="keyword">typeof</span> data[key])) &#123;</span><br><span class="line">      result.push(<span class="string">`&quot;<span class="subst">$&#123;key&#125;</span>&quot;:<span class="subst">$&#123;stringify(data[key])&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;result.join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>&#125;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse()"></a>实现 JSON.parse()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span> || str[<span class="number">0</span>] === <span class="string">&quot;&#x27;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;null&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;&#123;&#125;&#x27;</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;[]&#x27;</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 判断 boolean</span></span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;true&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="string">&#x27;false&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 判断 number</span></span><br><span class="line">  <span class="keyword">if</span>(+str === +str) <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">  <span class="comment">// 判断 string</span></span><br><span class="line">  <span class="keyword">if</span>(str[<span class="number">0</span>] === <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对象</span></span><br><span class="line">  <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">1</span>, -<span class="number">1</span>).split(<span class="string">&#x27;,&#x27;</span>).reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> index = cur.indexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> key = cur.slice(<span class="number">0</span>, index);</span><br><span class="line">      <span class="keyword">const</span> value = cur.slice(index + <span class="number">1</span>);</span><br><span class="line">      acc[parse(key)] = parse(value);</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断数组</span></span><br><span class="line">  <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">1</span>, -<span class="number">1</span>).split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function">(<span class="params">value</span>) =&gt;</span> parse(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 基础学习笔记</title>
    <url>/2022/01/24/webpack-learning-notes/</url>
    <content><![CDATA[<p>本文对应<a href="https://github.com/Flower-F/webpack-learning/tree/main/webpack-basics">仓库地址</a></p>
<h1 id="webpack-初体验"><a href="#webpack-初体验" class="headerlink" title="webpack 初体验"></a>webpack 初体验</h1><p>运行命令初始化 package.json。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure>

<p>安装 webpack 和 webpack-cli。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>根目录新建文件夹 src，里面新建文件夹 js。</p>
<p>js 文件夹下新建两个文件 math.js 和 foo.js。内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mul = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>src 目录下新建文件 index.js，文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum, mul &#125; <span class="keyword">from</span> <span class="string">&quot;./js/math&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = <span class="built_in">require</span>(<span class="string">&quot;./js/foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>根目录下新建 index.html，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Learning<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行命令打包文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>

<p>在 dist/main.js 中，可以看到打包的结果。</p>
<p>在 package.json 中配置 build 运行命令。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;npx webpack&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="css-loader-amp-style-loader"><a href="#css-loader-amp-style-loader" class="headerlink" title="css-loader &amp; style-loader"></a>css-loader &amp; style-loader</h1><p>src/js 目录下新建文件 title.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;../css/title.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;h1&quot;</span>);</span><br><span class="line">  h1.innerHTML = title;</span><br><span class="line">  h1.className = <span class="string">&quot;title&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(h1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> setTitle;</span><br></pre></td></tr></table></figure>

<p>修改 index.js 内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setTitle <span class="keyword">from</span> <span class="string">&quot;./js/title&quot;</span>;</span><br><span class="line"></span><br><span class="line">setTitle(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>src 目录下新建文件夹 css，css 文件夹下新建文件 title.css，内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 index.html 中引入 css 文件。</p>
<p>运行命令 <code>yarn build</code>，报错，原因是缺少 loader。</p>
<p>安装 loader。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add css-loader -D</span><br></pre></td></tr></table></figure>

<p>根目录下新建文件 webpack.config.js，进行配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是样式并没有展示，因为现在只是把 css 语法识别为了 js 语法，但是还没有挂载到页面上，我们需要 style-loader 来把内容挂载到 <code>&lt;style&gt;</code> 标签上。</p>
<p>安装 style-loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add style-loader -D</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h1><p>首先安装 less。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less -D</span><br></pre></td></tr></table></figure>

<p>配置文件修改为下面的内容。</p>
<p>安装 less-loader。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less-loader -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h1 id="browserslitrc"><a href="#browserslitrc" class="headerlink" title="browserslitrc"></a>browserslitrc</h1><p>浏览器使用比例可以查看 <a href="https://caniuse.com/">caniuse 官网</a></p>
<p>在 package.json 中新增内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;&gt;1%&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last 2 version&quot;</span>,</span><br><span class="line">  <span class="string">&quot;not dead&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx browserslist</span><br></pre></td></tr></table></figure>

<p>可查看当前兼容的浏览器选项。</p>
<h1 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h1><p>postcss 用来处理 css 的兼容性问题。</p>
<p>先安装 postcss 和 postcss-loader</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add postcss -D</span><br></pre></td></tr></table></figure>

<p>css 文件夹下新建文件 test.css，内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  user-select: none;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把文件引入 title.js 中。</p>
<p>修改 webpack.config.js 为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>打包以后发现没有任何效果，原因是 postcss 本身其实不具备修改 css 的功能，还需要额外的插件才行。</p>
<h2 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a>autoprefixer</h2><p>安装插件 autoprefixer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>修改配置文件为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>)],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="postcss-preset-env"><a href="#postcss-preset-env" class="headerlink" title="postcss-preset-env"></a>postcss-preset-env</h2><p>安装 postcss-preset-env。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add postcss-preset-env -D</span><br></pre></td></tr></table></figure>

<p>修改 test.css 内容为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#123456</span>78;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postcss-loader 配置的 plugins 中增加以下内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>打包以后颜色会以 rgba 形式展示。</p>
<h2 id="避免重复配置"><a href="#避免重复配置" class="headerlink" title="避免重复配置"></a>避免重复配置</h2><p>为了避免在 css-loader 和 less-loader 中都要进行重复的配置，postcss 还支持我们通过配置文件进行配置。</p>
<p>根目录下新建文件 postcss.config.js，内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>), <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们就不需要在 webpack.config.js 中书写 postcss-loader 的 plugins 了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="filer-loader"><a href="#filer-loader" class="headerlink" title="filer-loader"></a>filer-loader</h1><h2 id="处理-img-标签"><a href="#处理-img-标签" class="headerlink" title="处理 img 标签"></a>处理 img 标签</h2><p>在 src 文件夹下新建文件夹 img，里面塞入一张图片。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/123112132122.jpg"></p>
<p>在 js 文件夹下新建文件 image.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imgSrc <span class="keyword">from</span> <span class="string">&quot;../img/ai.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  img.src = imgSrc;</span><br><span class="line">  div.appendChild(img);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> setImage;</span><br></pre></td></tr></table></figure>

<p>修改 index.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setImage <span class="keyword">from</span> <span class="string">&quot;./js/image&quot;</span>;</span><br><span class="line"></span><br><span class="line">setImage();</span><br></pre></td></tr></table></figure>

<p>打包以后报错缺少 loader。</p>
<p>安装 file-loader。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add file-loader -D</span><br></pre></td></tr></table></figure>

<p>修改 webpack.config.js，添加如下内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;file-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="处理-css-背景图片"><a href="#处理-css-背景图片" class="headerlink" title="处理 css 背景图片"></a>处理 css 背景图片</h2><p>修改 js/image.js 为以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;../css/bg.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> backgroundImg = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  backgroundImg.className = <span class="string">&quot;bg-img&quot;</span>;</span><br><span class="line">  div.appendChild(backgroundImg);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> setImage;</span><br></pre></td></tr></table></figure>

<p>css 文件夹下新建文件 bg.css，内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">../img/ai.jpg</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先删除 dist 目录，再运行打包命令。此时发现 dist 目录下会出现两张图片。</p>
<p>其中一张是正常的，另一张点击打开以后内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220124143938.png"></p>
<p>里面的文本内容是一个指向我们需要的图片的导出语句。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220124144219.png"></p>
<p>这是因为图片是嵌在 css-loader 里面，没有被 file-loader 处理。</p>
<p>css-loader 会把 url 路径处理为 require 语句，而 require 语句使用时需要把 css-loader 的 esModule 属性设置为 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>处理以后打包问题就解决了。</p>
<h1 id="图片名称和路径设置"><a href="#图片名称和路径设置" class="headerlink" title="图片名称和路径设置"></a>图片名称和路径设置</h1><ul>
<li>[ext] 拓展名</li>
<li>[name] 文件名</li>
<li>[hash] 哈希</li>
<li>[hash:<length>] 哈希截取长度</li>
<li>[path] 文件路径</li>
</ul>
<p>修改 webpack.config.js 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;[name].[hash:6].[ext]&quot;</span>,</span><br><span class="line">        <span class="attr">outputPath</span>: <span class="string">&quot;img&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h1><p>安装 url-loader。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add url-loader -D</span><br></pre></td></tr></table></figure>

<p>把配置文件的 file-loader 修改为 url-loader，进行打包。</p>
<p>打包后发现页面显示正常，但是 dist 目录下没有出现 img 文件夹。</p>
<p>它会以 base64 形式把图片嵌入代码中。</p>
<h1 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h1><p><strong>url-loader VS file-loader</strong></p>
<ul>
<li>url-loader 会把文件转换为 base64 格式，可以减少请求次数，但是会增加单次请求文件的体积，不利于首屏渲染</li>
<li>file-loader 会将资源拷贝到指定目录，分开请求</li>
<li>url-loader 可以调用 file-loader，通过设置 limit 进行阈值限制，控制文件小于多少的时候使用 url-loader</li>
</ul>
<p>在 img 文件夹下加入一张新图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/ai2.jpg"></p>
<p>修改 image.js 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;../css/bg.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> imgSrc <span class="keyword">from</span> <span class="string">&quot;../img/ai2.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  img.src = imgSrc;</span><br><span class="line">  div.appendChild(img);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> backgroundImg = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  backgroundImg.className = <span class="string">&quot;bg-img&quot;</span>;</span><br><span class="line">  div.appendChild(backgroundImg);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> setImage;</span><br></pre></td></tr></table></figure>

<p>修改 webpack.config.js 文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;[name].[hash:6].[ext]&quot;</span>,</span><br><span class="line">        <span class="attr">outputPath</span>: <span class="string">&quot;img&quot;</span>,</span><br><span class="line">        <span class="attr">limit</span>: <span class="number">25</span> * <span class="number">1024</span>, <span class="comment">// 即 25Kb</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>运行打包命令，会发现只有一张较大的图片，另一张小的图片被以 base64 的形式嵌入文件里了。</p>
<h1 id="asset-处理图片"><a href="#asset-处理图片" class="headerlink" title="asset 处理图片"></a>asset 处理图片</h1><p>webpack5 之后不需要再使用 file-loader 和 url-loader 了。</p>
<ul>
<li>asset/resource =&gt; file-loader</li>
<li>asset/inline =&gt; url-loader</li>
<li>asset =&gt; 阈值限制</li>
</ul>
<p>修改 webpack.config.js 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">  type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果需要设置 limit，则修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">  type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parser</span>: &#123;</span><br><span class="line">    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">25</span> * <span class="number">1024</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="asset-处理字体图标"><a href="#asset-处理字体图标" class="headerlink" title="asset 处理字体图标"></a>asset 处理字体图标</h1><p>先去 <a href="https://www.iconfont.cn/">iconfont 官网</a>下载图标。</p>
<p>在 src 下新建文件夹 font，里面留着下面图片中这几个文件即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220124155141.png"></p>
<p>src/js 下新建文件 font.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFont</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> span = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>);</span><br><span class="line">  span.className = <span class="string">&quot;iconfont icon-gift lg-icon&quot;</span>;</span><br><span class="line">  div.appendChild(span);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> setFont;</span><br></pre></td></tr></table></figure>

<p>修改 index.js 内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setFont <span class="keyword">from</span> <span class="string">&quot;./js/font&quot;</span>;</span><br><span class="line"></span><br><span class="line">setFont();</span><br></pre></td></tr></table></figure>

<p>运行打包命令，报错，这是因为我们没有办法处理 iconfont 里面的路径。</p>
<p>我们直接把字体当成资源文件进行拷贝即可，因此可以使用前面所说的 asset/resource ，给 webpack.config.js 添加如下内容即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">  type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;font/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="plugin-VS-loader"><a href="#plugin-VS-loader" class="headerlink" title="plugin VS loader"></a>plugin VS loader</h1><ul>
<li>loader：webpack 只认识 js 和 json 文件，为了让 webpack 认识其它文件，如 css、jpg、png 等等，需要将其它类型文件<strong>转换</strong>为 js 格式，让 webpack 认识，这个转换的作用就是 loader 提供的。</li>
<li>plugin：plugin 可以做更多的事情，比如在打包开始之前做一些预处理，或者打包进行过程中做一些处理。loader 的作用时机只有当 webpack 要读取某个文件的时候，但是 plugin 的作用时机很多。</li>
</ul>
<h1 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h1><p>安装 clean-webpack-plugin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>作用是每次打包之前先把 dist 目录删除。</p>
<p>修改 webpack.config.js 内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220124162444.png"></p>
<p>在现版本的 webpack 中，已经不需要再加入此插件了，直接设置 output 的 clean 属性为 true 即可。</p>
<h1 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h1><p>安装 html-webpack-plugin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>引入 HtmlWebpackPlugin 类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>引入插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Webpack Learning&quot;</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p>这里打包以后产出的 js 文件是 defer 引入的。但是这样很不灵活，其实我们可以自己书写打印出的模板。</p>
<p>在 src 目录下新建文件夹 public。public 下新建文件 index.html。我们把 vue-cli 的 index.html 拷贝过来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">    &lt;%= htmlWebpackPlugin.options.title %&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled.</span><br><span class="line">        Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包以后报错说找不到 BASE_URL。webpack 可以自定义一些常量，我们在这还没有定义所以会报错。这里用到的是 webpack 内置的一个插件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">  <span class="attr">BASE_URL</span>: <span class="string">&#x27;&quot;./&quot;&#x27;</span>, <span class="comment">// 必须包裹两层引号，否则会在转译的时候以 const a = ./ 的形式出现，导致出错</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><p>Babel 的作用：JSX TS ES6+ =&gt; 转换为浏览器可以直接使用的语法</p>
<p>将 js/foo.js 内容修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello babel&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure>

<p>修改 index.js 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;./js/foo&quot;</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>打包后，main.js 内容含有箭头函数，可能在某些浏览器无法正常显示。我们需要使用 babel 处理。</p>
<h1 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h1><p>安装 @babel/core（核心模块）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core -D</span><br></pre></td></tr></table></figure>

<p>安装 babel-loader</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader -D</span><br></pre></td></tr></table></figure>

<p>安装插件 @babel/preset-env -D</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<p>修改配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后就可以把语法转成 ES5 了。</p>
<p>还可以新建文件 babel.config.js，里面写入一下配置内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就能简写 webpack.config.js 的信息为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h1><p>preset-env 并不能把所有的语法都转换，此时我们需要 polyfill。polyfill 即字面意思，填充，意思是填充一些旧版本没有的新语法（比如 Promise）。webpack4 会默认加入 polyfill，所以打包速度很不乐观，在 webpack5 就去掉了。</p>
<p>修改 index.js 内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promsie&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>安装 core-js、regenerator-runtime，注意此处不是开发依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add core-js regenerator-runtime</span><br></pre></td></tr></table></figure>

<p>然后修改 babel.config.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 index.js 中引入核心模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/stable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;regenerator-runtime/runtime&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promsie&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h1><p>可以进行一些资源的拷贝，如 favicon 图标。</p>
<p>安装 copy-webpack-plugin。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add copy-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>引入插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改 webpack.config.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">  <span class="attr">patterns</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">      <span class="attr">globOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p>修改 index.js 内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./js/font&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./js/image&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p>在 webpack.config.js 中添加 watch: true，如下所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220124182901.png"></p>
<p>当文件修改以后，会自动触发打包。但是这样会影响速度，因为每次保存都要重新打包一次。我们可以在本地开启一个服务器，把文件存储在内存中。</p>
<p>安装 webpack-dev-server。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>在 package.json 中配置命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;npx webpack serve&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>

<p>这样就可以实现开启本地服务器。</p>
<h1 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h1><p>HMR 即 hot-module-replacement，模块热替换，也叫热更新，就是可以对页面的局部内容进行替换。</p>
<p>首先修改 index.js 内容为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;HMR&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改 public 文件夹下的 index.html，增加一个输入框，用于验证热替换是否开启。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled.</span><br><span class="line">        Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>webpack.config.js 中加入内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>，</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>此时事实上还没有开启热更新。还需要把热更新的选项加入配置中。因为开发中通常是使用框架进行，所以这部分意义不大，省略。</p>
<h1 id="React-HMR"><a href="#React-HMR" class="headerlink" title="React HMR"></a>React HMR</h1><p>安装 @babel/preset-react，这是一个用于转换 jsx 语法的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-react -D</span><br></pre></td></tr></table></figure>

<p>安装 react。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>

<p>src 目录下新建文件 App.jsx，内容如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [title, setTitle] = useState(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>修改 index.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.jsx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>修改 babel.config.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时可以支持 React 语法，为了实现热更新，还需要引入其它插件。</p>
<p>安装 @pmmmwh/react-refresh-webpack-plugin 和 react-refresh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @pmmmwh/react-refresh-webpack-plugin react-refresh -D</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 中引入插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ReactRefreshWebpackPlugin(),</span><br></pre></td></tr></table></figure>

<p>修改 babel.config.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [[<span class="string">&quot;react-refresh/babel&quot;</span>]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时就能实现 React 的热更新了。</p>
<h1 id="devServer-其它属性设置"><a href="#devServer-其它属性设置" class="headerlink" title="devServer 其它属性设置"></a>devServer 其它属性设置</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>compress 表示是否压缩资源（使用 gzip），open 表示是否自动打开文件，当使用 History API 时，任意的 404 响应会被替代为 index.html。</p>
<p><strong>hot: ‘only’</strong> 和 <strong>hot: true</strong> 的区别：<br>如果文件报错了，修改成了对的以后，hot: true 会直接刷新整个页面，而 hot: ‘only’ 不会刷新整个页面。</p>
<h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><p>先开启一个 node 服务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;server is listening on port &quot;</span> + port);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>安装 axios</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure>

<p>修改 index.js 内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.jsx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&quot;http://127.0.0.1:8000/&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>此时请求出现跨域，需要设置代理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>,</span><br><span class="line">      <span class="comment">// 如果请求路径是 http://127.0.0.1:8000/api/user 这种就不需要重写</span></span><br><span class="line">      <span class="comment">// 如果请求路径是 http://127.0.0.1:8000/user 这种就需要重写</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^api&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>前端更改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;http://127.0.0.1:8000/&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时跨域问题得到解决。</p>
<h1 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h1><p>devtool 选项控制是否需要 source-map。</p>
<p>source-map 是一种映射方式，可以在调试的时候定位到源代码中的位置。</p>
<p>设置 <code>devtool: &#39;source-map&#39;</code>，运行 <code>yarn build</code>，dist 目录下除了原来的文件外还会多出一个 main.js.map，然后也可以定位到错误的具体位置了。</p>
<h1 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h1><p>通过 devtool 还可以进行更多的配置。</p>
<ul>
<li>source-map：错误信息有行也有列，推荐使用</li>
<li>inline-source-map：直接把 map 信息塞入 main.js 中，可以减少一次请求</li>
<li>cheap-source-map：错误信息只显示行，不显示列</li>
</ul>
<h1 id="ts-loader-编译-ts"><a href="#ts-loader-编译-ts" class="headerlink" title="ts-loader 编译 ts"></a>ts-loader 编译 ts</h1><p>src 目录下新建文件 index.ts，内容如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>修改 webpack.config.js 文件中的 entry 为 “./src/index.ts”</p>
<p>执行命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>生成 tsconfig.json 文件。</p>
<p>安装 ts-loader。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add ts-loader -D</span><br></pre></td></tr></table></figure>

<p>安装 typescript。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add typescript -D</span><br></pre></td></tr></table></figure>

<p>修改 webpack.config.js 文件内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">  use: [<span class="string">&quot;ts-loader&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="babel-loader-编译-ts"><a href="#babel-loader-编译-ts" class="headerlink" title="babel-loader 编译 ts"></a>babel-loader 编译 ts</h1><p>此时 ts 已经可以被正确编译，但是一些新的语法没有被转换为低级的语法，可能会存在兼容性问题，所以还需要 babel-loader 进行进一步的处理。</p>
<p>安装 @babel/preset-typescript</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-typescript -D</span><br></pre></td></tr></table></figure>

<p>修改 babel.config.js，内容为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-typescript&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [[<span class="string">&quot;react-refresh/babel&quot;</span>]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ts-loader 如果出现数据类型错误，会在 build 的时候暴露；而 babel-loader 可以进行 polyfill。</p>
<p>我们可以选择使用 babel-loader，然后通过命令进行类型校验。输入命令 <code>tsc</code>，可以实现数据类型的校验。</p>
<p>也可以选择直接修改打包命令如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220125001809.png"></p>
<h1 id="分离生产和开发环境"><a href="#分离生产和开发环境" class="headerlink" title="分离生产和开发环境"></a>分离生产和开发环境</h1><p>修改 package.json 中的脚本命令：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220125150959.png"></p>
<p>在根目录下新建文件夹 config，然后在 config 文件夹下新建 3 个文件 webpack.common.js、webpack.dev.js、webpack.prod.js。</p>
<p>安装 webpack-merge，来进行文件合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack-merge -D</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">25</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;font/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;Webpack Learning&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      <span class="attr">BASE_URL</span>: <span class="string">&#x27;&quot;./&quot;&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">          <span class="attr">globOptions</span>: &#123;</span><br><span class="line">            <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> ReactRefreshWebpackPlugin()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改 babel.config.js，区分生产和开发环境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-typescript&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">  config.plugins = [[<span class="string">&quot;react-refresh/babel&quot;</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>连载</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Webpack 从零打造 React 开发环境</title>
    <url>/2022/01/24/webpack-react-settings/</url>
    <content><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>先初始化项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure>

<p>运行命令初始化 package.json 文件。</p>
<p>安装 webpack 和 webpack-cli。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<h1 id="进行-ts-配置"><a href="#进行-ts-配置" class="headerlink" title="进行 ts 配置"></a>进行 ts 配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>修改 tsconfig.json，使用 create-react-app 的设置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;dom&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dom.iterable&quot;</span>,</span><br><span class="line">      <span class="string">&quot;esnext&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react-jsx&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在根目录下新建文件夹 config，书写配置信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.tsx&quot;</span>,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sass-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/i</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|gif|jpe?g)$/i</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">25</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/i</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;font/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/i</span>,</span><br><span class="line">        use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;Webpack Learning&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      <span class="attr">BASE_URL</span>: <span class="string">&#x27;&quot;./&quot;&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">          <span class="attr">globOptions</span>: &#123;</span><br><span class="line">            <span class="attr">ignore</span>: [<span class="string">&quot;**/index.html&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> ReactRefreshWebpackPlugin()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="安装-react"><a href="#安装-react" class="headerlink" title="安装 react"></a>安装 react</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>

<p>安装 ts 依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom -D</span><br></pre></td></tr></table></figure>

<h1 id="安装-babel-相关依赖"><a href="#安装-babel-相关依赖" class="headerlink" title="安装 babel 相关依赖"></a>安装 babel 相关依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/preset-react @babel/preset-typescript -D</span><br></pre></td></tr></table></figure>

<p>根目录新建文件 babel.config.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-typescript&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">  config.plugins = [[<span class="string">&quot;react-refresh/babel&quot;</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

<h1 id="安装-loader"><a href="#安装-loader" class="headerlink" title="安装 loader"></a>安装 loader</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add sass sass-loader css-loader postcss-loader postcss style-loader babel-loader -D</span><br></pre></td></tr></table></figure>

<h1 id="安装-plugin"><a href="#安装-plugin" class="headerlink" title="安装 plugin"></a>安装 plugin</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @pmmmwh/react-refresh-webpack-plugin react-refresh copy-webpack-plugin html-webpack-plugin -D </span><br></pre></td></tr></table></figure>

<h1 id="安装-postcss-依赖"><a href="#安装-postcss-依赖" class="headerlink" title="安装 postcss 依赖"></a>安装 postcss 依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add postcss-preset-env autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>新建文件 postcss.config.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>), <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="添加-browserslist"><a href="#添加-browserslist" class="headerlink" title="添加 browserslist"></a>添加 browserslist</h1><p>给 package.json 添加 browserslist。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;&gt;1%&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last 2 version&quot;</span>,</span><br><span class="line">  <span class="string">&quot;not dead&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="安装-webpack-dev-server"><a href="#安装-webpack-dev-server" class="headerlink" title="安装 webpack-dev-server"></a>安装 webpack-dev-server</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<h1 id="安装-webpack-merge"><a href="#安装-webpack-merge" class="headerlink" title="安装 webpack-merge"></a>安装 webpack-merge</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add webpack-merge -D</span><br></pre></td></tr></table></figure>

<h1 id="安装-cross-env"><a href="#安装-cross-env" class="headerlink" title="安装 cross-env"></a>安装 cross-env</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add cross-env -D</span><br></pre></td></tr></table></figure>

<h1 id="配置脚本命令"><a href="#配置脚本命令" class="headerlink" title="配置脚本命令"></a>配置脚本命令</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production npx webpack --config ./config/webpack.prod.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development npx webpack serve --config ./config/webpack.dev.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>React + Redux + Typescript + Axios 通用配置</title>
    <url>/2022/01/23/quick-react-settings/</url>
    <content><![CDATA[<p>本文代码对应<a href="https://github.com/Flower-F/react-common-setttings">仓库地址</a></p>
<p>本文主要包括以下内容配置</p>
<ul>
<li>creat-react-app 创建项目</li>
<li>配置 redux</li>
<li>配置 react-router</li>
<li>配置 json-server</li>
<li>配置 axios</li>
</ul>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>首先按照<a href="https://flower-f.github.io/2022/01/12/eslint-prettier-commitlint/">这篇文章</a>完成项目创建和基本配置，你也可以使用 webpack 进行基础配置。</p>
<p>把 src 文件夹下的 App.css、index.css、logo.svg 删除。</p>
<h1 id="配置-styled-components-Sass-Less"><a href="#配置-styled-components-Sass-Less" class="headerlink" title="配置 styled-components / Sass / Less"></a>配置 styled-components / Sass / Less</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add styled-components</span><br></pre></td></tr></table></figure>

<p>如果报错找不到类型文件，就执行以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @types/styled-components -D</span><br></pre></td></tr></table></figure>

<h1 id="修改默认样式"><a href="#修改默认样式" class="headerlink" title="修改默认样式"></a>修改默认样式</h1><p>在根目录新建文件 <code>globalStyle.ts</code>，内容如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createGlobalStyle &#125; <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> GlobalStyle = createGlobalStyle<span class="string">`</span></span><br><span class="line"><span class="string">  html, body &#123;</span></span><br><span class="line"><span class="string">    // 根据需要配置 background、line-height、font 等</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  * &#123;</span></span><br><span class="line"><span class="string">    margin: 0;</span></span><br><span class="line"><span class="string">    padding: 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  a &#123;</span></span><br><span class="line"><span class="string">    text-decoration: none;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ul, li &#123;</span></span><br><span class="line"><span class="string">    list-style: none;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h1 id="配置-react-router"><a href="#配置-react-router" class="headerlink" title="配置 react-router"></a>配置 react-router</h1><p>安装 react-router，进行路径配置。（这里以 V6 为准）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure>

<p>在 src 文件夹下新建文件夹 route，创建 index.tsx 文件。内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Routes, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#123; Suspense, lazy &#125; from &quot;react&quot;;</span><br><span class="line">import TopBar from &quot;pages/TopBar&quot;;</span><br><span class="line">import Home from &quot;pages/Home&quot;;</span><br><span class="line"></span><br><span class="line">const ReduxExample = lazy(() =&gt; import(&quot;pages/ReduxExample&quot;));</span><br><span class="line">const RequestExample = lazy(() =&gt; import(&quot;pages/RequestExample&quot;));</span><br><span class="line"></span><br><span class="line">const MyRouter = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">      &lt;Route path=&quot;/&quot; element=&#123;&lt;TopBar /&gt;&#125;&gt;</span><br><span class="line">        &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;redux&quot;</span><br><span class="line">          element=&#123;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;&gt;Loading...&lt;/&gt;&#125;&gt;</span><br><span class="line">              &lt;ReduxExample /&gt;</span><br><span class="line">            &lt;/Suspense&gt;</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;request&quot;</span><br><span class="line">          element=&#123;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;&gt;Loading...&lt;/&gt;&#125;&gt;</span><br><span class="line">              &lt;RequestExample /&gt;</span><br><span class="line">            &lt;/Suspense&gt;</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;*&quot;</span><br><span class="line">          element=&#123;</span><br><span class="line">            &lt;main style=&#123;&#123; padding: &quot;1rem&quot; &#125;&#125;&gt;</span><br><span class="line">              &lt;p&gt;404 Not Found&lt;/p&gt;</span><br><span class="line">            &lt;/main&gt;</span><br><span class="line">          &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default MyRouter;</span><br></pre></td></tr></table></figure>

<p>在 src 目录下的 index.tsx 中引入 <strong>BrowserRouter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure>

<p>代码修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  &lt;/React.StrictMode&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改 src 目录下的 APP.tsx，引入默认样式以及路由配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import MyRouter from &quot;routes&quot;;</span><br><span class="line">import &#123; GlobalStyle &#125; from &quot;./globalStyle&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt;</span><br><span class="line">      &lt;MyRouter /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>在 src 文件夹下新建文件夹 pages，用于存储页面。</p>
<p>文件夹 pages 下新建文件夹 RequestExample、ReduxExample、TopBar、Home，文件内容如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ReduxExample/index.tsx</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ReduxExample = () =&gt; &#123;</span><br><span class="line">  return &lt;h1&gt;ReduxExample&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(ReduxExample);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RequestExample/index.tsx</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const RequestExample = () =&gt; &#123;</span><br><span class="line">  return &lt;h1&gt;RequestExample&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(RequestExample);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Home/index.tsx</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Home = () =&gt; &#123;</span><br><span class="line">  return &lt;h1&gt;HomePage&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(Home);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TopBar/index.tsx</span><br><span class="line">import &#123; memo, useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; NavLink, Outlet, useLocation, useNavigate &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#123; NavBar, TopbarContainer &#125; from &quot;./style&quot;;</span><br><span class="line"></span><br><span class="line">const TopBar = () =&gt; &#123;</span><br><span class="line">  const &#123; pathname &#125; = useLocation();</span><br><span class="line">  const navigate = useNavigate();</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (pathname === &quot;/&quot;) &#123;</span><br><span class="line">      navigate(&quot;/home&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [pathname, navigate]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;TopbarContainer&gt;</span><br><span class="line">      &lt;div&gt;TopBar&lt;/div&gt;</span><br><span class="line">      &lt;NavBar&gt;</span><br><span class="line">        &lt;NavLink</span><br><span class="line">          to=&quot;/home&quot;</span><br><span class="line">          className=&#123;(&#123; isActive &#125;) =&gt; (isActive ? &quot;selected&quot; : &quot;unselected&quot;)&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Home Page</span><br><span class="line">        &lt;/NavLink&gt;</span><br><span class="line">        &lt;NavLink</span><br><span class="line">          to=&quot;/redux&quot;</span><br><span class="line">          className=&#123;(&#123; isActive &#125;) =&gt; (isActive ? &quot;selected&quot; : &quot;unselected&quot;)&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Redux Example</span><br><span class="line">        &lt;/NavLink&gt;</span><br><span class="line">        &lt;NavLink</span><br><span class="line">          to=&quot;/request&quot;</span><br><span class="line">          className=&#123;(&#123; isActive &#125;) =&gt; (isActive ? &quot;selected&quot; : &quot;unselected&quot;)&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Request Example</span><br><span class="line">        &lt;/NavLink&gt;</span><br><span class="line">      &lt;/NavBar&gt;</span><br><span class="line">      &lt;Outlet /&gt;</span><br><span class="line">    &lt;/TopbarContainer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(TopBar);</span><br></pre></td></tr></table></figure>

<p>上面这段代码的 <code>&lt;Outlet /&gt;</code> 是为了能够渲染下一级的路由。因为目前 react-router-dom@6 在 ts 环境下不支持重定向，所以要先用 <code>useEffect</code> 强制重定向。</p>
<p>给 TopBar 加上一些简单的样式，方便我们查看。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TopBar/style.ts</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TopbarContainer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  .selected &#123;</span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">    text-decoration: underline;</span></span><br><span class="line"><span class="string">    cursor: pointer;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  .unselected &#123;</span></span><br><span class="line"><span class="string">    color: black;</span></span><br><span class="line"><span class="string">    cursor: default;</span></span><br><span class="line"><span class="string">    &amp;:hover &#123;</span></span><br><span class="line"><span class="string">      text-decoration: underline;</span></span><br><span class="line"><span class="string">      cursor: pointer;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NavBar = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex-direction: column;</span></span><br><span class="line"><span class="string">  gap: 10px;</span></span><br><span class="line"><span class="string">  margin: 20px 0;</span></span><br><span class="line"><span class="string">  border: 1px solid black;</span></span><br><span class="line"><span class="string">  width: 100px;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h1 id="配置-redux"><a href="#配置-redux" class="headerlink" title="配置 redux"></a>配置 redux</h1><p>首先安装依赖，这里处理异步使用的是 redux-thunk。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add redux redux-thunk react-redux immer</span><br></pre></td></tr></table></figure>

<p>在 src 文件夹下新建文件夹 store，再在 store 文件夹中新建文件 index.ts 和 reducer.ts。内容如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> reduxExampleReducer &#125; <span class="keyword">from</span> <span class="string">&quot;../pages/ReduxExample/store/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RootState &#123;</span><br><span class="line">  <span class="attr">reduxExample</span>: reduxExampleReducer.state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  <span class="attr">reduxExample</span>: reduxExampleReducer.reducer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, compose, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> windowWithReduxExtension = Window &amp;</span><br><span class="line">  <span class="keyword">typeof</span> globalThis &amp; &#123;</span><br><span class="line">    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: <span class="built_in">Function</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers =</span><br><span class="line">  (<span class="built_in">window</span> <span class="keyword">as</span> windowWithReduxExtension).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ||</span><br><span class="line">  compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>在 App.tsx 中注入 store。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Provider &#125; from &quot;react-redux&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt;</span><br><span class="line">      &lt;MyRouter /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>为了验证 Redux 配置是否正确，我们使用经典的 Counter 来验证。</p>
<p>在 src 下创建文件夹 components，再在 components 文件夹下新建文件夹 Counter。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Counter/index.tsx</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface CounterProps &#123;</span><br><span class="line">  count: number;</span><br><span class="line">  increment: () =&gt; void;</span><br><span class="line">  decrement: () =&gt; void;</span><br><span class="line">  reset: () =&gt; void;</span><br><span class="line">  incrementAsync: () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Counter = (&#123;</span><br><span class="line">  count,</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  reset,</span><br><span class="line">  incrementAsync,</span><br><span class="line">&#125;: CounterProps) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;Count: &#123;count&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;decrement&#125;&gt;-1&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;reset&#125;&gt;Reset&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;incrementAsync&#125;&gt;+1 (1s delay)&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(Counter);</span><br></pre></td></tr></table></figure>

<p>在 ReduxExample 目录下创建文件夹 store，在 store 文件夹下新建文件 index.ts、store.ts、constants.ts、actions.ts。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/constants.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&quot;INCREMENT&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&quot;DECREMENT&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RESET = <span class="string">&quot;RESET&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT_ASYNC = <span class="string">&quot;INCREMENT_ASYNC&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/actions.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Dispatch &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> (&#123; <span class="attr">type</span>: actionTypes.INCREMENT &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">() =&gt;</span> (&#123; <span class="attr">type</span>: actionTypes.DECREMENT &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reset = <span class="function">() =&gt;</span> (&#123; <span class="attr">type</span>: actionTypes.RESET &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementAsync = <span class="function">() =&gt;</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="attr">type</span>: actionTypes.INCREMENT_ASYNC,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/reducer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AnyAction &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">&quot;immer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> CounterState &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState: CounterState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reduxExampleReducer = produce(</span><br><span class="line">  <span class="function">(<span class="params">state: CounterState, action: AnyAction</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> actionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">case</span> actionTypes.INCREMENT_ASYNC:</span><br><span class="line">        state.count = state.count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> actionTypes.DECREMENT:</span><br><span class="line">        state.count = state.count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> actionTypes.RESET:</span><br><span class="line">        state.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultState</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&quot;./actions&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actions, constants &#125;;</span><br></pre></td></tr></table></figure>

<p>修改 ReduxExample，进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Counter from &quot;components/Counter&quot;;</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;</span><br><span class="line">import &#123; RootState &#125; from &quot;store/reducer&quot;;</span><br><span class="line">import &#123; actions &#125; from &quot;./store&quot;;</span><br><span class="line"></span><br><span class="line">const ReduxExample = () =&gt; &#123;</span><br><span class="line">  const &#123; count &#125; = useSelector((state: RootState) =&gt; (&#123;</span><br><span class="line">    count: state.reduxExample.count,</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  const dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  const increment = () =&gt; &#123;</span><br><span class="line">    dispatch(actions.increment());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const decrement = () =&gt; &#123;</span><br><span class="line">    dispatch(actions.decrement());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const reset = () =&gt; &#123;</span><br><span class="line">    dispatch(actions.reset());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const incrementAsync = () =&gt; &#123;</span><br><span class="line">    dispatch(actions.incrementAsync());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;ReduxExample&lt;/h1&gt;</span><br><span class="line">      &lt;Counter</span><br><span class="line">        count=&#123;count&#125;</span><br><span class="line">        increment=&#123;increment&#125;</span><br><span class="line">        decrement=&#123;decrement&#125;</span><br><span class="line">        reset=&#123;reset&#125;</span><br><span class="line">        incrementAsync=&#123;incrementAsync&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(ReduxExample);</span><br></pre></td></tr></table></figure>

<h1 id="配置-json-server"><a href="#配置-json-server" class="headerlink" title="配置 json-server"></a>配置 json-server</h1><p>json-server 是我认为的一种比较不错的 mock 数据方法。</p>
<p>如果还没有安装的话先全局一下安装 json-server。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure>

<p>在根目录下新建文件夹 <code>__mock__</code>，然后在文件夹下新建文件 <code>db.json</code>。文件内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;subjects&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;html&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;css&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;js&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 3000 端口已经被我们的页面占用了，所以我们要换一个端口运行命令启动 json-server。为了便捷我们可以在 <code>package.json</code> 中加入新的脚本命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220123172231.png"></p>
<p>配置完成后，运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn server</span><br></pre></td></tr></table></figure>

<p>即可在 <a href="http://localhost:3001/">http://localhost:3001</a> 开启 json-server。</p>
<p>在浏览器输入路径 <a href="http://localhost:3001/subjects">http://localhost:3001/subjects</a> ，可以看到 <code>db.json</code> 中的数据。</p>
<h1 id="配置-axios"><a href="#配置-axios" class="headerlink" title="配置 axios"></a>配置 axios</h1><p>执行命令安装 axios。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure>

<p>在 src 目录下新建文件夹 api，并在 api 文件夹下新建文件 config.ts、request.ts。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/config.ts</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseUrl = <span class="string">&quot;http://localhost:3001&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: baseUrl,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; axiosInstance &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; axiosInstance &#125; <span class="keyword">from</span> <span class="string">&quot;./config&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getSubjectsRequest = &lt;T=any&gt;() =&gt; &#123;</span><br><span class="line">  return axiosInstance.get&lt;T&gt;(&quot;/subjects&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编写组件 SubjectList 来验证 axios 配置。</p>
<p>在 components 文件夹下新建文件夹 SubjectList。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SubjectList.tsx</span><br><span class="line">import &#123; memo &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">interface Subject &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  title: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SubjectListProps &#123;</span><br><span class="line">  list: Subject[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const SubJectList = (&#123; list &#125;: SubjectListProps) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map((item) =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &#123;item.id&#125; - &#123;item.title&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(SubJectList);</span><br></pre></td></tr></table></figure>

<p>在 SubjectList 文件夹下新建 store 文件夹。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/constants.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_SUBJECTS = <span class="string">&quot;CHANGE_SUBJECTS&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/reducer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AnyAction &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">&quot;immer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Subject &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RequestExampleState &#123;</span><br><span class="line">  <span class="attr">subjectList</span>: Subject[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState: RequestExampleState = &#123;</span><br><span class="line">  <span class="attr">subjectList</span>: [],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> requestExampleReducer = produce(</span><br><span class="line">  <span class="function">(<span class="params">state: RequestExampleState, action: AnyAction</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> actionTypes.CHANGE_SUBJECTS:</span><br><span class="line">        state.subjectList = action.data;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultState</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/actions.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getSubjectsRequest &#125; <span class="keyword">from</span> <span class="string">&quot;api/request&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Dispatch &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RequestExampleState &#125; <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeSubjectList = <span class="function">(<span class="params">data: RequestExampleState</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">type</span>: actionTypes.CHANGE_SUBJECTS,</span><br><span class="line">  data,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getSubjectList = <span class="function">() =&gt;</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  getSubjectsRequest&lt;&#123; <span class="attr">list</span>: RequestExampleState &#125;&gt;()</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> action = changeSubjectList(data.list);</span><br><span class="line">      dispatch(action);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;subjects 传输错误&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&quot;./actions&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actions, constants &#125;;</span><br></pre></td></tr></table></figure>

<p>然后把 reducer 导入全局：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/reducer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> reduxExampleReducer &#125; <span class="keyword">from</span> <span class="string">&quot;pages/ReduxExample/store/&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> requestExampleReducer &#125; <span class="keyword">from</span> <span class="string">&quot;pages/RequestExample/store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RootState &#123;</span><br><span class="line">  <span class="attr">requestExample</span>: requestExampleReducer.RequestExampleState;</span><br><span class="line">  reduxExample: reduxExampleReducer.CounterState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  <span class="attr">reduxExample</span>: reduxExampleReducer.reduxExampleReducer,</span><br><span class="line">  <span class="attr">requestExample</span>: requestExampleReducer.requestExampleReducer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改 RequestExample/index.tsx，内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import SubjectList from &quot;components/SubjectList&quot;;</span><br><span class="line">import &#123; memo, useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;</span><br><span class="line">import &#123; RootState &#125; from &quot;store/reducer&quot;;</span><br><span class="line">import &#123; actions &#125; from &quot;./store&quot;;</span><br><span class="line"></span><br><span class="line">const RequestExample = () =&gt; &#123;</span><br><span class="line">  const &#123; list &#125; = useSelector((state: RootState) =&gt; (&#123;</span><br><span class="line">    list: state.requestExample.subjectList,</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  const dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  const getSubjectList = () =&gt; &#123;</span><br><span class="line">    dispatch(actions.getSubjectList());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (!list.length) &#123;</span><br><span class="line">      getSubjectList();</span><br><span class="line">    &#125;</span><br><span class="line">    // eslint-disable-next-line react-hooks/exhaustive-deps</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;RequestExample&lt;/h1&gt;</span><br><span class="line">      &lt;SubjectList list=&#123;list&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default memo(RequestExample);</span><br></pre></td></tr></table></figure>

<p>完成任务！</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 6 天（下）</title>
    <url>/2022/01/21/byte-fe-training-6-part-two/</url>
    <content><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>Cross-Site Scripting，跨站脚本攻击。指攻击者通过某种方式把恶意脚本注入你写的页面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121214536.png"></p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul>
<li>开发者盲目相信用户提交的内容</li>
<li>直接把用户的提交转换成了 DOM，如 <code>document.write(xxx)</code>、<code>elem.innerHTML = xxx</code></li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>通常难以从 UI 上感知</li>
<li>窃取用户信息（cookie / token）</li>
<li>因为可以操作 js，所以可以绘制 UI，诱骗用户填写表单</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; content, id &#125; = ctx.request.body;</span><br><span class="line">  <span class="comment">// 没有对 content 进行过滤</span></span><br><span class="line">  <span class="keyword">await</span> db.save(&#123;</span><br><span class="line">    content,</span><br><span class="line">    id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; content &#125; = <span class="keyword">await</span> db.query(&#123;</span><br><span class="line">    <span class="attr">id</span>: ctx.query.id</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 又没有对 content 进行过滤</span></span><br><span class="line">  ctx.body = <span class="string">`&lt;div&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导致攻击：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121215645.png"></p>
<h2 id="Stored-XSS-存储型"><a href="#Stored-XSS-存储型" class="headerlink" title="Stored XSS 存储型"></a>Stored XSS 存储型</h2><ul>
<li>恶意脚本被保存在数据库中</li>
<li>访问页面 -&gt; 读数据 -&gt; 被攻击</li>
<li>危害最大，对全部用户可见</li>
</ul>
<p>比如说一个用户在视频中插入一个 XSS 攻击，然后某一刻脚本被启动了，此时所有的在浏览这个页面的用户都会被脚本攻击，造成信息泄露。</p>
<h2 id="Reflected-XSS-反射型"><a href="#Reflected-XSS-反射型" class="headerlink" title="Reflected XSS 反射型"></a>Reflected XSS 反射型</h2><p>不涉及数据库，而是从 URL 进行攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220034.png"></p>
<p>把字段直接生成 HTML 字段，然后被成功攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220057.png"></p>
<h2 id="Dom-based-XSS"><a href="#Dom-based-XSS" class="headerlink" title="Dom-based XSS"></a>Dom-based XSS</h2><p>不需要服务器参与，恶意攻击的发起与执行都在浏览器完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220034.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220433.png"></p>
<h2 id="Mutation-XSS"><a href="#Mutation-XSS" class="headerlink" title="Mutation XSS"></a>Mutation XSS</h2><p>利用了浏览器渲染 DOM 的特性，对于不同的浏览器执行会有区别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220622.png"></p>
<p>代码会被渲染为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220828.png"></p>
<p>又由于 src 属性不符合规范，然后会触发 <code>onerror</code> 事件，也就完成了 XSS 攻击。</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>Cross-site request forgery，跨站请求伪造</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>用户不知情</li>
<li>利用用户权限</li>
<li>构造指定的 HTTP 请求，窃取或修改用户的敏感信息</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221305.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221625.png"></p>
<p>在这个例子中，用户并没有直接请求银行，但是这个请求却被成功执行了，这就是一个经典的 CSRF 攻击。</p>
<h1 id="Injection-注入"><a href="#Injection-注入" class="headerlink" title="Injection 注入"></a>Injection 注入</h1><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221710.png"></p>
<p>删库跑路示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121223501.png"></p>
<p>其余注入：</p>
<ul>
<li>CLI</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121224200.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121224547.png"></p>
<p>因为没有过滤导致成功删除跑路</p>
<ul>
<li>读取 + 修改</li>
</ul>
<p>以 Nginx 为例，如果用户可以读取 Nginx 的配置文件，就能把我们的网站转到另一个网站</p>
<ul>
<li>SSRF Server-Side Request Forgery（严格来说不算注入）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232106.png"></p>
<h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p>Denial of Service，服务拒绝。通过某种方式构造特定的请求，导致服务器资源被显著消耗，来不及响应更多的请求，导致请求积压，进而引发雪崩效应。</p>
<h2 id="Regex-DOS"><a href="#Regex-DOS" class="headerlink" title="Regex DOS"></a>Regex DOS</h2><h2 id="正则贪婪模式"><a href="#正则贪婪模式" class="headerlink" title="正则贪婪模式"></a>正则贪婪模式</h2><p><strong>书写正则的时候是否写 ?</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232454.png"></p>
<p>这里的第一行就是贪婪模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232755.png"></p>
<p>因为贪婪引发回溯</p>
<h2 id="DDOS-分布式拒绝服务"><a href="#DDOS-分布式拒绝服务" class="headerlink" title="DDOS 分布式拒绝服务"></a>DDOS 分布式拒绝服务</h2><p>短时间内，收到大量来自僵尸设备的请求流量，服务器不能及时完成全部的请求，导致请求堆积，进而引发雪崩效应，无法响应新的请求。</p>
<p><em>不搞复杂的，量大就完事儿</em></p>
<h3 id="攻击特点"><a href="#攻击特点" class="headerlink" title="攻击特点"></a>攻击特点</h3><ul>
<li>直接访问 IP 而不是域名</li>
<li>使用任意的 API</li>
<li>消耗掉大量的带宽，直至耗尽</li>
</ul>
<h3 id="洪水攻击"><a href="#洪水攻击" class="headerlink" title="洪水攻击"></a>洪水攻击</h3><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121233159.png"></p>
<p>攻击者发起大量的 TCP 请求，然后就会产生大量的 SYN，发送给服务器。然后服务器就会产生大量的 ACK 和 SYN 给攻击者。但是，攻击者不会返回第三次 ACK，进而导致三次握手失败，连接无法被释放，于是很快就会到达最大连接次数，所有的新请求就无法被响应。</p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121233703.png"></p>
<p>为什么中间人攻击可以成立？</p>
<ul>
<li>HTTP 报文使用明文方式发送，可能被第三方窃听。</li>
<li>HTTP 报文可能被第三方拦截后修改通信内容，接收方没有办法发现报文内容的修改。</li>
<li>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</li>
</ul>
<h1 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h1><ul>
<li>永远不要信任用户提交的任何内容</li>
<li>永远不要把用户提交的内容直接转换成 DOM，而应该转换成字符串</li>
<li>主流的框架（React &amp; Vue）其实默认会防御 XSS 攻击</li>
</ul>
<p><strong>如果有需求不讲武德，必须动态生成 DOM 呢？</strong></p>
<ul>
<li>如果要把 string 直接生成 DOM，必须要对 string 进行转义</li>
<li>如果允许上传 SVG 文件，需要对 SVG 文件进行扫描，因为 SVG 中允许嵌套 script 标签</li>
<li>如果允许用户自定义跳转链接，必须进行检查过滤<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121234430.png"><br>像上图这样，用户可以插入 js 代码</li>
<li>如果允许自定义样式，必须进行检查过滤<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121234605.png"></li>
</ul>
<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>Content Security Policy</p>
<ul>
<li>允许开发者定义哪些源（域名）是安全的</li>
<li>来自安全源的脚本可以执行，否则直接报错</li>
<li>对于 eval 或内联的脚本直接报错</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235018.png"></p>
<p>第一行：只允许同源；第二行：除了同源之外，还另外允了 domain.com</p>
<p>我们也可以在浏览器端进行设置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235151.png"></p>
<h1 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h1><p>只要我们限制请求的来源，就可以限制伪造请求。可以根据 Origin 或者 Referer 判断。</p>
<h2 id="token-防御机制"><a href="#token-防御机制" class="headerlink" title="token 防御机制"></a>token 防御机制</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235423.png"></p>
<ul>
<li>token 必须和具体的用户绑定，才能确保不会被其它的用户所利用。</li>
<li>token 必须有过期时间，否则万一 token 泄露，之前的所有请求都可以被利用</li>
</ul>
<h2 id="iframe-攻击"><a href="#iframe-攻击" class="headerlink" title="iframe 攻击"></a>iframe 攻击</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235650.png"></p>
<p>首先在视觉上，让 button 覆盖住 iframe，然后用户就看不出来了。接着通过 button 的设置导致点击事件穿透了，然后传递给了 iframe，iframe 中的请求没有跨域，因此可以完成攻击。</p>
<p>可以设置 HTTP 响应头 <code>X-Frame-Options: DENY/SAMEORIGIN</code> （不允许加载 iframe 或只允许加载同源的 iframe）</p>
<h2 id="CSRF-反模式"><a href="#CSRF-反模式" class="headerlink" title="CSRF 反模式"></a>CSRF 反模式</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122000110.png"></p>
<p>GET !== GET + POST</p>
<p>一旦被攻击，信息不单止可能泄露，甚至还会被篡改。</p>
<h2 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h2><p>限制 cookie 的 domain 属性。我页面的 cookie 只能为我所用，只有同域才能使用这个 cookie，第三方服务的请求不能带上我页面的 cookie。</p>
<p><strong>但是如果服务依赖于第三方的 cookie 怎么办？</strong></p>
<p>比如内嵌了一个 b 站的播放器，需要识别用户的登录状态。</p>
<p>可以设置 <code>SetCookie: SameSite=None; Secure;</code></p>
<p>即不限制 same site，但是必须确保 cookie 是安全的（只能通过 HTTPS 传输）。</p>
<p><strong>SameSite VS 同源策略</strong>：SameSite 主要针对 cookie，同源策略 针对的是请求的资源。</p>
<h2 id="防御-CSRF-的正确姿势"><a href="#防御-CSRF-的正确姿势" class="headerlink" title="防御 CSRF 的正确姿势"></a>防御 CSRF 的正确姿势</h2><p>用 Node 做一个中间件防范攻击。</p>
<h1 id="Injection-防御"><a href="#Injection-防御" class="headerlink" title="Injection 防御"></a>Injection 防御</h1><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>对 SQL 语句做一些 prepare 处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122095147.png"></p>
<h2 id="其余注入"><a href="#其余注入" class="headerlink" title="其余注入"></a>其余注入</h2><ul>
<li>命令不要通过 sudo 执行，不要给 root 权限</li>
<li>拒绝像 rm 这种极其危险的行为</li>
<li>对 URL 类型参数进行协议、域名、IP 等的限制</li>
</ul>
<h1 id="DOS-防御"><a href="#DOS-防御" class="headerlink" title="DOS 防御"></a>DOS 防御</h1><h2 id="Regex-DOS-1"><a href="#Regex-DOS-1" class="headerlink" title="Regex DOS"></a>Regex DOS</h2><ul>
<li>避免写出贪婪的正则匹配</li>
<li>扫描代码找出里面的所有正则，然后做正则性能测试</li>
<li>拒绝使用用户提供的正则</li>
</ul>
<h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p>过滤：</p>
<ul>
<li>负载均衡</li>
<li>API 网关</li>
</ul>
<p>抗量：</p>
<ul>
<li>快速自动扩容</li>
<li>非核心服务降级</li>
</ul>
<h1 id="传输层防御"><a href="#传输层防御" class="headerlink" title="传输层防御"></a>传输层防御</h1><p>使用 HTTPS，其中 HTTP3 内置了 TLS</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/31121131121.png"></p>
<h1 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h1><p>HTTP Strict Transport Security，HTTO 严格传输安全协议。</p>
<p>HSTS 的作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。服务器开启 HSTS 的方法是，当客户端通过 HTTPS 发出请求时，在服务器返回的超文本传输协议（HTTP）响应头中包含 Strict-Transport-Security 字段。非加密传输时设置的 HSTS 字段无效。<br>比如，<a href="https://example.com/">https://example.com/</a> 的响应头含有 Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：</p>
<ul>
<li>在接下来的 31536000 秒（即一年）中，浏览器向 example.com 或其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如，用户点击超链接或在地址栏输入 <a href="http://www.example.com/">http://www.example.com/</a> ，浏览器应当自动将 http 转写成 https，然后直接向 <a href="https://www.example.com/">https://www.example.com/</a> 发送请求。</li>
<li>在接下来的一年中，如果 example.com 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。</li>
</ul>
<h1 id="SRI"><a href="#SRI" class="headerlink" title="SRI"></a>SRI</h1><p>Subresource Integrity，子资源完整性。</p>
<p>Web 性能优化中很重要的一点是加快请求完成速度，让可缓存的资源走 CDN 是最通用的做法。CDN 服务提供商通过分布在各地的节点，让用户从最近的节点加载内容，大幅提升速度。但是 CDN 的安全性一直是一个风险点：对于网站来说，让请求从第三方服务器经过，由第三方响应，安全方面肯定不如自己服务器可控。</p>
<p>我们知道 CSP（Content Security Policy） 的外链白名单机制可以在现代浏览器下减小 XSS 风险。但针对 CDN 内容被篡改而导致的 XSS，CSP 并不能防范，因为网站所使用的 CDN 域名，肯定在 CSP 白名单之中。这时候，SRI 就应运而生了。</p>
<p>它通过对比 hash 值，来确保文件的安全性，可以在一定程度上防范 XSS 攻击。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122101625.png"></p>
]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 6 天（上）</title>
    <url>/2022/01/21/byte-fe-training-6-part-one/</url>
    <content><![CDATA[<p>这部分的入门门槛太高了，等我先把基础学好了再研究吧。</p>
<h1 id="现代图形系统"><a href="#现代图形系统" class="headerlink" title="现代图形系统"></a>现代图形系统</h1><ul>
<li>光栅 Raster：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li>
<li>像素 Pixel：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li>
<li>帧缓存 Frame Buffer：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li>
<li>CPU (Central Processing Unit)：中央处理单元，负责逻辑计算。</li>
<li>GPU (Graphics Processing Unit)：图形处理单元，负责图形计算。</li>
</ul>
<h1 id="CPU-VS-GPU"><a href="#CPU-VS-GPU" class="headerlink" title="CPU VS GPU"></a>CPU VS GPU</h1><h1 id="WebGL-Startup"><a href="#WebGL-Startup" class="headerlink" title="WebGL Startup"></a>WebGL Startup</h1><ol>
<li>创建 WebGL 上下文（Canvas）</li>
<li>创建 WebGL Program（顶点选择器、片源选择器）</li>
<li>将数据存入缓冲区（比如顶点颜色）</li>
<li>将缓冲区数据读取到 GPU</li>
<li>GPU 执行 WebGL 程序，输出结果</li>
</ol>
]]></content>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 5 天（下）</title>
    <url>/2022/01/20/byte-fe-training-5-part-two/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>前端工程化</li>
<li>服务端</li>
<li>Electron 跨端桌面应用</li>
</ul>
<h1 id="编写-Http-Server"><a href="#编写-Http-Server" class="headerlink" title="编写 Http Server"></a>编写 Http Server</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收请求</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bufs = [];</span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buf</span>) =&gt;</span> &#123;</span><br><span class="line">    bufs.push(buf);</span><br><span class="line">  &#125;)</span><br><span class="line">  req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = Buffer.concat(bufs).toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">JSON</span>.parse(buf);</span><br><span class="line">      <span class="keyword">const</span> msg = result.msg || <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> responseMsg = &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">`receive: <span class="subst">$&#123;msg&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">      res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">      res.end(<span class="built_in">JSON</span>.stringify(responseMsg));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      res.end(<span class="string">&#x27;invalid json data&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发请求</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;Hello Byte Dance&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bufs = [];</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buf</span> =&gt;</span> &#123;</span><br><span class="line">    bufs.push(buf);</span><br><span class="line">  &#125;)</span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = Buffer.concat(bufs);</span><br><span class="line">    <span class="keyword">const</span> json = <span class="built_in">JSON</span>.parse(buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;json msg is: &#x27;</span>, json.msg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.end(body);</span><br></pre></td></tr></table></figure>

<h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folderPath = path.resolve(__dirname, <span class="string">&#x27;./static&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> info = url.parse(req.url);</span><br><span class="line">  <span class="keyword">const</span> filePath = path.resolve(folderPath, <span class="string">&#x27;.&#x27;</span> + info.pathname);</span><br><span class="line">  <span class="keyword">const</span> fileStream = fs.createReadStream(filePath);</span><br><span class="line"></span><br><span class="line">  fileStream.pipe(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ReactDomServer = <span class="built_in">require</span>(<span class="string">&#x27;react-dom/server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&#x27;h1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello SSR&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Nodejs&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;ReactDomServer.renderToString(</span></span></span><br><span class="line"><span class="subst"><span class="string">        React.createElement(App)</span></span></span><br><span class="line"><span class="subst"><span class="string">      )&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/body &gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><ul>
<li>守护进程：当进程退出以后</li>
<li>多进程：通过 cluster 模块便捷地利用多进程</li>
<li>记录进程状态：用于诊断</li>
</ul>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 5 天（上）</title>
    <url>/2022/01/20/byte-fe-training-5-part-one/</url>
    <content><![CDATA[<h1 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h1><ul>
<li>Hyper Text Transfer Protocol 超文本传输协议</li>
<li>应用层协议，基于 TCP 协议</li>
<li>分为两部分：请求 &amp; 响应</li>
<li>可拓展，比如可以自定义 Header</li>
<li>无状态，每个请求之间都是孤立的</li>
</ul>
<h1 id="HTTP-历史"><a href="#HTTP-历史" class="headerlink" title="HTTP 历史"></a>HTTP 历史</h1><h2 id="HTTP-0-9（单行协议）"><a href="#HTTP-0-9（单行协议）" class="headerlink" title="HTTP/0.9（单行协议）"></a>HTTP/0.9（单行协议）</h2><ul>
<li>只有一个请求行，没有请求头和请求体</li>
<li>请求方法只有 GET</li>
<li>响应只有 HTML 文档</li>
<li>文件格式只局限于 ASCII 编码</li>
<li>存在的问题：<ul>
<li>只支持 HTML 文件，其余类型文件无法传输</li>
<li>文件格式不再仅仅局限于 ASCII 编码</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1-0（可拓展性）"><a href="#HTTP-1-0（可拓展性）" class="headerlink" title="HTTP/1.0（可拓展性）"></a>HTTP/1.0（可拓展性）</h2><ul>
<li>引入了请求头和响应头</li>
<li>增加了状态码</li>
<li>支持多种的文档类型</li>
<li>提供了 Cache 机制（If-Modified-Since、Last-Modified、Expires）</li>
<li>请求头加入了 User-Agent</li>
<li>存在的问题：<ul>
<li>每次通信都需要经过建立 TCP 连接、传输数据、断开 TCP 连接三个阶段，开销很大</li>
<li>在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，也就是所谓的<strong>队头阻塞</strong></li>
<li>每个域名绑定唯一 IP 地址，因此一个服务器只支持一个域名</li>
<li>需要在响应头设置 Content-Length，然后浏览器再根据设置的数据大小来接收数据，对于动态生成的数据无能为力</li>
<li>不支持断点续传（在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度。）</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1-1（标准化协议）"><a href="#HTTP-1-1（标准化协议）" class="headerlink" title="HTTP/1.1（标准化协议）"></a>HTTP/1.1（标准化协议）</h2><ul>
<li>增加了持久连接，默认开启 Connection: Keep-Alive。只要浏览器或服务器没有明确断开连接，那么连接会一直保持</li>
<li>虚拟主机的发展可以让一个 IP 对应多个域名。<ul>
<li>请求头增加了 Host 字段，用来表示当前域名地址</li>
<li>域名分片机制：引入 CDN 之后，每个域名可以维护 6 个连接</li>
</ul>
</li>
<li>引入了 cookie 机制和安全机制</li>
<li>新的缓存方案（If-None-Match、ETag）</li>
<li>存在的问题：<ul>
<li>TCP 的慢启动</li>
<li>同时开启多条 TCP 连接时，连接之间会竞争带宽</li>
<li>队头阻塞问题依然无法解决</li>
<li>由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-2-（表现更优异）"><a href="#HTTP-2-（表现更优异）" class="headerlink" title="HTTP/2 （表现更优异）"></a>HTTP/2 （表现更优异）</h2><ul>
<li>HTTP/2 是一个二进制协议。在 HTTP/1.1 中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为<strong>帧</strong></li>
<li>实现了多路复用。HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了队头阻塞问题</li>
<li>使用了数据流的概念。<strong>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求</strong>。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li>实现了头信息压缩。由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，<strong>以后就不发送同样字段了，只发送索引号</strong>，这样就能提高速度了。</li>
<li>允许服务器推送。HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。</li>
<li>存在的问题：因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。这也导致了<strong>队头阻塞</strong>。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</li>
</ul>
<h2 id="HTTP-3（QUIC-协议）"><a href="#HTTP-3（QUIC-协议）" class="headerlink" title="HTTP/3（QUIC 协议）"></a>HTTP/3（QUIC 协议）</h2><ul>
<li>Quick UDP Internet Connection </li>
<li>基于 UDP 实现了类似 TCP 的流量控制、可靠传输机制</li>
<li>集成了 TLS 安全加密</li>
<li>实现了 HTTP/2 多路复用技术，QUIC 实现了在同一个物理连接中可以有多个独立的逻辑数据流，实现了数据流单独传输，解决了 TCP 队头阻塞的问题</li>
<li>实现了快速握手功能（因为是基于 UDP 的）</li>
<li>存在的问题：<ul>
<li>服务器和浏览器还没有对其提供较完整的支持</li>
<li>可能存在安全性问题</li>
</ul>
</li>
</ul>
<h1 id="常用请求方法"><a href="#常用请求方法" class="headerlink" title="常用请求方法"></a>常用请求方法</h1><table>
<thead>
<tr>
<th align="center">请求方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="left">请求指定的资源，并返回实体</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和已有资源的修改</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的内容</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="left">请求服务器删除指定的数据</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td align="left">在采取具体资源的请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="left">HTTP/1.1 协议中预留于能够将连接改为管道方式</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="left">类似于 GET 请求，只不过返回的响应中没有请求体</td>
</tr>
</tbody></table>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul>
<li>安全的方法：不好修改服务器数据，如 GET、HEAD、OPTIONS</li>
<li>幂等的方法：同样的请求执行一次，与连续执行多次效果相同。包括上面所有的安全方法，还包括 PUT、DELETE 这两个不安全但是幂等的方法</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码概览：</p>
<ul>
<li>1XX：请求已接受，正在继续处理</li>
<li>2XX：请求成功，处理完毕</li>
<li>3XX：重定向</li>
<li>4XX：客户端错误</li>
<li>5XX：服务端错误</li>
</ul>
<p>常见状态码总结：</p>
<table>
<thead>
<tr>
<th align="left">状态码 &amp; 英文描述</th>
<th align="left">详细说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100 Continue</td>
<td align="left">服务器收到了请求的一部分，并且希望客户端继续发送其余部分</td>
</tr>
<tr>
<td align="left">101 Switching Protocols</td>
<td align="left">切换协议，服务端根据客户端请求的头信息切换协议</td>
</tr>
<tr>
<td align="left">200 OK</td>
<td align="left">请求成功，且被服务端成功处理</td>
</tr>
<tr>
<td align="left">201 Created</td>
<td align="left">成功请求，且创建了新的资源</td>
</tr>
<tr>
<td align="left">202 Accepted</td>
<td align="left">服务器已接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">204 No Content</td>
<td align="left">请求成功处理，但是没有资源可以返回</td>
</tr>
<tr>
<td align="left">206 Partial Content</td>
<td align="left">服务器成功处理了部分 GET 请求</td>
</tr>
<tr>
<td align="left">301 Moved Permanently</td>
<td align="left">永久重定向。请求的资源被分配了新的 URL，之后应使用<strong>更改</strong>的URL</td>
</tr>
<tr>
<td align="left">302 Found</td>
<td align="left">临时重定向。表示请求的资源被分配了新的 URL，希望<strong>本次</strong>访问使用新的 URL</td>
</tr>
<tr>
<td align="left">304 Not Modified</td>
<td align="left"><strong>缓存</strong>相关的状态码。自从上次请求后，请求的资源未被修改过。 服务器返回此响应时，不会返回任何资源。客户端的请求中带有 If-Modified-Since 或者 If-None-Match</td>
</tr>
<tr>
<td align="left">307 Temporary Redirect</td>
<td align="left">类似 302，但是 307 会遵照浏览器标准，请求方法不会从 POST 变成 GET</td>
</tr>
<tr>
<td align="left">400 Bad Request</td>
<td align="left">请求报文中存在语法错误</td>
</tr>
<tr>
<td align="left">401 Unauthorized</td>
<td align="left">用户未授权</td>
</tr>
<tr>
<td align="left">403 Forbidden</td>
<td align="left">服务器拒绝该次访问</td>
</tr>
<tr>
<td align="left">404 Not Found</td>
<td align="left">服务器上无法找到请求的资源</td>
</tr>
<tr>
<td align="left">408 Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">500 Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">502 Bad Gateway</td>
<td align="left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</td>
</tr>
<tr>
<td align="left">503 Service Unavailable</td>
<td align="left">服务器超负载或正在进行停机维护，无法处理请求</td>
</tr>
</tbody></table>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>一种 API 设计风格，有以下特点：</p>
<ul>
<li>每个 URI 代表一种资源</li>
<li>URI 只用于表示资源的名称，而不包括资源的操作</li>
<li>接口应该使用标准的 HTTP 方法如 GET，PUT 和 POST，并遵循这些方法的<strong>语义</strong></li>
</ul>
<p>CRUD 应该遵循以下语义：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220120225230.png"></p>
<p>示例：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220120225441.png"></p>
<h2 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h2><table>
<thead>
<tr>
<th align="left">请求头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">浏览器可接受的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a></td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">资源属于什么 MIME 类型</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">用于指定缓存机制。常见的值有 no-cache（不直接使用缓存，要向服务器发起请求确认资源是否更改，也就是我们常说的<strong>协商缓存</strong>），no-store（不使用任何缓存），max-age=xxx（缓存内容在 xxx 秒后失效）</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">对应于服务端的 Last-Modified，若所请求的内容在指定的日期之后没有修改过，则返回 304 Not Modified，精度达到秒</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">对应于服务端的 ETag，若所请求的内容在指定的日期之后没有修改过，则返回 304 Not Modified，精度非常准确</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">有 cookie 而且同域的时候会自动带上</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器类型</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">若为 Keep-Alive，或者协议是 HTTP/1.1，则开启持久连接</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">一般用来表示重定向的地址</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">缓存过期时间，在此时间内不需要发起请求，可以直接使用缓存</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">授权信息</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">说明该页面的来源 URL。用处：防止盗链；避免 CSRF 攻击</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">类似于 Referer，把 URI 剥离成 {协议，域名，端口} 的三元组，用于指明当前请求来自于哪个站点。Origin 的出现就是为了实现跨域。</td>
</tr>
</tbody></table>
<h2 id="常用响应头"><a href="#常用响应头" class="headerlink" title="常用响应头"></a>常用响应头</h2><table>
<thead>
<tr>
<th align="left">响应头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Content-Type</td>
<td align="left">资源属于什么 MIME 类型</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">用于指定缓存机制。常见的值有 no-cache（不直接使用缓存，要向服务器发起请求确认资源是否更改，也就是我们常说的<strong>协商缓存</strong>），no-store（不使用任何缓存），max-age=xxx（缓存内容在 xxx 秒后失效）</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">最后修改时间。客户端可以通过 If-Modified-Since 请求头提供一个日期，只有改动时间迟于指定时间，才会返回新的资源，否则返回一个 304 Not Modified</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">资源特定的标识符。客户端可以通过 If-None-Match 请求头提供一个标识符，如果客户端标识符与服务端不同才会返回新的资源，否则返回一个 304 Not Modified</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置页面相关的 Cookie</td>
</tr>
<tr>
<td align="left">Access-Control-Allow-Origin</td>
<td align="left">服务器允许请求的 Origin，如果设置为 * 则表示允许所有的 Origin</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">缓存过期时间。在此时间内不需要发起请求，可以直接使用缓存</td>
</tr>
<tr>
<td align="left">Max-age</td>
<td align="left">本地缓存应该缓存多久，开启了 Cache-Control 后才生效</td>
</tr>
</tbody></table>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据 Expires 和 Cache-control 判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信</strong>。</p>
<p><strong>Expires VS max-age</strong></p>
<ul>
<li>Expires 是一个<strong>时间戳</strong>，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 Expires 的时间戳，如果本地时间小于 Expires 设定的过期时间，那么就直接去缓存中取这个资源。由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 Expires 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求，<strong>若服务器与客户端存在时差，将带来意料之外的结果</strong>。</li>
<li>max-age 是一个相对时间，这就意味着它有能力规避掉 Expires 可能会带来的时差问题。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的起始时间和当前时间都来源于客户端，因此能够实现更加精准的判断。</li>
<li>Cache-Control 的 max-age 配置项相对于 Expires 的优先级更高。当 Cache-Control 与 Expires 同时出现时，我们以 Cache-Control 为准。</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动，资源会被<strong>重定向到浏览器缓存</strong>（解释了为什么它是 3XX 开头），这种情况下网络请求对应的状态码是 304。</p>
<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h4><p>含义：指最后一次修改资源的时间。开启了协商缓存之后，我们的每次请求都会带上 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 Last-Modified 值。服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值，否则返回 304 Not Modified。</p>
<p>弊端：</p>
<ul>
<li>有时候可能我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li>
<li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since <strong>只能检查到以秒为最小计量单位</strong>的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li>
</ul>
<h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><p>Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是<strong>基于文件内容编码</strong>的，只要文件内容不同，它们对应的 Etag 就是不同的；相反，只要文件内容相同，ETag 就是相同的。因此 Etag 能够<strong>精准地感知文件的变化</strong>。它的作用原理和 If-Modified-Since 类似，都是客户端带上然后去跟服务端进行比较，不同就返回资源以及新的 ETag，相同就返回 304 Not Modified。</p>
<p>弊端：Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p>
<p>示例图：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121095649.png"><br>简单来说就是：</p>
<ul>
<li>有强缓存且新鲜，就用，否则，就看有没有协商缓存</li>
<li>协商缓存 ETag 优先级高于 If-Modified-Since</li>
<li>什么缓存都没有，或者缓存不新鲜，就去重新请求</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;cookie-name&gt;=&lt;cookie-value&gt;</code></td>
<td align="left">cookie 的键值对。</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 cookie。</td>
</tr>
<tr>
<td align="left">Domain</td>
<td align="left">指定 cookie 可以送达的主机名。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。</td>
</tr>
<tr>
<td align="left">Sec</td>
<td align="left">规定必须通过安全的 HTTPS 连接来传输 cookie。</td>
</tr>
<tr>
<td align="left">HttpOnly</td>
<td align="left">JS 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击。</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">规定 cookie 的最长有效时间。形式为符合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date">HTTP-Date</a> 规范的时间戳。</td>
</tr>
<tr>
<td align="left">Max-Age</td>
<td align="left">在 cookie 失效之前需要经过的秒数。假如 Expires 和 Max-Age 均存在，那么 Max-Age 优先级更高。</td>
</tr>
<tr>
<td align="left">SameSite=[Strict, Lax]</td>
<td align="left">允许服务器设定 cookie 不随着跨域请求一起发送，这样可以在一定程度上防范 CSRF 攻击。</td>
</tr>
</tbody></table>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ul>
<li>HTTP 报文使用<strong>明文</strong>方式发送，可能被第三方窃听。</li>
<li>HTTP 报文可能被第三方<strong>拦截</strong>后修改通信内容，接收方没有办法发现报文内容的修改。</li>
<li>HTTP 还存在认证的问题，第三方可以<strong>冒充</strong>他人参与通信。</li>
</ul>
<h2 id="HTTPS-的解决方案"><a href="#HTTPS-的解决方案" class="headerlink" title="HTTPS 的解决方案"></a>HTTPS 的解决方案</h2><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。优点有：</p>
<ul>
<li>所有的信息都是加密的，第三方没有办法窃听。</li>
<li>它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。</li>
<li>配备了身份证书，防止身份被冒充的情况出现。</li>
</ul>
<h2 id="TLS-握手安全的原理"><a href="#TLS-握手安全的原理" class="headerlink" title="TLS 握手安全的原理"></a>TLS 握手安全的原理</h2><ul>
<li>对称加密：双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。因此还需要非对称加密。</li>
<li>非对称加密：我们拥有两个秘钥，一个公钥，一个私钥。公钥是公开的，私钥是保密的。<strong>用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。</strong>我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，然后我们就可以对应的私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密速度很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</li>
<li>非对称与对称的权衡：因为对称加密的方式的缺点是无法保证秘钥的安全传输，非对称加密的缺点是加密速度很慢，因此我们可以<strong>用非对称加密的方式来对对称加密的密钥进行传输，然后以后的通信使用对称加密的方式来加密</strong>，这样就解决了两个方法各自存在的问题。<strong>注意，只有传输这个加密的密钥的时候我们才需要使用非对称的加密。</strong></li>
<li>数字证书：但是这样依然无法确保安全性。因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，拦截了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个<strong>信息摘要</strong>，然后让有公信力的认证中心（简称 CA ）用它的私钥对信息摘要加密，形成<strong>签名</strong>。最后将原始的信息和签名合在一起，称为<strong>数字证书</strong>。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最重要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。</li>
</ul>
<p>示例图：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/31121131121.png"></p>
<h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>静态资源方案：缓存 + CDN + 文件名 hash（确保用户能拿到最新的文件）</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>Content Delivery Network，内容分发网络，是由分布在不同区域的边缘节点服务器组成的分布式网络。开启 CDN 之后，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时也分担了源服务器的访问压力。</p>
<p><strong>是否开启 CDN 的区别</strong></p>
<p>不开启 CDN：<br>用户输入域名 -&gt; DNS 解析获取 IP -&gt; 向该 IP 对应服务器发送访问请求 -&gt; 返回资源</p>
<p>开启 CDN：<br>用户输入域名 -&gt; 智能 DNS 解析 -&gt; 获取缓存服务器 IP -&gt; 若缓存有目标资源，返回资源；若没有就向源服务器发起请求，把获取的资源保存到缓存服务器，再把资源返回给用户</p>
<h1 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h1><p>在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。这种方式减少了由登录产生的时间消耗，辅助了用户管理。</p>
<p>用户在授权访问后会获得一个凭证，之后访问相关的应用时也会带上这个凭证，所以用户就可以在不需要再次登录的情况下直接登录访问。</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>常用的跨域解决方案主要有五种：</p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>WebSocket</li>
<li>Node 正向代理</li>
<li>Nginx 反向代理</li>
</ul>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax 五部曲</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：创建 xhr 对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span><br><span class="line"><span class="comment">// 第三步：发送请求</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">// 第四步：绑定事件</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readState</span></span><br><span class="line">  <span class="comment">// 0 表示未初始化</span></span><br><span class="line">  <span class="comment">// 1 表示 open 完毕</span></span><br><span class="line">  <span class="comment">// 2 表示 send 完毕 </span></span><br><span class="line">  <span class="comment">// 3 表示服务端返回了部分结果 </span></span><br><span class="line">  <span class="comment">// 4 表示服务端返回了所有结果</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 第五步：处理结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>常见状态码总结</title>
    <url>/2022/01/19/status-code/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">状态码 &amp; 英文描述</th>
<th align="left">详细说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100 Continue</td>
<td align="left">服务器收到了请求的一部分，并且希望客户端继续发送其余部分</td>
</tr>
<tr>
<td align="left">101 Switching Protocols</td>
<td align="left">切换协议，服务端根据客户端请求的头信息切换协议</td>
</tr>
<tr>
<td align="left">200 OK</td>
<td align="left">请求成功，且被服务端成功处理</td>
</tr>
<tr>
<td align="left">201 Created</td>
<td align="left">成功请求，且创建了新的资源</td>
</tr>
<tr>
<td align="left">202 Accepted</td>
<td align="left">服务器已接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">204 No Content</td>
<td align="left">请求成功处理，但是没有资源可以返回</td>
</tr>
<tr>
<td align="left">206 Partial Content</td>
<td align="left">服务器成功处理了部分 GET 请求</td>
</tr>
<tr>
<td align="left">301 Moved Permanently</td>
<td align="left">永久重定向。请求的资源被分配了新的 URL，之后应使用<strong>更改</strong>的URL</td>
</tr>
<tr>
<td align="left">302 Found</td>
<td align="left">临时重定向。表示请求的资源被分配了新的 URL，希望<strong>本次</strong>访问使用新的 URL</td>
</tr>
<tr>
<td align="left">304 Not Modified</td>
<td align="left"><strong>缓存</strong>相关的状态码。自从上次请求后，请求的资源未被修改过。 服务器返回此响应时，不会返回任何资源。客户端的请求中带有 If-Modified-Since 或者 if-Match</td>
</tr>
<tr>
<td align="left">307 Temporary Redirect</td>
<td align="left">类似 302，但是 307 会遵照浏览器标准，请求方法不会从 POST 变成 GET</td>
</tr>
<tr>
<td align="left">400 Bad Request</td>
<td align="left">请求报文中存在语法错误</td>
</tr>
<tr>
<td align="left">401 Unauthorized</td>
<td align="left">用户未授权</td>
</tr>
<tr>
<td align="left">403 Forbidden</td>
<td align="left">服务器拒绝该次访问</td>
</tr>
<tr>
<td align="left">404 Not Found</td>
<td align="left">服务器上无法找到请求的资源</td>
</tr>
<tr>
<td align="left">408 Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">500 Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">502 Bad Gateway</td>
<td align="left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</td>
</tr>
<tr>
<td align="left">503 Service Unavailable</td>
<td align="left">服务器超负载或正在进行停机维护，无法处理请求</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 4 天（下）</title>
    <url>/2022/01/19/byte-fe-training-4-part-two/</url>
    <content><![CDATA[<h1 id="动画基本原理"><a href="#动画基本原理" class="headerlink" title="动画基本原理"></a>动画基本原理</h1><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>无论动画多么简单，始终需要定义两个基本状态，即开始状态和结束状态。没有它们，我们将无法定义插值状态，从而填补两者之间的空白。<br>插值可能是颜色，也可能是位置等属性，可以理解为是对某个上下文中一个值或多个值的估计。当图形的变化可以由线性方程表示，就是线性插值。</p>
<h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><ul>
<li>帧：连续变换的多张画面，其中的每一幅画面都是一帧。</li>
<li>帧率:用于度量一定时间段内的帧数，通常的测量单位是 FPS (frame per second)。</li>
<li>帧率与人眼：一般每秒 10-12 帧人会认为画面是连贯的，这个现象称为视觉暂留。对于一些电脑动画和游戏来说低于 30FPS 会感受到明显卡顿，目前主流的屏幕、显卡输出为 60FPS，效果会明显更流畅。</li>
</ul>
<h2 id="空白补全"><a href="#空白补全" class="headerlink" title="空白补全"></a>空白补全</h2><p>空白的补全方式有以下两种</p>
<ul>
<li>补间动画：传统动画，主画师绘制关键帧，交给清稿部门，清稿部门的补间动画师补充关键帧进行交付。（类比到这里， 补间动画师由浏览器来担任，如 keyframe，transition）</li>
<li>逐帧动画（Frame By Frame）：从词语来说意味着全片每一帧逐帧都是纯手绘。（如 css 的 steps 实现精灵动画）</li>
</ul>
<h1 id="前端动画分类"><a href="#前端动画分类" class="headerlink" title="前端动画分类"></a>前端动画分类</h1><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><p>优点:</p>
<ul>
<li>浏览器会对 CSS3 动画做一些优化，导致 CSS3 动画性能上稍有优势。（新建一个图层来跑动画）</li>
<li>CSS3 动画的代码相对简单。</li>
</ul>
<p>缺点:</p>
<ul>
<li>动画控制上不够灵活。</li>
<li>兼容性不佳。</li>
<li>部分动画无法实现。（视差效果、滚动动画）</li>
</ul>
<p>主要属性：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a>：可以用于图形的旋转、移动、缩放等</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition"><code>transition</code></a>：处理开始状态到结束状态的过渡效果</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation"><code>animation</code></a>：通过 keyframe 定义开始状态、结束状态以及多个中间态，相比于 <code>transition</code> 可以处理更复杂的动画</li>
</ul>
<h2 id="SVG-动画"><a href="#SVG-动画" class="headerlink" title="SVG 动画"></a>SVG 动画</h2><p>优点：通过矢量元素实现动画，不同的屏幕下均可获得较好的清晰度。可以用于实现一些特殊的效果，如：描字，形变，墨水扩散等。</p>
<p>缺点：使用方式较为复杂，过多使用可能会带来性能问题。</p>
<p>实现 SVG 动画通常有三种方式，SMIL、JS、CSS</p>
<h3 id="SMIL"><a href="#SMIL" class="headerlink" title="SMIL"></a>SMIL</h3><p>兼容性不理想，因此不过多讨论</p>
<h3 id="JS-操作-SVG"><a href="#JS-操作-SVG" class="headerlink" title="JS 操作 SVG"></a>JS 操作 SVG</h3><ul>
<li>Snap.svg</li>
<li>anime.js</li>
<li>HTML 原生的 Web Animation</li>
</ul>
<p>例一：<a href="https://codepen.io/jiangxiang/pen/MWmdjeY">SVG 文字变形</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">CSS 属性 filter</a>：可以将模糊或颜色偏移等效果应用于元素，它的属性 url 可以传入一个 svg</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elts.text2.style.filter = <span class="string">`blur(<span class="subst">$&#123;<span class="built_in">Math</span>.min(<span class="number">8</span> / fraction - <span class="number">8</span>, <span class="number">100</span>)&#125;</span>px)`</span>;</span><br><span class="line">elts.text2.style.opacity = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.pow(fraction, <span class="number">0.4</span>) * <span class="number">100</span>&#125;</span>%`</span>;</span><br><span class="line"></span><br><span class="line">fraction = <span class="number">1</span> - fraction;</span><br><span class="line">elts.text1.style.filter = <span class="string">`blur(<span class="subst">$&#123;<span class="built_in">Math</span>.min(<span class="number">8</span> / fraction - <span class="number">8</span>, <span class="number">100</span>)&#125;</span>px)`</span>;</span><br><span class="line">elts.text1.style.opacity = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.pow(fraction, <span class="number">0.4</span>) * <span class="number">100</span>&#125;</span>%`</span>;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码控制 <code>blur</code> 和 <code>opacity</code> 不断地变化。每次切换单词的时候，当它的模糊程度快没有，就直接通过透明度把它隐藏掉，造成一种文字溶解的错觉。</p>
<p>例二：<a href="https://codepen.io/jiangxiang/pen/eYWagxq">JS 画笔</a></p>
<p><a href="https://codepen.io/jiangxiang/pen/LYzvvxd">JS 画笔的原理</a>：<br><code>stroke-dashoffset</code>、<code>stroke-dasharray</code> 配合使用实现笔画效果。</p>
<ul>
<li>属性 <code>stroke-dasharray</code> 可控制用来描边的点划线的图案范式。它是一个数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2 等同于 5,3,2,5,3,2。</li>
<li><code>stroke-dashoffset</code> 属性指定了 dash 模式到路径开始的距离。（当使用了 <code>stroke-dasharray</code>，就进入了 dash 模式）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">line</span> <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5, 5&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;190&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">line</span> <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5, 10&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;30&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;190&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面第一个表示先走 5 像素实线，再走 5 像素的空白；第二个表示先走 5 像素实线，再走 10 像素空白。</p>
<p>计算 path 的长度：<code>path.getTotalLength()</code>，然后将 <code>stroke-dashoffset</code> 的值设置为该的长度，就能实现类似画画的效果。</p>
<h2 id="JS-动画"><a href="#JS-动画" class="headerlink" title="JS 动画"></a>JS 动画</h2><p>JS 可以通过操作 SVG、CSS、Canvas 等实现动画。</p>
<p>优点：</p>
<ul>
<li>使用灵活，同样在定义一个动画的 keyframe 序列时，可以根据不同的条件调节若干参数（JS 动画函数）改变动画方式。（CSS 会有非常多的代码冗余），对比于 CSS 的 keyframe 粒度更粗，CSS 本身的时间函数是有限的，这块 JS 可以弥补。</li>
<li>CSS 很难做到两个以上的状态转化。（要么使用关键帧，要么需要多个动画延时触发，再想到要对动画循环播放或暂停倒序等，复杂度极高）</li>
</ul>
<p>缺点:</p>
<ul>
<li>使用到 JS 运行时，调优方面不如 CSS 简单，CSS 调优方式固定。</li>
<li>对于性能和兼容性较差的浏览器，CSS 可以做到优雅降级，而 JS 需要额外的代码兼容。</li>
</ul>
<h2 id="对比与结论"><a href="#对比与结论" class="headerlink" title="对比与结论"></a>对比与结论</h2><ul>
<li>当 UI 元素采用较小的独立状态时，使用 CSS。</li>
<li>在需要对动画进行大量控制时，使用 JavaScript。</li>
<li>在特定的场景下可以使用 SVG，可以使用 CSS 或 JS 去操作 SVG 变化。</li>
</ul>
<h1 id="实现前端动画"><a href="#实现前端动画" class="headerlink" title="实现前端动画"></a>实现前端动画</h1><h2 id="animate-函数的实现"><a href="#animate-函数的实现" class="headerlink" title="animate 函数的实现"></a>animate 函数的实现</h2><p><strong>requestAnimationFrame VS setTimeout VS setInterval</strong></p>
<p>JavaScript 动画应该通过 <code>requestAnimationFrame</code> 实现。该内置方法允许设置回调函数以在<strong>浏览器准备重绘时</strong>运行，因此不容易丢帧，但是 <code>setTimeout</code> 和 <code>setInterval</code> 容易丢帧。通常这很快，确切的时间取决于浏览器。另外，当页面在后台时，根本没有重绘，所以回调不会运行，此时动画将被暂停并且不会消耗资源，这也比 <code>setTimeout</code> 和 <code>setInterval</code> 更优。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">&#123; easing, draw, duration &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为什么不使用 Date.new()？</span></span><br><span class="line">  <span class="comment">// 因为 performance.now() 会以恒定速度自增，精确到微秒级别，而 Date.now() 容易被篡改</span></span><br><span class="line">  <span class="keyword">const</span> start = performance.now();</span><br><span class="line">  <span class="comment">// 因为动画是连续的，执行完这个动画以后可能还有别的动画</span></span><br><span class="line">  <span class="comment">// 所以我们返回 Promise 以支持后续的顺序调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// timeFraction 是当前已经执行的时间与动画要持续的总时间的比值</span></span><br><span class="line">      <span class="comment">// progress 是一个介于 0 到 1 的值，表示执行绘画的进度</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果 timeFraction 大于或等于 1，说明时间已经超过 duration，执行完成</span></span><br><span class="line">      <span class="comment">// 直接把 progress 的最终值 1 传过去就行了</span></span><br><span class="line">      <span class="comment">// 否则的话，继续执行 requestAnimationFrame</span></span><br><span class="line">      <span class="keyword">let</span> timeFraction = (time - start) / duration;</span><br><span class="line">      <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        timeFraction = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> progress = easing(timeFraction);</span><br><span class="line">      draw(progress);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        requestAnimationFrame(animate);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw 绘制函数</span></span><br><span class="line"><span class="comment">// draw 是一支画笔，它会被反复调用</span></span><br><span class="line"><span class="comment">// 传入的参数是当前执行的进度，是一个介于 0 到 1 之间的值</span></span><br><span class="line"><span class="keyword">const</span> ball = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.ball&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> draw = <span class="function">(<span class="params">progress</span>) =&gt;</span> &#123;</span><br><span class="line">  ball.style.transfrom = <span class="string">`translate(<span class="subst">$&#123;progress&#125;</span>px, 0)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easing 缓动函数</span></span><br><span class="line"><span class="comment">// 修改动画执行的节奏</span></span><br><span class="line"><span class="keyword">const</span> easing = <span class="function">(<span class="params">timeFraction</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> timeFraction ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JS-动画的核心思想"><a href="#JS-动画的核心思想" class="headerlink" title="JS 动画的核心思想"></a>JS 动画的核心思想</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3159700498f41418f87469f348b591e~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>这里 r 是距离，v 是速度，t 是时间。动画就是在开始状态和结束状态之间插值，这里的 r 可以简单理解为插值。</p>
<p>另外我们还需要通过比例尺实现物体的缩放，使得动画可以在显示屏中正常显示。</p>
<h2 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h2><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a><a href="https://codepen.io/jiangxiang/pen/rNmgVKK">动画演示</a></h3><ul>
<li>匀速直线</li>
<li>重力</li>
<li>摩擦力</li>
<li>平抛</li>
<li>旋转 + 平抛</li>
</ul>
<h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>贝塞尔曲线生成网站：<a href="https://cubic-bezier.com/">cubic-bezier.com</a></p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 4 天（上）</title>
    <url>/2022/01/19/byte-fe-training-4-part-one/</url>
    <content><![CDATA[<h1 id="React-的应用场景"><a href="#React-的应用场景" class="headerlink" title="React 的应用场景"></a>React 的应用场景</h1><ul>
<li>网页应用，Facebok，Instagram，Netflix 网页版</li>
<li>移动原生应用：Instagram，Discord，Oculus</li>
<li>桌面应用：结合 Electron</li>
<li>3D：<a href="https://github.com/pmndrs/react-three-fiber">react-three-fiber</a></li>
</ul>
<h1 id="React-的设计思路"><a href="#React-的设计思路" class="headerlink" title="React 的设计思路"></a>React 的设计思路</h1><h2 id="UI-编程的痛点"><a href="#UI-编程的痛点" class="headerlink" title="UI 编程的痛点"></a>UI 编程的痛点</h2><ul>
<li>状态更新，UI 不会自动更新，需要手动调用 dom</li>
<li>缺少代码层面的封装与隔离，没有组件化</li>
<li>UI 之间存在数据依赖关系，需要手动维护；如果数据依赖关系链太长，会出现 callback hell</li>
</ul>
<h2 id="转换式系统-amp-响应式系统"><a href="#转换式系统-amp-响应式系统" class="headerlink" title="转换式系统 &amp; 响应式系统"></a>转换式系统 &amp; 响应式系统</h2><p>转换式系统：给定输入，求解输出，如编译器，计算器<br>响应式系统：监听事件，由消息驱动</p>
<p>前端代码并不需要大量的计算，更多的是需要去处理一些事件（比如用户的点击）；另外当事件发生时，我们需要进行一些响应（比如改变界面）。这两个特点决定了转换式系统对于前端写起来是很难受的，我们需要一种新的方式。</p>
<p>依据上面的分析，我们对于 React 设计的期望也很容易得出：</p>
<ul>
<li>状态更新，UI 自动更新</li>
<li>前端代码组件化，可以复用，可以封装</li>
<li>状态之间</li>
</ul>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul>
<li>组件是组件的组合 / 原子组件</li>
<li>组件内拥有状态，且外部不可见</li>
<li>父组件可以把状态传递给子组件</li>
</ul>
<h2 id="状态归属"><a href="#状态归属" class="headerlink" title="状态归属"></a>状态归属</h2><p>状态提升：当多个组件需要共享一个状态的时候，我们需要不断地提升状态，所以我们需要状态管理库。</p>
<p>注意 React 不是双向数据流，是单向的。<strong>子组件只是执行了父组件传递过来的函数，而没有把任何的状态传递回去给父组件。</strong>（函数在 Js 中是一等公民，所以可以作为一个变量传递）</p>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><ul>
<li>组件声明了状态以及 UI 的映射</li>
<li>组件有 state（内部状态）和 props（外部状态）两种状态</li>
<li>组件可以由其它组件拼装而成</li>
</ul>
<h1 id="状态管理库"><a href="#状态管理库" class="headerlink" title="状态管理库"></a>状态管理库</h1><p>使用状态管理库的弊端：组件的复用性降低了，一般使用于业务代码</p>
<p>常用的状态管理库有：</p>
<ul>
<li>redux</li>
<li>mobx</li>
<li>xstate</li>
<li>recoil</li>
<li>reduck（来源于 modern.js）</li>
</ul>
<p><strong>什么东西应该放到状态管理库？</strong><br>如果你觉得某个东西整个 APP 有多处可能用到的，就放进去，比如说用户头像，这样也可以减少我们发送的请求数。</p>
<h1 id="React-组件什么时候被渲染？"><a href="#React-组件什么时候被渲染？" class="headerlink" title="React 组件什么时候被渲染？"></a>React 组件什么时候被渲染？</h1><ul>
<li>首次渲染</li>
<li>props 变化</li>
<li>state 变化</li>
<li>context 变化</li>
</ul>
<h1 id="应用级框架科普"><a href="#应用级框架科普" class="headerlink" title="应用级框架科普"></a>应用级框架科普</h1><ul>
<li>Next.js</li>
<li>Modern.js</li>
<li>Blitz</li>
</ul>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 React 要发明 Hooks</title>
    <url>/2022/01/18/why-we-need-hooks/</url>
    <content><![CDATA[<p>本文为<a href="https://time.geekbang.org/column/article/378311">React Hooks 核心原理与实战</a>阅读笔记</p>
<h1 id="React-组件的本质"><a href="#React-组件的本质" class="headerlink" title="React 组件的本质"></a>React 组件的本质</h1><p>我们可以把 UI 的展现看成一个<strong>函数</strong>的执行过程。其中，Model 是输入参数，函数的执行结果是 DOM 树，也就是 View。而 React 要保证的，就是每当 Model 发生变化时，函数会重新执行，并且生成新的 DOM 树，然后 React 再把新的 DOM 树以最优的方式更新到浏览器。</p>
<p><strong>所以我们是否真的有必要使用 class 来作为组件呢？</strong><br>事实上使用 class 是一种很牵强的做法，React 根本没有用到类的两个重要特性：</p>
<ul>
<li>React 组件之间是不会互相继承的。比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 来继承 Button。所以说，React 中其实是没有利用到 Class 的继承特性的。</li>
<li>所有 UI 都是由状态驱动的，因此很少会在外部去调用一个类实例（即组件）的方法。要知道，组件的所有方法都是在内部调用，或者作为生命周期方法被自动调用的。在使用类组件的时候，你从不需要去 new 一个对象来实现任何功能。</li>
</ul>
<p><strong>换句话说，class 并不是最好的组件表现形式，function 才是。</strong></p>
<h1 id="Hooks-的诞生"><a href="#Hooks-的诞生" class="headerlink" title="Hooks 的诞生"></a>Hooks 的诞生</h1><p>但是当时有一个局限是，函数组件无法存在内部状态，必须是纯函数，而且也无法提供完整的生命周期机制。</p>
<p>因此我们需要一个机制，能够把一个外部的数据绑定到函数的执行。<strong>当数据变化时，函数能够自动重新执行</strong>。</p>
<p><strong>于是有了 Hooks。</strong></p>
<p>在 React 中，Hooks 就是把某个目标结果<strong>钩到某个可能会变化的数据源或者事件源上</strong>，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p>
<p>对于函数组件，这个结果是最终的 DOM 树；对于 useCallback、useMemo 这样与缓存相关的组件，则是在依赖项发生变化时去更新缓存。</p>
<p>另外，有一点需要特别注意，Hooks 中被钩的对象，不仅可以是某个独立的数据源，也可以是另一个 Hook 执行的结果，这就带来了 Hooks 的最大好处：<strong>实现逻辑的复用</strong>。</p>
<h1 id="Hooks-实现逻辑复用"><a href="#Hooks-实现逻辑复用" class="headerlink" title="Hooks 实现逻辑复用"></a>Hooks 实现逻辑复用</h1><p>在之前的 React 使用中，有一点经常被大家诟病，就是非常难以实现逻辑的复用，必须借助于高阶组件等非常复杂的设计模式。但是高阶组件会产生冗余的组件节点，让调试变得困难。不过这些问题可以通过 Hooks 得到了很好的解决。所以如果有人问你 Hooks 有什么好处，那么最关键的答案就是<strong>简化了逻辑复用</strong>。</p>
<p>在 Hooks 出现之前，高阶组件几乎是 Class 组件中实现代码逻辑复用的唯一方式，其缺点其实比较显然：</p>
<ul>
<li>代码难理解，不直观，很多人甚至宁愿重复代码，也不愿用高阶组件。</li>
<li>会增加很多额外的组件节点。每一个高阶组件都会多一层节点，这就会给调试带来很大的负担。</li>
</ul>
<p>但现在我们可以通过 Hooks 的方式对外部数据进行封装，从而将其变成一个可绑定的数据源。</p>
<h1 id="Hooks-帮助实现关注点的分离"><a href="#Hooks-帮助实现关注点的分离" class="headerlink" title="Hooks 帮助实现关注点的分离"></a>Hooks 帮助实现关注点的分离</h1><p>除了逻辑复用之外，Hooks 能够带来的另外一大好处就是有助于关注分离，意思是说 Hooks 能够让针对同一个业务逻辑的代码尽可能聚合在一块儿。这是过去在 Class 组件中很难做到的。因为在 Class 组件中，你不得不把同一个业务逻辑的代码分散在类组件的不同生命周期的方法中。</p>
<p>在过去的 Class 组件中，我们需要在 <code>componentDidMount</code> 中监听事件，在 <code>componentWillUnmount</code> 中解绑事件。而在函数组件中，我们可以把所有逻辑写在一起。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域解决方案</title>
    <url>/2022/01/17/cross-origin/</url>
    <content><![CDATA[<h1 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h1><p>浏览器同源策略是一个安全策略，其中同源指的是 <code>协议 + 域名 + 端口号</code> 三者相同，即使有两个不同的域名指向同一个 IP 地址，也不是同源的。同源策略可以一定程度上防止 XSS、CSRF 攻击。</p>
<p>一个域名的组成包括：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117211107.png"></p>
<p>在默认情况下 http 可以省略端口 80， https 可以省略端口 443。也就是说，<a href="https://www.baidu.com/">https://www.baidu.com</a> 和 <a href="https://www.baidu.com/">https://www.baidu.com:443</a> 显然也是同源的，因为它们是一回事。</p>
<p>不符合同源策略导致的后果有：</p>
<ul>
<li>localStorage、sessionStorage、Cookie 等浏览器的内存无法跨域访问</li>
<li>DOM 节点无法进行跨域操作</li>
<li>Ajax 请求无法跨域请求</li>
</ul>
<p>但是有一些标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img&gt;</code></li>
<li><code>&lt;link&gt;</code></li>
<li><code>&lt;script&gt;</code></li>
</ul>
<p>值得注意的几个要点有：</p>
<ul>
<li>如果是协议和端口造成的跨域问题，前端是无能为力的</li>
<li><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong></li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(<span class="string">&#x27;hello world&#x27;</span>));</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第一步：创建 xhr 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第三步：发送请求</span></span></span><br><span class="line"><span class="javascript">    xhr.send();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第四步：绑定事件</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// readState</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 0 表示未初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1 表示 open 完毕</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2 表示 send 完毕 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3 表示服务端返回了部分结果 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4 表示服务端返回了所有结果</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第五步：处理结果</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>果不其然报错了：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117213331.png"></p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>JSONP，即 JSON with Padding，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。<br>JSONP 工作原理：在网页有一些标签天生就具有跨域能力，比如 <code>img</code> <code>link</code> <code>script</code> 等。JSONP 就是利用 <code>script</code> 标签的跨域能力来发送请求的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117230214.png"><br>举个例子，客户端传入 a 和 b，服务端传回 a + b 的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; a, b, callback &#125; = query;</span><br><span class="line">    <span class="keyword">const</span> ans = <span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;<span class="subst">$&#123;ans&#125;</span>&#x27;)`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">ans</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;a + b =&#x27;</span>, ans);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> jsonp = <span class="function">(<span class="params">a, b, callback</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        script.src = <span class="string">`http://127.0.0.1:8000?a=<span class="subst">$&#123;a&#125;</span>&amp;b=<span class="subst">$&#123;b&#125;</span>&amp;callback=<span class="subst">$&#123;callback&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    jsonp(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;add&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>缺点：需要前后端配合，只支持 get 请求。</p>
<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>CORS 全称是 Cross-Orgin Resource Sharing，跨域资源共享。CORS 由后端开启，开启后前端就可以跨域访问后端。</p>
<p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。该属性表示哪些域名可以访问资源，如果设置为通配符 *，则表示所有网站都可以访问资源。类似的还有 <code>Access-Control-Allow-Methods</code>，表示允许的请求方法，<code>Access-Control-Allow-Headers</code>，表示允许的请求头类型。</p>
<p>设置 CORS 本身和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>只要同时满足以下条件的就是简单请求：</p>
<ol>
<li>请求方法是以下三者之一：</li>
</ol>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
<ol start="2">
<li>允许人为设置的字段仅限以下几种：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type（有额外限制）</li>
</ul>
<ol start="3">
<li>Content-Type 取值为以下三者之一：</li>
</ol>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<ol start="4">
<li><p>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
</li>
<li><p>请求中没有使用 ReadableStream 对象。</p>
</li>
</ol>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>不是简单请求的请求就是复杂请求。<strong>复杂请求</strong>必须首先使用 <code>OPTIONS</code> 请求方法发起一个<strong>预检请求</strong>到服务器，以获知服务器是否允许该实际请求。预检请求的使用，可以避免跨域请求对服务器的用户数据产生预期之外的影响。</p>
<p>代码示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第一步：创建 xhr 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000?a=1&amp;b=2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第三步：发送请求</span></span></span><br><span class="line"><span class="javascript">    xhr.send();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第四步：绑定事件</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// readState</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 0 表示未初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1 表示 open 完毕</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2 表示 send 完毕 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3 表示服务端返回了部分结果 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4 表示服务端返回了所有结果</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第五步：处理结果</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">query</span>: &#123; a, b &#125; &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>Websocket 属于应用层协议，它基于 TCP 传输协议，并复用 http 的握手通道。<br>相比于 http 协议，它的优点是：</p>
<ul>
<li>支持双向通信，客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据</li>
<li>有更好的二进制支持</li>
<li>支持拓展</li>
</ul>
<p>因为这种方式本质没有使用 http 的响应头, 因此也没有跨域的限制。</p>
<p><strong>那么为什么 WebSocket 可以跨域呢？</strong><br>因为 WebSocket 根本不属于同源策略，而且它本身就有意被设计成可以跨域的一个手段。由于历史原因，跨域检测一直是由浏览器端来做，但是 WebSocket 出现以后，对于 WebSocket 的跨域检测工作就交给了服务端，浏览器仍然会带上一个 Origin 跨域请求头，服务端则根据这个请求头判断此次跨域 WebSocket 请求是否合法。</p>
<p>依然以 a + b 问题举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">ws</span>(<span class="params">a, b</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://127.0.0.1:8000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            socket.send(<span class="built_in">JSON</span>.stringify(&#123; a, b &#125;));</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    ws(<span class="number">1</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket.Server(&#123; port &#125;);</span><br><span class="line">ws.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    obj.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data.toString());</span><br><span class="line">        <span class="keyword">const</span> &#123; a, b &#125; = data;</span><br><span class="line">        obj.send(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Node-接口代理"><a href="#Node-接口代理" class="headerlink" title="Node 接口代理"></a>Node 接口代理</h1><p>同源策略只在浏览器存在，无法限制后端。也就是说前端与后端之间会受同源策略影响，但是后端与后端之间不会受到限制。所以可以通过 Node 做一层接口代理，先访问已经设置了 CORS 的后端 1，再让后端 1 去访问后端 2，获取数据后传给后端 1，最后再让后端 1 把数据传回给前端。</p>
<p>客户端代码同上，把请求端口改成 8888 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端 1 http://127.0.0.1:8888</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; methods = <span class="string">&#x27;GET&#x27;</span>, headers &#125; = req;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给后端 2 发送请求</span></span><br><span class="line">    http.request(&#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="string">&#x27;8000&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">`/?<span class="subst">$&#123;querystring.stringify(query)&#125;</span>`</span>,</span><br><span class="line">        methods,</span><br><span class="line">        headers</span><br><span class="line">    &#125;, <span class="function"><span class="params">proxyRes</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把从后端 2 获取的数据传回给前端</span></span><br><span class="line">        proxyRes.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">            res.end(chunk.toString());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).end()</span><br><span class="line">&#125;).listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端 2 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">query</span>: &#123; a, b &#125; &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p>实现原理类似于上面提到的 Node 接口代理，需要你搭建一个中转 Nginx 服务器，用于转发请求。使用 Nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 Nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器的性能。</p>
<p>先根据<a href="https://blog.csdn.net/diaojw090/article/details/89135073">Nginx安装教程</a>进行 Nginx 的安装。<br>然后修改 conf 目录下的 nginx.conf 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 8888;</span><br><span class="line">    server_name  127.0.0.1;</span><br><span class="line"> </span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>此时客户端请求 8888 端口，就不会跨域了。</p>
<p>参考资料：<br><a href="https://juejin.cn/post/7017614708832206878">https://juejin.cn/post/7017614708832206878</a><br><a href="https://juejin.cn/post/6844904126246027278">https://juejin.cn/post/6844904126246027278</a><br><a href="https://juejin.cn/post/6844903767226351623">https://juejin.cn/post/6844903767226351623</a><br><a href="https://www.jianshu.com/p/9a8d793ec52a">https://www.jianshu.com/p/9a8d793ec52a</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a><br>公众号前端点线面</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>js 版算法 101 笔记</title>
    <url>/2022/01/17/js-algorithm-101-notes/</url>
    <content><![CDATA[<p>本文题目列表来源于<a href="https://101.zoo.team/">政采云前端团队</a>，题源来源于<a href="https://leetcode-cn.com/">力扣</a>。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></h2><ul>
<li>方法一：使用 <code>reverse</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(x.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  num = x &lt; <span class="number">0</span> ? -num : num;</span><br><span class="line">  <span class="keyword">return</span> num &lt; -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) || num &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> ? <span class="number">0</span> : num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：借鉴欧几里得算法，可以把空间复杂度降到 O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="built_in">Math</span>.abs(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (temp !== <span class="number">0</span>) &#123;</span><br><span class="line">    num = num * <span class="number">10</span> + (temp % <span class="number">10</span>);</span><br><span class="line">    temp = <span class="built_in">Math</span>.floor(temp / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  num = x &lt; <span class="number">0</span> ? -num : num;</span><br><span class="line">  <span class="keyword">return</span> num &lt; -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) || num &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> ? <span class="number">0</span> : num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></h2><p>这题就是上面那题的变式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x === reverse(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转数字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">      num = num * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">      x = <span class="built_in">Math</span>.floor(x / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">有效的字母异位词</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length !== t.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    map.set(ch, (map.get(ch) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(ch) &amp;&amp; map.get(ch) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      map.set(ch, map.get(ch) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串转换整数"><a href="#字符串转换整数" class="headerlink" title="字符串转换整数"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数</a></h2><ul>
<li>方法一：正则</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> maxVal = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>,</span><br><span class="line">    minVal = -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 书写正则</span></span><br><span class="line">  <span class="comment">// (-|\+)? 表示 - 或 + 或什么都没有</span></span><br><span class="line">  <span class="comment">// \d+ 为匹配数字</span></span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^(-|\+)?\d+/g</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> groups = s.trim().match(reg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若匹配到了，取其第一项</span></span><br><span class="line">  <span class="keyword">if</span> (groups) &#123;</span><br><span class="line">    res = +groups[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res &gt; maxVal) res = maxVal;</span><br><span class="line">  <span class="keyword">if</span> (res &lt; minVal) res = minVal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：使用 <code>parseInt</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> maxVal = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>,</span><br><span class="line">    minVal = -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">parseInt</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(res)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res &gt; maxVal) res = maxVal;</span><br><span class="line">  <span class="keyword">if</span> (res &lt; minVal) res = minVal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="报数"><a href="#报数" class="headerlink" title="报数"></a><a href="https://leetcode-cn.com/problems/count-and-say/">报数</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sb = [];</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos &lt; str.length) &#123;</span><br><span class="line">      <span class="keyword">while</span> (pos &lt; str.length &amp;&amp; str[pos] === str[start]) &#123;</span><br><span class="line">        pos++;</span><br><span class="line">      &#125;</span><br><span class="line">      sb.push(<span class="string">&quot;&quot;</span> + (pos - start) + str[start]);</span><br><span class="line">      start = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str = sb.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    [s[i], s[s.length - <span class="number">1</span> - i]] = [s[s.length - <span class="number">1</span> - i], s[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">字符串中的第一个唯一字符</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    map.set(ch, (map.get(ch) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(s[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> real = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (s[i] &gt;= <span class="string">&quot;a&quot;</span> &amp;&amp; s[i] &lt;= <span class="string">&quot;z&quot;</span>) ||</span><br><span class="line">      (s[i] &gt;= <span class="string">&quot;A&quot;</span> &amp;&amp; s[i] &lt;= <span class="string">&quot;Z&quot;</span>) ||</span><br><span class="line">      (s[i] &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; s[i] &lt;= <span class="string">&quot;9&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">      real.push(s[i].toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> realString = real.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; realString.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (realString[i] !== realString[realString.length - i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></h2><ul>
<li>暴力</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">haystack</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">needle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span> (<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (needle === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; needle.length &amp;&amp; j + i &lt; haystack.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haystack[i + j] === needle[j]) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j === needle.length - <span class="number">1</span> &amp;&amp; count === needle.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>剪枝 + 遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">haystack</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">needle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span> (<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 剪枝</span></span><br><span class="line">  <span class="keyword">if</span> (needle === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle.length &gt; haystack.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle.length === haystack.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> needle === haystack ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= haystack.length - needle.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack[i] !== needle[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haystack.substring(i, i + needle.length) === needle) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 假设第一个元素是最长前缀</span></span><br><span class="line">  <span class="keyword">let</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!strs[i].startsWith(prefix)) &#123;</span><br><span class="line">      prefix = prefix.substring(<span class="number">0</span>, prefix.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否存在公共前缀</span></span><br><span class="line">    <span class="keyword">if</span> (prefix === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h2><ul>
<li>dp</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 长度为 1，一定回文</span></span><br><span class="line">  <span class="comment">// 长度为 2 或 3，判断首尾是否相同：s[i] === s[j]</span></span><br><span class="line">  <span class="comment">// 长度大于 3, 首尾字符相同，且去掉首尾之后的子串仍为回文：(s[i] === s[j]) &amp;&amp; dp[i + 1][j - 1]</span></span><br><span class="line">  <span class="keyword">const</span> len = s.length;</span><br><span class="line">  <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界，长度为 1 必定为回文</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录起点和长度，即可得到字符串</span></span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">1</span>,</span><br><span class="line">    begin = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 第一层枚举为子串长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">    <span class="comment">// 第二层枚举为左边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// j - i + 1 = l</span></span><br><span class="line">      <span class="keyword">const</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">        <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[i] !== s[j]) &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">          dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只要 dp[i][j] 为 true，就表示子串 s[i..j] 是回文</span></span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; l &gt; maxLen) &#123;</span><br><span class="line">        maxLen = l;</span><br><span class="line">        begin = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>暴力，需要注意的是这题暴力的解比 dp 更优</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 返回以 i 为中心的回文串</span></span><br><span class="line">    <span class="keyword">const</span> a = palindrome(i, i);</span><br><span class="line">    <span class="comment">// 返回以 i 和 i + 1 为中心的回文串</span></span><br><span class="line">    <span class="keyword">const</span> b = palindrome(i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; res.length) &#123;</span><br><span class="line">      res = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.length &gt; res.length) &#123;</span><br><span class="line">      res = b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置左右两个指针，是为了可以同时处理回文串长度为奇数和偶数的情况</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">      left--;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以 s[left] 和 s[right] 为中心的最长回文串</span></span><br><span class="line">    <span class="comment">// 此时 left 和 right 已经不符合要求了，所以返回的区间是 [left + 1, right - 1]</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></h2><p>先遍历所有罗马数字进行累加，对于特殊数字的循环，比如：5 + 1 = 6，而实际是 4，相差 2，所以需要在结果上减去 2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;I&quot;</span>:</span><br><span class="line">        res += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;V&quot;</span>:</span><br><span class="line">        res += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;X&quot;</span>:</span><br><span class="line">        res += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;L&quot;</span>:</span><br><span class="line">        res += <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">        res += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">        res += <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;M&quot;</span>:</span><br><span class="line">        res += <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.includes(<span class="string">&quot;IV&quot;</span>) || s.includes(<span class="string">&quot;IX&quot;</span>)) res -= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.includes(<span class="string">&quot;XL&quot;</span>) || s.includes(<span class="string">&quot;XC&quot;</span>)) res -= <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.includes(<span class="string">&quot;CD&quot;</span>) || s.includes(<span class="string">&quot;CM&quot;</span>)) res -= <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a><a href="https://leetcode-cn.com/problems/fizz-buzz/">Fizz Buzz</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fizzBuzz = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      str += <span class="string">&quot;Fizz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      str += <span class="string">&quot;Buzz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> !== <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      str += i;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a><a href="https://leetcode-cn.com/problems/count-primes/">计数质数</a></h2><ul>
<li>枚举，超出时间限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>埃拉筛<br>这个算法的推导由来可以看<a href="https://labuladong.gitee.io/algo/4/30/118/">labuladong</a>。这个算法的复杂度是 <code>O(N * loglogN)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isPrime = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">      <span class="comment">// i 的倍数不可能是素数，每次 j += i</span></span><br><span class="line">      <span class="comment">// 从 i * i 开始，因为前面的数字已经算过了</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">        isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-的幂"><a href="#3-的幂" class="headerlink" title="3 的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/">3 的幂</a></h2><p>循环和递归都很简单，不说了，还有一种骚操作。<br>在题目给定的 32 位有符号整数的范围内，最大的 3 的幂为 3 ^ 19 = 1162261467。我们只需要判断 n 是否是这个数的约数即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfThree = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Excel-表列名称"><a href="#Excel-表列名称" class="headerlink" title="Excel 表列名称"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">Excel 表列名称</a></h2><p>和正常 0 ~ 25 的 26 进制相比，本质上就是每一位多加了 1，所以只要在处理每一位的时候先减 1，就可以按照正常的 26 进制来处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">columnNumber</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span> (<span class="params">columnNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (columnNumber) &#123;</span><br><span class="line">    columnNumber--;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="built_in">String</span>.fromCharCode((columnNumber % <span class="number">26</span>) + <span class="number">65</span>); <span class="comment">// 65 是 A 对应的 Char Code</span></span><br><span class="line">    res.push(temp);</span><br><span class="line">    columnNumber = <span class="built_in">Math</span>.floor(columnNumber / <span class="number">26</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res.reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Excel-表列序号"><a href="#Excel-表列序号" class="headerlink" title="Excel 表列序号"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">Excel 表列序号</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">columnTitle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> titleToNumber = <span class="function"><span class="keyword">function</span> (<span class="params">columnTitle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> i = columnTitle.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">1</span>; <span class="comment">// 进制</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为 A 表示 1，所以减法后需要每个数加 1，相当于减去 65，再加上 1</span></span><br><span class="line">    <span class="keyword">const</span> cur = columnTitle[i].charCodeAt(<span class="number">0</span>) - <span class="number">64</span>;</span><br><span class="line">    sum += cur * carry;</span><br><span class="line">    carry *= <span class="number">26</span>;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">快乐数</a></h2><p>首先我们需要清楚，快乐数的计算是可能会导致死循环出现的。遇到判断某个可能的死循环是否满足一定的条件，我们可以使用快慢指针，比如链表的经典题目<strong>判断链表是否有环</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slow = n,</span><br><span class="line">    fast = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// slow 执行一遍， fast 连续执行两遍</span></span><br><span class="line">    slow = calculateSum(slow);</span><br><span class="line">    fast = calculateSum(fast);</span><br><span class="line">    fast = calculateSum(fast);</span><br><span class="line">  &#125; <span class="keyword">while</span> (slow !== fast);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> slow === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">calculateSum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">      <span class="keyword">const</span> bit = num % <span class="number">10</span>;</span><br><span class="line">      sum += bit * bit;</span><br><span class="line">      num = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">阶乘后的零</a></h2><ul>
<li>暴力</li>
</ul>
<ol>
<li>尾数中有 0 必定是是 10 的倍数</li>
<li>尾数中有多少个 0 就就是整个数能有多少个因子 10</li>
<li>因子 10 又可以拆成 ，因此就是找整个数字可以拆分成多少了<br>因为在因子中 2 的数量一定比 5 多，所以实际上我们只要找到因子 5 的个数就可以找到尾数中 0 的个数了，所以这个问题就可以转换成找因子 5 的个数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trailingZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = i;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="number">0</span> &amp;&amp; x % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">      x = <span class="built_in">Math</span>.floor(x / <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>优化版本</li>
</ul>
<ol>
<li>n! 这些乘数中，每隔 5 个数，肯定会有一个数至少能拆出一个 5 因子。所以 n / 5 = 至少会出现的 5 的个数</li>
<li>因为 n / 5 并不能完全算出 5 因子的个数，比如若某个数 25 = 5 * 5，分解后得到的 5 也算一个，所以能被 25 因式分解相当于会出现 2 个 5 因子</li>
<li>依此类推，能被 25 _ 5 = 125 因式分解的相当于比之前按 25 因式分解的时候又多出一个 5 因子。能被 125 _ 5 = 625 因式分解的相当于比按 125 因式分解时又多出一个 5 因子。还有 625 * 5 …<br>所以 n! 的结果可以拆分为多少个 5 因子呢？<br>显然就是 n/5 + n/25 + n/125 + n/625 + …</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trailingZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">5</span>);</span><br><span class="line">    ans += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h2><ul>
<li><p>二分<br>使用折半计算，每次把 n 缩小一半，通过递归，最终获取 x 的 n 次幂。比如说要计算 x<sup>32</sup>，推算过程为：<br>x<sup>32</sup> -&gt; x<sup>16</sup> -&gt; x<sup>8</sup> -&gt; x<sup>4</sup> -&gt; x<sup>2</sup> -&gt; x<br>但是具体的操作还要根据数字的奇偶决定，如要计算 x<sup>77</sup>，推算过程为：<br>x<sup>77</sup> -&gt; x<sup>38</sup> -&gt; x<sup>19</sup> -&gt; x<sup>9</sup> -&gt; x<sup>4</sup> -&gt; x<sup>2</sup> -&gt; x<br>当我们要计算 x<sup>n</sup> 时，我们可以先递归地计算出 y = x<sup>n/2</sup>，接着：</p>
<ul>
<li>如果 n 为偶数，那么 x<sup>n</sup> = y<sup>2</sup></li>
<li>如果 n 为奇数，那么 x<sup>n</sup> = y<sup>2</sup> * x</li>
</ul>
<p>边界：n = 0，返回 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &gt;= <span class="number">0</span> ? quickPower(x, n) : <span class="number">1</span> / quickPower(x, -n);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">quickPow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> y = quickPow(x, <span class="built_in">Math</span>.floor(n / <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> === <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>快速幂<br>若 n = a1 + a2 + a3 + … + am，则<br>x<sup>n</sup> = x<sup>a1</sup> * x<sup>a2</sup> * x<sup>a3</sup> * … * x<sup>am</sup><br>依然以 x<sup>77</sup>，为例，x -&gt; x<sup>2</sup> -&gt; x<sup>4</sup> -&gt; x<sup>9</sup> -&gt; x<sup>19</sup> -&gt; x<sup>38</sup> -&gt; x<sup>77</sup></p>
<ul>
<li>x<sup>38</sup> -&gt; x<sup>77</sup> 额外乘的 x 在 x<sup>77</sup> 中贡献了 x</li>
<li>x<sup>9</sup> -&gt; x<sup>19</sup> 额外乘的 x 在 后面被平方了 2 次，所以贡献是 x<sup>2 ^ 2</sup></li>
<li>x<sup>4</sup> -&gt; x<sup>9</sup> 额外乘的 x 在 后面被平方了 3 次，所以贡献是 x<sup>2 ^ 3</sup></li>
<li>最初的 x 在之后被平方了 6 次，因此最后贡献的是 x<sup>2 ^ 6</sup></li>
<li>上面的贡献相乘， x * x<sup>4</sup> * x<sup>8</sup> * x<sup>64</sup> = x<sup>77</sup>，这些指数 1、4、8、64，对应了 77 的二进制表示 (1001101)<sub>2</sub> 中的每一个 1</li>
</ul>
<p>因此，我们从 x 开始不断平方，得到 x<sup>2</sup>、x<sup>4</sup>、x<sup>8</sup>、x<sup>16</sup>，… ，如果 n 的第 k 位（从右往左数）二进制为 1，那么我们就将对应的贡献 x<sup>2 ^ k</sup> 计入答案。</p>
<p>说实话不是很懂为什么快速幂居然会超时，这测试用例有点那啥（</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断边界，否则会超时</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> || n &lt;= <span class="number">1</span> &lt;&lt; <span class="number">31</span> &amp;&amp; <span class="built_in">Math</span>.abs(x) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span> &lt;&lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n &gt;= <span class="number">0</span> ? quickPow(x, n) : <span class="number">1</span> / quickPow(x, -n);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">quickPow</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算贡献</span></span><br><span class="line">        result = result * a;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 扩大它的贡献</span></span><br><span class="line">      a = a * a;</span><br><span class="line">      <span class="comment">// 去除最后一位</span></span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>javascript</tag>
        <tag>leetcode</tag>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 3 天</title>
    <url>/2022/01/17/byte-fe-training-3/</url>
    <content><![CDATA[<p>今天大多数的内容都属于是实用性的，没什么笔记记录。</p>
<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><ul>
<li>IE：Trident</li>
<li>Firefox：Gecko</li>
<li>Chrome：Webkit / Blink</li>
<li>Safari：Webkit</li>
<li>Opera：Presto</li>
</ul>
<h1 id="Web-标准组织"><a href="#Web-标准组织" class="headerlink" title="Web 标准组织"></a>Web 标准组织</h1><ul>
<li>W3C: HTML、XML、CSS、DOM、Web API 等</li>
<li>ECMA: ECMAScript</li>
<li>WHATWG: 与 W3C 合作制定 HTML 和 DOM</li>
<li>ITEF: TCP/IP、FTP 等网络协议</li>
</ul>
<h1 id="console"><a href="#console" class="headerlink" title="console"></a>console</h1><ul>
<li><code>console.warn</code></li>
<li><code>console.error</code></li>
<li><code>console.table</code>：格式化打印数组 / JSON 数据</li>
<li><code>console.dir</code>：按照树形结构打印 DOM 节点</li>
</ul>
<h1 id="SourceMap-原理"><a href="#SourceMap-原理" class="headerlink" title="SourceMap 原理"></a>SourceMap 原理</h1><p>关于 SourceMap 的原理，推荐<a href="https://juejin.cn/post/6963076475020902436">这篇文章</a></p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>关于跨域，推荐<a href="https://juejin.cn/post/7017614708832206878">这篇文章</a></p>
<h1 id="Bug-终极解决方案"><a href="#Bug-终极解决方案" class="headerlink" title="Bug 终极解决方案"></a>Bug 终极解决方案</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117203510.png"></p>
<p><em>传说中程序大师随身携带只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 ——《程序员修炼之道》</em></p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 2 天</title>
    <url>/2022/01/16/byte-fe-training-2/</url>
    <content><![CDATA[<p>经过了昨天还算是友好的前菜，今天突然猛地来了一顿硬菜，让人有点措手不及（或者应该说是消化不良？）。不过想想这不就是我们来青训营的目的吗？见识以前可能只是听说过甚至完全没有听说过的知识，学习更先进的编程思维。总之，今天完全被月影老师圈粉了，甚至萌生了去极客买买买的想法（x</p>
<p>开篇，谨以此图表达我对 JavaScript 的热爱<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220116140922.png"></p>
<h1 id="如何写好-JavaScript"><a href="#如何写好-JavaScript" class="headerlink" title="如何写好 JavaScript"></a>如何写好 JavaScript</h1><h2 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h2><p>举个例子，写一段 js，控制一个网页支持浅色和深色两种浏览模式，如何实现？<br>很容易想到的一种实现方法是，加一个切换按钮，然后给该按钮添加事件，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    <span class="keyword">if</span> (e.target.innerHTML === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">        body.style.backgroundColor = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        body.style.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        body.style.backgroundColor = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        body.style.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;light&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码的问题所在：直接使用 js 操作了样式，没有做到<strong>各司其职</strong>。</p>
<p>修改版本一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    <span class="keyword">if</span> (body.className !== <span class="string">&#x27;night&#x27;</span>) &#123;</span><br><span class="line">        body.className = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        body.className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过添加或删除类名，实现状态切换，做到<strong>各司其职</strong>，使得代码结构得到优化。</p>
<p>修改版本二：完全使用 CSS 实现<br>这个主要是利用 CSS 的 checkbox 的 <code>checked</code> 伪类实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐一个利用了这个原理实现明暗主题变换的 React 项目：<a href="https://github.com/ShaifArfan/artistic">戳这</a></p>
<h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>组件设计的原则：</p>
<ul>
<li>封装性</li>
<li>正确性</li>
<li>拓展性</li>
<li>复用性</li>
</ul>
<p>如何使用原生 JavaScript 实现一个电商网站的轮播图？</p>
<p><em>组件设计比较复杂的点往往在于控制的地方和组件本身有一定的耦合。 ——月影</em></p>
<p>比如说当前轮播图的第几个小圆点标红，就是显示第几张图片，它们之间的状态是耦合的。我们不希望它们之间关系绑的太死，所以我们一般会使用自定义事件。</p>
<p>详细的实现见<a href="https://forum.juejin.cn/youthcamp/post/7052254063840198686">青训营社区</a></p>
<p><strong>划重点</strong>，原文中最后说到：<br>这个轮播组件实现了封装性和正确性，但是缺少了可扩展性。这个组件只能满足自身的使用，它的实现代码很难扩展到其他的组件，当有功能变化时，也需要修改其自身内部的代码。<br>比如产品经理因为某种原因，希望将图片下方的小圆点暂时去掉，只保留左右箭头。那么在这个版本中，就需要这么做：</p>
<ul>
<li>注释掉 html 中 <code>.slider__control</code> 相关的代码</li>
<li>修改 Slider 组件，注释掉与小圆点控制相关的代码</li>
<li>又或者，将来需要为这个组件添加新的用户控制，都需要对这个组件进行再修改</li>
</ul>
<p>这样的修改常常涉及了<strong>核心代码</strong>的更改。那么，如何可以避免这样的修改，让组件具备可扩展性和复用性呢？</p>
<p><em>在 JavaScript 代码中，一个方法一般来说最多只能有 15 行代码，超过了就需要重构。 ——月影</em></p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><h4 id="如何解耦"><a href="#如何解耦" class="headerlink" title="如何解耦"></a>如何解耦</h4><ul>
<li>将控制元素（如小圆点）抽取成插件</li>
<li>插件与组件之间通过<strong>依赖注入</strong>的方式建立联系</li>
</ul>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>然后月影老师给了一个无敌的使用依赖注入实现的轮播图。核心要点是通过一个 <code>registerPlugins</code> 方法来完成插件的注册，然后分别实现三个插件（Controller、Next、Previous）。通过这样的重构，如果哪天 PM 要我们把小圆点删除掉，我们直接把小圆点对应的代码删掉就行了，不需要修改组件的核心代码。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>为什么需要依赖注入？<br><strong>插件的初始化依赖于组件。我们不希望组件知道插件的存在，但是插件需要知道组件的存在。</strong></p>
<h4 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h4><p>现在插件独立了，如果要删除小圆点，我们现在可以直接把对应插件的 JavaScript 代码删除掉，但是问题是我们还需要删掉 html 的对应代码，这样也是需要修改多个地方。因为我们还需要把 html 模板化。方法就是在 js 代码中实现一个 <code>render</code> 方法，来进行模板化的渲染。渲染方法里面可以加入一些参数，比如说有多少张图片，然后组件需要根据传入的参数进行渲染。另外插件也需要实现自己的 <code>render</code> 方法，来实现插件的 html 模板化；还有一个 <code>action</code> 函数，作用是根据组件依赖注入的实例来初始化插件数据。</p>
<h4 id="抽象化"><a href="#抽象化" class="headerlink" title="抽象化"></a>抽象化</h4><p>进一步修改实现的思想为：<br>实现一个 <code>Component</code> 类，里面有一个 <code>render</code> 方法。<code>render</code> 方法是一个抽象的方法，然后轮播图组件和各插件继承于它，再实现各自的 <code>render</code> 函数。也就是说，所有的元素都是组件（没有插件），小圆点也是组件、图片展示也是组件，最后整个的轮播图组件则是由多个小的组件组合而成。</p>
<h2 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220116201358.png"><br>什么是过程抽象呢？举个例子，比如你有间小房子，房子有门、有窗，这里门和窗也就是数据。那么你可以开门，也可以开窗，开门和开窗就属于过程。我们不仅仅可以抽象数据，还可以抽象这个过程。</p>
<p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>任务一：学习 html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>任务二：学习 css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>任务三：学习 JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> ulElem = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> liElems = ulElem.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">liElems.forEach(<span class="function"><span class="params">liElem</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    liElem.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        e.target.className = <span class="string">&#x27;completed&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            ulElem.removeChild(e.target);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设我们现在有三个任务需要完成，我们完成了其中一个所以要点击删除它。现在点击其中一个，他将会在 2s 之后完成删除，但是假如我们在这过程中再次点击这一项，就会出现报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220116202742.png"></p>
<p>报错的原因也很明显，点击的时候这一项已经被删除了，当然也就没有了，也无法执行删除操作。</p>
<p>这时候我们可以封装一个高阶函数 <code>once</code>，这个函数的目标就是限制删除只能进行一次，确保操作的安全性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察这个函数的特征，它就是一个<strong>高阶函数</strong>。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>以函数作为参数</li>
<li>以函数作为返回值</li>
<li>经常用于作为函数装饰器</li>
</ul>
<p>常见的高阶函数还有：</p>
<ul>
<li>防抖和节流</li>
<li>consumer</li>
<li>iterative</li>
</ul>
<h4 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h4><ul>
<li>防抖：在某个时间段内，函数只执行一次；但如果在该时间段内再次触发了这个事件，就会重新计算函数的执行时间。</li>
<li>节流：在某个时间段内每隔一定时间，函数就执行一次。节流会降低函数的执行频率。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="comment">// 先开启一个定时任务执行，定时任务完成后则清空</span></span><br><span class="line"><span class="comment">// 当再调用时，如果定时任务仍存在则清空原来任务，创建新的定时任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="comment">// 先开启一个定时任务执行，定时任务完成后则清空</span></span><br><span class="line"><span class="comment">// 当再调用时，如果定时任务仍存在则不执行任何操作，如果不存在就开启一个新的定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试防抖的代码如下，节流同理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceFn = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我 resize 了&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, debounceFn);</span><br></pre></td></tr></table></figure>

<h4 id="iterative"><a href="#iterative" class="headerlink" title="iterative"></a>iterative</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检验是否可迭代</span></span><br><span class="line"><span class="keyword">const</span> isIterable = <span class="function"><span class="params">obj</span> =&gt;</span> obj !== <span class="literal">null</span></span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterative</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">subject, ...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isIterable(subject)) &#123;</span><br><span class="line">            <span class="comment">// 把所有的执行结果存储于 result 中并返回</span></span><br><span class="line">            <span class="keyword">const</span> result = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> subject) &#123;</span><br><span class="line">                result.push(fn.apply(<span class="built_in">this</span>, [obj, ...rest]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [subject, ...rest]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯函数-amp-非纯函数"><a href="#纯函数-amp-非纯函数" class="headerlink" title="纯函数 &amp; 非纯函数"></a>纯函数 &amp; 非纯函数</h3><ul>
<li>纯函数：如果输入值确定，那么输出值确定，函数没有状态。示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>非纯函数：依赖于外部的环境，比如网络请求。示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">elems, color</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> elems) &#123;</span></span><br><span class="line"><span class="javascript">            elem.style.color = color;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> els1 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li:nth-child(2n+1)&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> els2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li:nth-child(3n+1)&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    setColor(els2, <span class="string">&#x27;blue&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    setColor(els1, <span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
上面的代码中，两个 <code>setColor</code> 的调用顺序如果更换，执行的结果会不一样，所以它的结果会受外部环境的影响，是非纯函数。</li>
</ul>
<p>使用高阶函数，可以减少系统里面非纯函数的数量，从而使得系统的稳定性和可靠性加强。比如说，我们现在需要实现两个函数，一个是 <code>setColor(elem, color)</code>，一次改变一个元素的颜色，还有一个 <code>setColors(elems, color)</code>，一次改变多个元素的颜色。显然这两个函数都是非纯函数，但是我们可以选择直接定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setColors = iterative(setColor);</span><br></pre></td></tr></table></figure>

<p>这样就减少了一个非纯函数，有利于我们进行单元测试。</p>
<h3 id="命令式-amp-声明式"><a href="#命令式-amp-声明式" class="headerlink" title="命令式 &amp; 声明式"></a>命令式 &amp; 声明式</h3><p>命令式：强调过程是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 过程是给每个元素 × 2</span></span><br><span class="line">    arr.push(list[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明式：强调操作是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作是每个元素 x 2</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = list.map(double);</span><br></pre></td></tr></table></figure>

<p>假设现在需要实现一个开关，打开的时候显示字体 on，背景为绿色；关闭的时候显示字体 off，背景为红色。我们可以分别采用命令式和声明式实现。</p>
<p>命令式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span>off<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="css">        <span class="attribute">outline</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.on</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.off</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.target.className === <span class="string">&#x27;on&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">            e.target.className = <span class="string">&#x27;off&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            e.target.innerHTML = <span class="string">&#x27;off&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            e.target.className = <span class="string">&#x27;on&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            e.target.innerHTML = <span class="string">&#x27;on&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：实现简单，代码比较容易理解。</p>
<p>声明式：<br>定义一个高阶函数 <code>toggle</code>，来实现状态的切换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggle</span>(<span class="params">...actions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 先将第一个操作取出，然后再将其 push 到列表的末尾，因此可以实现循环</span></span><br><span class="line">        <span class="keyword">const</span> action = actions.shift();</span><br><span class="line">        actions.push(action);</span><br><span class="line">        <span class="keyword">return</span> action.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, toggle(</span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        e.target.className = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        e.target.className = <span class="string">&#x27;off&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;off&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<p>优点：很容易拓展状态，比如说我想加一个 <code>warn</code> 状态，非常简单，直接在 <code>toggle</code> 函数中加入新的一项即可。</p>
<p><em>所有的抽象都是为了提升可拓展性。 ——月影</em></p>
<p>弄了一晚上终于把上半节课的笔记做完了，呜呜太难了。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>字节前端青训营第 1 天</title>
    <url>/2022/01/15/byte-fe-training-1/</url>
    <content><![CDATA[<h1 id="DOCTYPE-的作用"><a href="#DOCTYPE-的作用" class="headerlink" title="DOCTYPE 的作用"></a>DOCTYPE 的作用</h1><ul>
<li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准来解析这个文档。如果 <code>DOCTYPE</code> 不存在或格式不正确的话，会导致文档以兼容模式呈现。</li>
<li>在标准模式（严格模式）下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式（怪异模式）下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</li>
</ul>
<h1 id="标签语义化的意义"><a href="#标签语义化的意义" class="headerlink" title="标签语义化的意义"></a>标签语义化的意义</h1><ul>
<li>便于浏览器的解析与渲染</li>
<li>帮助阅读代码的人更容易理解代码的结构，利于代码的维护</li>
<li>有利于 SEO</li>
<li>实现网页的无障碍阅读</li>
</ul>
<h1 id="strong-和-em-的区别"><a href="#strong-和-em-的区别" class="headerlink" title="strong 和 em 的区别"></a>strong 和 em 的区别</h1><ul>
<li><code>em</code> 用来局部强调，<code>strong</code> 则是全局强调</li>
<li><code>em</code> 的强调是有顺序的，只有阅读到某处时用户才会注意到。<code>strong</code> 的强调则是一种随意无顺序的，看见的时候立刻就凸显出来的关键词句。斜体和粗体刚好满足了这两种视觉效果，因此也就成了 <code>em</code> 和 <code>strong</code> 的默认样式。</li>
</ul>
<h1 id="href-和-src-的区别"><a href="#href-和-src-的区别" class="headerlink" title="href 和 src 的区别"></a>href 和 src 的区别</h1><ul>
<li>src 是 source 的缩写，指向外部资源的位置，指向的内容将会<strong>嵌入到文档中</strong>当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 iframe 等元素</li>
<li>href 是 Hypertext Reference 的缩写，指向网络资源所在位置。例如说我们在文档中添加 <code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>，那么浏览器会识别该文档为 CSS 文件，然后并行下载资源并且不会停止对当前文档的处理</li>
</ul>
<h1 id="iframe-的应用和缺点"><a href="#iframe-的应用和缺点" class="headerlink" title="iframe 的应用和缺点"></a>iframe 的应用和缺点</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">iframe 的应用</a><br>缺点：</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li>
</ul>
<h1 id="关于-line-height-继承的计算"><a href="#关于-line-height-继承的计算" class="headerlink" title="关于 line-height 继承的计算"></a>关于 line-height 继承的计算</h1><p><code>line-height</code> 有三种赋值方式，分别是单位、百分比、纯数字。</p>
<ul>
<li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>百分比：会将计算后的值传递给后代。例如，父级行高为 150%，font-size 是 20px，那么行高就是 20px * 150% = 30px，子元素也是 30px</li>
</ul>
<h1 id="line-height-与-height-的区别"><a href="#line-height-与-height-的区别" class="headerlink" title="line-height 与 height 的区别"></a>line-height 与 height 的区别</h1><ul>
<li><code>line-height</code> 是每一行文字的高度，如果文字换行，整个盒子的实际高度会变大，高度 = 行数 * 行高</li>
<li><code>height</code> 本身是一个已经写死的值，就代表盒子高度</li>
</ul>
<h1 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和 @import 的区别"></a>link 和 @import 的区别</h1><ul>
<li><code>link</code> 是 <code>html</code> 方式， <code>@import</code> 是 <code>css</code> 方式。<code>@import</code> 只有导入样式表的作用；<code>link</code> 不仅可以加载 CSS 文件，还可以定义其他属性，如 <code>shortcut</code></li>
<li>加载页面时，<code>link</code> 标签引入的 CSS 被同时并行加载；<code>@import</code> 引入的 CSS 将在页面加载完毕后被加载，可能会出现 FOUC</li>
<li>浏览器对 <code>link</code> 支持早于 <code>@import</code>，兼容性更好</li>
</ul>
<p>FOUC（Flash Of Unstyled Content）：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。</p>
<h1 id="CSS-什么属性可以继承，什么不能继承？"><a href="#CSS-什么属性可以继承，什么不能继承？" class="headerlink" title="CSS 什么属性可以继承，什么不能继承？"></a>CSS 什么属性可以继承，什么不能继承？</h1><p>可以继承：</p>
<ul>
<li>字体相关的属性，<code>font-size</code>、<code>font-weight</code> 等</li>
<li>文本相关的属性，<code>color</code>、<code>line-height</code> 、<code>text-align</code> 等</li>
<li>光标属性 <code>cursor</code></li>
<li>元素可见性 <code>visibility</code></li>
</ul>
<p>不可继承：几何属性，如 <code>padding</code>、<code>margin</code>、<code>border</code></p>
<p>当一个属性不是继承属性的时候，我们也可以通过将它的值设置为 <code>inherit</code> 来使它从父元素那获取同名的属性值来继承</p>
<h1 id="padding-和-margin-赋值为百分比的时候是相对于什么计算的？"><a href="#padding-和-margin-赋值为百分比的时候是相对于什么计算的？" class="headerlink" title="padding 和 margin 赋值为百分比的时候是相对于什么计算的？"></a>padding 和 margin 赋值为百分比的时候是相对于什么计算的？</h1><p>在默认的文档流方向下，<code>margin</code> 和 <code>padding</code> 的水平和垂直方向的百分比值<strong>都是相对于宽度</strong>计算的。</p>
<h1 id="CSS-画三角形"><a href="#CSS-画三角形" class="headerlink" title="CSS 画三角形"></a>CSS 画三角形</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;triangle&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.triangle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-color</span>: black transparent transparent transparent;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="margin-合并"><a href="#margin-合并" class="headerlink" title="margin 合并"></a>margin 合并</h1><p><a href="https://www.bilibili.com/video/BV1DE41197Kc">蛋老师</a></p>
<h1 id="盒子模型的类型"><a href="#盒子模型的类型" class="headerlink" title="盒子模型的类型"></a>盒子模型的类型</h1><p>有 3 种盒子模型：IE 盒模型（border-box）、标准盒模型（content-box）、padding-box<br>盒模型一般都由四部分组成：内容（content）、填充（padding）、边界（margin）、边框（border）</p>
<p>盒子模型之间的区别：</p>
<ul>
<li>标准盒模型：width，height 只包含内容 content，不包含 border 和 padding</li>
<li>IE 盒模型：width，height 包含 content、border 和 padding</li>
<li>padding-box：width，height 包含 content、padding，不包含 border</li>
</ul>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p><a href="https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md">BFC 解析</a></p>
<h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1><ul>
<li>id 选择器 #myid</li>
<li>类选择器 .classname</li>
<li>标签选择器 div</li>
<li>后代选择器 div p</li>
<li>子选择器 div &gt; p</li>
<li>兄弟选择器 div ~ p</li>
<li>相邻兄弟选择器 div + p</li>
<li>属性选择器 a[rel=”external”]</li>
<li>伪类选择器 a:hover，li:first-child</li>
<li>伪元素选择器 a::before，a:after</li>
<li>通配符选择器 *</li>
</ul>
<h1 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h1><ul>
<li>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过 <code>:hover</code> 来描述这个元素的状态</li>
<li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过 <code>::before</code> 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中</li>
</ul>
<h1 id="width-100-与-width-auto-的区别"><a href="#width-100-与-width-auto-的区别" class="headerlink" title="width: 100% 与 width: auto 的区别"></a>width: 100% 与 width: auto 的区别</h1><ul>
<li><code>width:100%</code> 并不包含 <code>margin-left</code> 和 <code>margin-right</code> 的属性值，直接取其父容器的宽度加上含 <code>margin-left</code> 和 <code>margin-right</code> 的值。如果设置了 <code>margin</code> 那新的 <code>width</code> 值是容器的宽度加上 <code>margin</code> 的值</li>
<li><code>width:auto</code> 包含 <code>margin-left</code> 和 <code>margin-right</code> 的属性值。<code>width:auto</code> 总是占据整行，<code>margin</code> 的值已经包含其中了</li>
<li>一般 <code>width:auto</code> 使用的多，因为这样灵活，而 <code>width: 100%</code> 使用比较少，因为在增加 <code>padding</code> 或者 <code>margin</code> 的时候，容易使其突破父级框，破坏布局</li>
</ul>
<p>举例来说，<br>当 child 没有加 <code>margin</code>，两者之间没什么区别。</p>
<p>以下面这段代码为例，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">195</span>, <span class="number">229</span>, <span class="number">236</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们将其改成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果相同，都是<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/202858.jpg"></p>
<p>但是如果给 child 加上 <code>margin</code> 后，比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>width: 100%</code> 的情况会变为：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/203137.jpg"></p>
<p><code>width: auto</code> 会变为：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/203252.jpg"></p>
<h1 id="图片空隙问题-amp-基线"><a href="#图片空隙问题-amp-基线" class="headerlink" title="图片空隙问题 &amp; 基线"></a>图片空隙问题 &amp; 基线</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align">vertical-align 戳这</a></p>
<p>图片空隙问题见下面的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/ai.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    我是哀酱</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220115213134.png"></p>
<p>因为是对齐基线，所以会有一点点空隙，修改方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="浏览器页面的渲染过程-amp-关键渲染路径"><a href="#浏览器页面的渲染过程-amp-关键渲染路径" class="headerlink" title="浏览器页面的渲染过程 &amp; 关键渲染路径"></a>浏览器页面的渲染过程 &amp; 关键渲染路径</h1><p><a href="https://juejin.cn/book/6850413616484040711/section/6850413616555491336">玩转 CSS 的艺术之美</a></p>
<h1 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h1><ul>
<li>块级元素可以设置宽高，独占一行</li>
<li>行内元素不可以设置宽高，不独占一行</li>
</ul>
<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">MDN 文档</a></p>
<h1 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid">MDN 文档</a></p>
<h1 id="float-图文环绕"><a href="#float-图文环绕" class="headerlink" title="float 图文环绕"></a>float 图文环绕</h1><p>根据老师的说法，<code>float</code> 现在的使用场景基本只有这个。<br>双飞翼 &amp; 圣杯：？？？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/ai.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;你的哀酱&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore</span><br><span class="line">        magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo</span><br><span class="line">        consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla</span><br><span class="line">        pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est</span><br><span class="line">        laborum.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220115212154.png"></p>
<h1 id="Chrome-文本小于-12px-如何解决"><a href="#Chrome-文本小于-12px-如何解决" class="headerlink" title="Chrome 文本小于 12px 如何解决"></a>Chrome 文本小于 12px 如何解决</h1><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示。<br>可以使用 <code>transform: scale(xx);</code> 解决。</p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划常见题目</title>
    <url>/2022/01/14/dp-common-questions/</url>
    <content><![CDATA[<p>dp 问题的思考过程主要包括 5 个方面：</p>
<ul>
<li>dp 数组的含义</li>
<li>base case，即边界</li>
<li>状态，即会变化的变量</li>
<li>选择：导致状态变化的行为</li>
<li>状态转移方程</li>
</ul>
<p>本文总结常见的动态规划题目：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">下降路径最小和</a></li>
<li><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
</ul>
<h1 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h1><p>这题属于是直接给出状态转移方程的 dp，所以不需要进行多余分析，直接确定边界就行了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minFallingPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 边界：第一行，最小路径和等于自己本身</span></span><br><span class="line">                dp[i][j] = matrix[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每行的最左边</span></span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) + matrix[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j === n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 每行的最右边</span></span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + matrix[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...dp[m - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><ul>
<li>dp 含义：状态只有一个，所以是一维数组。定义为输入目标金额 i，凑出该目标金额 i 的最少硬币数量为 dp[i]</li>
<li>边界：目标金额为 0，显然此时返回 0</li>
<li>状态：硬币数量无限，硬币的面额题目固定了，所以变量只有目标金额</li>
<li>选择：目标金额为什么会变化，是因为你选择了硬币</li>
<li>状态转移方程：dp[i] = min { dp[i - coins[i]] + 1, dp[i] }</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(amount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转移</span></span><br><span class="line">            dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] === amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><ul>
<li>dp 含义：dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度<br>以 1 4 3 4 2 为例：<ul>
<li>dp[0] 指 1 为结尾的最长递增子序列 1 的长度，即 1</li>
<li>dp[1] 指 4 为结尾的最长递增子序列 1 4 的长度，即 2</li>
<li>同理，dp[2] 为 1 3 的长度 2，dp[3] 为 1 3 4 的长度 3，dp[4] 为 1 2 的长度 2</li>
</ul>
</li>
<li>边界：如上例所示，显然 dp[i] 初始值为 1，因为以 nums[i] 结尾的最长递增子序列至少也要包含它自己</li>
<li>状态：最长递增子序列的长度</li>
<li>选择：更换了一个新的子序列结尾，就会导致最长递增子序列的长度变化</li>
<li>状态转移方程：举个例子，对于 1 4 3 4 2 3 来说，dp[0] = 1，dp[1] = 2，dp[2] = 2，dp[3] = 3，dp[4] = 2。现在要求的是 dp[5]，因为序列必须递增，所以我们从前面的子序列选取时，要满足的第一个条件是：<strong>结尾的字符比 nums[5] 要小</strong>；在此基础上，我们需要选取前面最长的一个子序列</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 边界，要全部初始化为 1</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断是否满足递增要求</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 状态转移</span></span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终结果是 dp 中的最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="变式一"><a href="#变式一" class="headerlink" title="变式一"></a>变式一</h2><p>如何输出这个子序列（若有多个满足条件，输出其中一个即可）？<br>使用一个 sequence 数组记录一下所有的子序列即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 记录所有的子序列</span></span><br><span class="line">    <span class="keyword">const</span> sequence = [];</span><br><span class="line">    <span class="comment">// 边界，要全部初始化为 1</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 边界，所有的 sequence[i] 设置为对应的 nums[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sequence[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断是否满足递增要求</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    sequence[i] = sequence[j] + <span class="string">&#x27; &#x27;</span> + nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到序列对应的下标</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span>, maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; dp[i]) &#123;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sequence[maxIndex];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="变式二"><a href="#变式二" class="headerlink" title="变式二"></a>变式二</h2><p>如何把时间复杂度优化到 O(NlogN)？<br>使用贪心算法。</p>
<ul>
<li>新建数组 ans，用于保存最长上升子序列（其实是假的）。</li>
<li>对原序列进行遍历，将每位元素二分插入 ans 中。<ul>
<li>如果 ans 中元素都比它小，将它插到最后</li>
<li>否则，用它覆盖掉比它大的元素中最小的那个<br>总之，思想就是让 ans 中存储比较小的元素。这样 ans 未必是真实的最长上升子序列，但长度是对的。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    ans.push(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// ans 中元素都比它小，将它插到最后</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; ans[ans.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans.push(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 二分，查找最左边满足条件的值的下标</span></span><br><span class="line">            <span class="keyword">let</span> left = <span class="number">0</span>, right = ans.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> targetIndex;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ans[mid] &gt;= nums[i]) &#123;</span><br><span class="line">                    <span class="comment">// 满足条件</span></span><br><span class="line">                    <span class="comment">// 因为查找的是最左的满足条件的元素，所以是收缩右边界</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                    targetIndex = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用它覆盖掉比它大的元素中最小的那个</span></span><br><span class="line">            ans[targetIndex] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="https://labuladong.gitee.io/algo/3/23/70/">https://labuladong.gitee.io/algo/3/23/70/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/solution/nickxue-xi-ji-hua-xi-lie-dong-tai-gui-hu-fbsb/">https://leetcode-cn.com/problems/minimum-falling-path-sum/solution/nickxue-xi-ji-hua-xi-lie-dong-tai-gui-hu-fbsb/</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a></li>
<li><a href="https://blog.csdn.net/weixin_30360497/article/details/94884825">https://blog.csdn.net/weixin_30360497/article/details/94884825</a></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树展开为链表</title>
    <url>/2022/01/13/flatten-binary-tree-to-linked-list/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a><br>解法分析：</p>
<p>解法一：前序遍历</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113194451.png"><br>由图示可知，树扯直以后特征是：每个左孩子为空，右孩子为前序遍历的下一位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = [];</span><br><span class="line">    preorderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pre = list[i - <span class="number">1</span>], cur = list[i];</span><br><span class="line">        pre.left = <span class="literal">null</span>;</span><br><span class="line">        pre.right = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        list.push(root);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法二：递归</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113195358.png"></p>
<p>把树拉直的步骤可归为以下三步：</p>
<ul>
<li>将左子树和右子树扯直<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113195524.png"></li>
<li>将右子树换成左子树<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113200803.png"></li>
<li>将原来的右子树接到当前右子树的后面<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113200913.png"></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历，所以此时二叉树已经被拉平</span></span><br><span class="line">    <span class="keyword">const</span> leftTree = root.left, rightTree = root.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将右子树换成左子树</span></span><br><span class="line">    root.right = leftTree;</span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将原来的右子树接到当前右子树的后面</span></span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (p.right) &#123; <span class="comment">// 查找最右节点</span></span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.right = rightTree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考题解：</p>
<ol>
<li><a href="https://labuladong.gitee.io/algo/2/17/21/">https://labuladong.gitee.io/algo/2/17/21/</a></li>
<li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表基础六大题型</title>
    <url>/2022/01/13/list-basic-questions/</url>
    <content><![CDATA[<ul>
<li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></li>
<li><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第 K 个节点</a> &amp; <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></li>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">链表的中间结点</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a> &amp; <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a> &amp; <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></li>
</ul>
<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = list1, p2 = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = p1 || p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="链表中倒数第-K-个节点"><a href="#链表中倒数第-K-个节点" class="headerlink" title="链表中倒数第 K 个节点"></a>链表中倒数第 K 个节点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="comment">// 要删除倒数第 n 个节点，则需要找到倒数第 n + 1 个节点</span></span><br><span class="line">    <span class="keyword">const</span> temp = getKthFromEnd(dummyHead, n + <span class="number">1</span>);</span><br><span class="line">    temp.next = temp.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getKthFromEnd</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> slow, fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> middleNode = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a>环形链表 II</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 标记是否有环</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 !== p2) &#123;</span><br><span class="line">        p1 = p1 ? p1.next : headB;</span><br><span class="line">        p2 = p2 ? p2.next : headA;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = cur.next; <span class="comment">// 存储 cur 的下一个节点</span></span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">// 移动指针，继续前进</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev; <span class="comment">// prev 最后指向的就是头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若链表只有一个节点或根本没有节点，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newList = reverseList(head.next);</span><br><span class="line">    <span class="comment">// 假设节点 head 为节点 1，节点 head 的下一个节点为节点 2</span></span><br><span class="line">    <span class="keyword">const</span> p2 = head.next; <span class="comment">// 获取节点 2</span></span><br><span class="line">    p2.next = head; <span class="comment">// 节点 2 的 next 指向节点 1</span></span><br><span class="line">    head.next = <span class="literal">null</span>; <span class="comment">// 节点 1 的 next 设为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113161308.png"></p>
<p>如果对 2-&gt;3-&gt;4 进行递归反转，则得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113161403.png"></p>
<p>接下来只要把节点 2 的 next 指向节点 1，然后节点 1 的 next 指向 null 即可，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113161457.png"></p>
<h1 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h1><ul>
<li>定义两个指针，分别称之为 g（guard 守卫） 和 p（point）。我们首先根据方法的参数 left 确定 g 和 p 的位置。将 g 移动到第一个要反转的节点的前面，将 p 移动到第一个要反转的节点的位置上。我们以 left = 2，right = 4 为例。</li>
<li>头插法：将 p 后面的元素删除，然后添加到 g 的后面。</li>
<li>重复上面头插法的步骤，一共需要操作 right - left 次。</li>
</ul>
<ol>
<li><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113171031.png"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113171056.png"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220113171126.png"></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> g = dummyHead, p = dummyHead.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        g = g.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">        <span class="comment">// 暂存删除节点</span></span><br><span class="line">        <span class="keyword">let</span> removed = p.next;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        <span class="comment">// 插入刚才删除的节点</span></span><br><span class="line">        removed.next = g.next;</span><br><span class="line">        g.next = removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="https://www.pianshen.com/article/1931399442/">https://www.pianshen.com/article/1931399442/</a></li>
<li><a href="https://labuladong.gitee.io/algo/2/16/15/">https://labuladong.gitee.io/algo/2/16/15/</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/</a></li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序数组的重复元素</title>
    <url>/2022/01/13/remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<p>该类题目包含以下的四道题：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></li>
<li><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li>
</ul>
<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== nums[slow]) &#123;</span><br><span class="line">            <span class="comment">// 每次找到一个不重复的元素就告诉 slow 并让 slow 前进一步</span></span><br><span class="line">            <span class="comment">// 然后给 slow 赋值 fast 所在位置的值</span></span><br><span class="line">            <span class="comment">// 因为第一个元素必定不是重复元素，所以先移动 slow</span></span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.val !== slow.val) &#123;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与后面断开连接</span></span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== val) &#123;</span><br><span class="line">            <span class="comment">// 第一个元素也可能等于 val，所以先赋值再移动 slow</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow, fast;</span><br><span class="line">    slow = fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== <span class="number">0</span>) &#123;</span><br><span class="line">            [nums[slow], nums[fast]] = [nums[fast], nums[slow]];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考题解：</p>
<ol>
<li><a href="https://labuladong.gitee.io/algo/4/29/120/">https://labuladong.gitee.io/algo/4/29/120/</a></li>
<li>代码随想录</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Eslint、Prettier、Commitlint 打造 React 开发规范</title>
    <url>/2022/01/12/eslint-prettier-commitlint/</url>
    <content><![CDATA[<h1 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h1><p>首先使用脚手架 <code>create-react-app</code> 创建应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create react-app project-name --template typescript</span><br></pre></td></tr></table></figure>

<h1 id="添加-baseUrl"><a href="#添加-baseUrl" class="headerlink" title="添加 baseUrl"></a>添加 baseUrl</h1><p>打开文件 tsconfig.json，添加 baseUrl</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220112234515.png"></p>
<h1 id="添加-prettier"><a href="#添加-prettier" class="headerlink" title="添加 prettier"></a>添加 prettier</h1><p><a href="https://prettier.io/docs/en/index.html">prettier 官方文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add --dev --exact prettier</span><br></pre></td></tr></table></figure>

<p>在根目录创建空文件 <strong>.prettierrc.json</strong>，里面写入内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>根目录创建新文件 <strong>.prettierignore</strong>，里面写入内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">build</span><br><span class="line">coverage</span><br></pre></td></tr></table></figure>

<p>接下来配置 <strong>pre-commit hooks</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx mrm@2 lint-staged</span><br></pre></td></tr></table></figure>
<p>配置后，每次代码提交之前都会自动格式化</p>
<p>为了避免 prettier 与 eslint 冲突，需要安装 <strong>eslint-config-prettier</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add eslint-config-prettier -D</span><br></pre></td></tr></table></figure>

<p>修改 package.json，在 lint-staged 配置项中增加 ts 和 tsx 选项（可自行选择其余拓展名）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220123222007.png"></p>
<p>修改 package.json，添加 prettier 拓展。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220125103608.png"></p>
<h1 id="添加-commitlint"><a href="#添加-commitlint" class="headerlink" title="添加 commitlint"></a>添加 commitlint</h1><p><a href="https://github.com/conventional-changelog/commitlint">commitlint github 链接</a></p>
<p>设置提交规范</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @commitlint/config-conventional @commitlint/cli -D</span><br></pre></td></tr></table></figure>

<p>根目录新建文件 <strong>commitlint.config.js</strong>，添加如下内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn husky add .husky/commit-msg <span class="string">&#x27;yarn commitlint --edit $1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>提交类型总结</p>
<ul>
<li>build    编译相关的修改，例如发布版本、对项目构建或者依赖的改动</li>
<li>chore    其他修改，比如改变构建流程、或者增加依赖库、工具等</li>
<li>ci 持续集成修改</li>
<li>docs 文档修改</li>
<li>feat 新特性、新功能</li>
<li>fix    修改bug</li>
<li>perf 优化相关，比如提升性能、体验</li>
<li>refactor 代码重构</li>
<li>revert 回滚到上一个版本</li>
<li>style    代码格式修改，注意不是 css 修改</li>
<li>test 测试用例修改</li>
</ul>
<p>参考资料：<br>链接：<a href="https://www.jianshu.com/p/9edce0b60f83">https://www.jianshu.com/p/9edce0b60f83</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>手写 Promise</title>
    <url>/2022/01/11/hand-write-promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 避免多次 resolve 或 reject</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 一旦 resolve 执行，调用成功数组的函数</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 一旦 reject 执行，调用失败数组的函数</span></span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// executor 同步执行，用户可以选择调用 resolve 和 reject</span></span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 当不是函数时，onFulfilled 返回一个普通的值，成功时直接等于 value</span></span><br><span class="line">            onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 当不是函数时，onRejected 直接抛出错误</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onFulfilled 和 onRejected 都必须异步调用，而且严格意义上应该是微任务</span></span><br><span class="line">        <span class="comment">// 此处只是使用 setTimeout 来模拟异步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 onFulfilled 或 onRejected 报错，则直接 reject</span></span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state === FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// resolvePromise 函数，处理自己 return 的 promise 和默认的 promise2 的关系</span></span><br><span class="line">                        <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state === REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理不同的 promise 套用</span></span><br><span class="line">    <span class="function"><span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 成功和失败只能调用一个，此处防止多次调用</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> then = x.then;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                    then.call(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// resolve 的结果依旧是 promise 那就继续解析</span></span><br><span class="line">                        <span class="built_in">this</span>.resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成书写以后，可以使用 npm 包 <code>promises-aplus-tests</code> 进行测试。</p>
<p>测试前需要加上这几行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h1><p><code>Promise.resolve</code> 会将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h1><p>和 <code>Promise.resolve</code> 类似，<code>Promise.reject</code> 会实例化一个 rejected 状态的 Promise。但与 <code>Promise.resolve</code> 不同的是，如果给 <code>Promise.reject</code> 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resolveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promise).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolveCount++;</span><br><span class="line">                result[index] = val;</span><br><span class="line">                <span class="keyword">if</span> (resolveCount === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promise).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    <span class="attr">state</span>: FULFILLED,</span><br><span class="line">                    <span class="attr">value</span>: val</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    <span class="attr">state</span>: REJECTED,</span><br><span class="line">                    <span class="attr">value</span>: err</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promise).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rejectCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promise).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                rejectCount++;</span><br><span class="line">                <span class="keyword">if</span> (rejectCount === promiseArr.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;All promises were rejected&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://juejin.cn/post/6844903625769091079">https://juejin.cn/post/6844903625769091079</a><br><a href="https://juejin.cn/post/6946022649768181774">https://juejin.cn/post/6946022649768181774</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>js 事件机制</title>
    <url>/2022/01/11/js-event/</url>
    <content><![CDATA[<h1 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h1><p>当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p>
<h1 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h1><p>与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220111124002.png"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#div1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#div2</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    div2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当点击 div2 时，会弹出两个弹出框。在 Chrome 浏览器，会先弹出 2 再弹出 1，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反。</p>
<p>W3C 的标准是先捕获再冒泡， <code>addEventListener</code> 函数的第三个参数决定把事件注册在捕获（true）还是冒泡（false）。</p>
<h1 id="事件流阻止"><a href="#事件流阻止" class="headerlink" title="事件流阻止"></a>事件流阻止</h1><p><code>event.preventDefault()</code>：取消事件对象的默认动作以及继续传播</p>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件冒泡还允许我们利用<strong>事件委托</strong>这个概念依赖于这样一个事实，如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p>
<p>一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将click单击事件监听器设置在父元素 <code>&lt;ul&gt;</code> 上，这样事件就会从列表项冒泡到其父元素 <code>&lt;ul&gt;</code> 上。</p>
<p>例如，假设现在有 100 个 li，每个 li 有相同的点击事件。如果为每个 li 都添加事件，则会造成 DOM 访问次数过多，引起浏览器重绘与重排的次数过多，因此性能会降低。使用事件委托则可以解决这样的问题。</p>
<p>实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的 ul、li、a 的点击事件都会冒泡到最外层节点上，委托它代为执行事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> target = ev.target;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (target.nodeName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                alert(target.innerHTML);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>new 详解</title>
    <url>/2022/01/11/new/</url>
    <content><![CDATA[<h1 id="new-关键字做了什么"><a href="#new-关键字做了什么" class="headerlink" title="new 关键字做了什么"></a>new 关键字做了什么</h1><ul>
<li>创建一个新对象</li>
<li>将新对象原型设置为构造函数原型</li>
<li>使用 apply 绑定 this</li>
<li>返回结果，需要特判上一步的返回值是否是 Object 类型</li>
</ul>
<h1 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 把该对象的原型设置为 fn 的原型</span></span><br><span class="line">    <span class="keyword">if</span> (fn.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf(obj, fn.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 apply，改变构造函数 this 的指向到新建的对象</span></span><br><span class="line">    <span class="comment">// 这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">const</span> result = fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const person = new Person(&#x27;Jack&#x27;, 12);</span></span><br><span class="line"><span class="keyword">const</span> person = myNew(Person, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>js 继承</title>
    <url>/2022/01/11/js-inherit/</url>
    <content><![CDATA[<p>常见的继承主要有三种：</p>
<ul>
<li>组合继承</li>
<li>寄生组合继承</li>
<li>ES6 的 class</li>
</ul>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><ul>
<li>子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性</li>
<li>改变子类的原型为 <code>new Parent()</code> 来继承父类的函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    Pareng.call(<span class="built_in">this</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child);</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent);</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>使用组合继承时，父类构造函数会被调用两次</li>
<li>生成了两个实例，但是子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以造成了子类的原型中多了一些不必要的属性，增加了不必要的内存</li>
</ul>
<h1 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要修改一行代码即可</span></span><br><span class="line"><span class="comment">// Child.prototype = new Parent();</span></span><br><span class="line">Child.proptotype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br></pre></td></tr></table></figure>

<h1 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.getValue());</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现 call、apply、bind</title>
    <url>/2022/01/10/hand-write-apply-call-bind/</url>
    <content><![CDATA[<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><ul>
<li>获取第一个参数，若不存在则为 window</li>
<li>执行 &amp; 删除这个函数</li>
<li>指定 this 到函数并传入给定参数执行函数</li>
<li>如果不传入参数，默认指向为 window</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若第一个参数传入 null 或 undefined，this 指向 window</span></span><br><span class="line">    <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 context 上加一个唯一值，避免影响 context 上的属性</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    <span class="comment">// 此处的 this 指的是传入的函数</span></span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args);</span><br><span class="line">    <span class="comment">// 删除副作用，避免 context 的属性越来越多</span></span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">f.myCall(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>apply 与 call 几乎完全一样，只是传入的参数形式不同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若第一个参数传入 null 或 undefined，this 指向 window</span></span><br><span class="line">    <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在context上加一个唯一值，避免影响 context 上的属性</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    <span class="comment">// 此处的 this 指的是传入的函数</span></span><br><span class="line">    context[key] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args);</span><br><span class="line">    <span class="comment">// 删除副作用，避免 context 的属性越来越多</span></span><br><span class="line">    <span class="keyword">delete</span> context[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">f.myApply(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (<span class="built_in">this</span>) !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The bound object needs to be a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用了 new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> newFunction) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _this.call(context, ...args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;poetries&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">foo.myBind(a, <span class="number">1</span>, <span class="number">2</span>)(); <span class="comment">// =&gt; &#x27;poetries&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 详解（译）</title>
    <url>/2022/01/10/js-promise/</url>
    <content><![CDATA[<h1 id="为什么需要-Promise"><a href="#为什么需要-Promise" class="headerlink" title="为什么需要 Promise"></a>为什么需要 Promise</h1><p>JavaScript 是一门单线程编程语言，这意味着一次只能发生一件事情。在 ES6 之前，我们使用回调函数来处理异步任务，例如网络请求。使用 promise，我们可以避免臭名昭著的回调地狱，使得我们的代码更简洁、可读性更高、更容易理解。</p>
<p>假设我们要从服务器获取一些异步数据，使用回调函数来处理，我们可能会遇到这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    getMoreData(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y); </span><br><span class="line">        getSomeMoreData(y, <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(z);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这就是回调地狱，每一个回调都被嵌套在另一个回调之中，除了最外层之外，其余所有的回调函数都依赖于它们父级回调函数。</p>
<p>我们可以使用 Promise 重写上面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData()</span><br><span class="line">    .then(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">        <span class="keyword">return</span> getMoreData(x);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y);</span><br><span class="line">        <span class="keyword">return</span> getSomeMoreData(y);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">z</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(z);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以看到代码变得更简洁、更清晰也更易于理解了。</p>
<h1 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h1><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。比如我们需要从服务器获取数据，Promise 承诺（promise）会帮我们在将来使用的时候获取到数据。</p>
<p>在我们讨论技术相关的问题之前，让我们先了解一下 Promise 的相关术语。</p>
<h1 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h1><p>Promise 有三种状态：</p>
<ul>
<li>pending：初始状态，承诺既没有被兑现，也没有被拒绝。</li>
<li>resolved / fulfilled：意味着操作成功完成。</li>
<li>rejected：意味着操作失败。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110212112.png"></p>
<h1 id="Promise-的创建"><a href="#Promise-的创建" class="headerlink" title="Promise 的创建"></a>Promise 的创建</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Promise 构造函数来创建对象，该构造函数的参数只有一个，它是一个执行器函数，其中包括两个回调函数 resolve 和 reject。</p>
<p>执行器函数会在 promise 对象创建的时候就直接执行。我们可以使用 resolve 当操作成功，使用 reject 当操作失败。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (allWentWell) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;All things went well!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>resolve 和 reject 可以传入一个参数，类型为 string、number、boolean、array 或 object。</p>
<p>我们来通过另一个例子彻底弄明白 promise 的创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> randomNumber = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (randomNumber &lt; <span class="number">0.6</span>) &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;All things went well!&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这里，我使用 Promise 构造函数创建一个新的 promise。promise 创建 2 秒后 resolve 或 reject。如果随机数小于 0.6，则 resolved，否则就 rejected。</p>
<p>当 promise 创建的时候，它会位于 pending 状态。<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110213623.png"></p>
<p>2s 后当定时器结束，根据随机数情况，promise 要么会 resolved，要么会 rejected。<br>resolved 的情况：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110213808.png"><br>rejected 的情况：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110213851.png"></p>
<p>注意：一个 promise 只能被 resolve 或者 reject 一次。多余的 resolve 或 reject 操作将不起作用。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise resolved&#x27;</span>);  <span class="comment">// Promise is resolved</span></span><br><span class="line">    reject(<span class="string">&#x27;Promise rejected&#x27;</span>);   <span class="comment">// Promise can&#x27;t be rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Promise-的使用"><a href="#Promise-的使用" class="headerlink" title="Promise 的使用"></a>Promise 的使用</h1><p>我们通过调用 <code>then</code> 和 <code>catch</code> 方法来使用 promise。<br>语法为：<br><code>.then()</code>: promise.then(successCallback, failureCallback)<br>成功的时候会调用 successCallback，失败的时候会调用 failureCallback。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> randomNumber = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">if</span> (randomNumber &lt; <span class="number">0.7</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;All things went well!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);  <span class="comment">// prints &#x27;All things went well!&#x27;</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// prints Error object</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>.catch()</code>: promise.catch(failureCallback)<br>我们可以使用 <code>catch</code> 来捕获错误，它的可读性要强于前面使用的 <code>failureCallback</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error); <span class="comment">// prints Error object</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p><code>then</code> 和 <code>catch</code> 函数会返回一个新的 promise 对象，所以它可以继续被捕获，从而形成链式调用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise1 resolved&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise2 resolved&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;Promise3 rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise1</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);  <span class="comment">// Promise1 resolved</span></span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);  <span class="comment">// Promise2 resolved</span></span><br><span class="line">        <span class="keyword">return</span> promise3;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);  <span class="comment">// Promise3 rejected</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>解析上述代码：</p>
<ul>
<li>When promise1 is resolved, the <code>then()</code> method is called which returns promise2.</li>
<li>The next <code>then()</code> is called when promise2 is resolved which returns promise3.</li>
<li>Since promise3 is rejected, the next <code>then()</code> is not called instead <code>catch()</code> is called which handles the promise3 rejection.</li>
</ul>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>很多的新手会错误地嵌套 promise，这样做依然可以正常运行，但是代码不利于阅读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise1 resolved&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise2 resolved&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;Promise3 rejected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);  <span class="comment">// Promise1 resolved</span></span><br><span class="line">    promise2.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);  <span class="comment">// Promise2 resolved</span></span><br><span class="line"></span><br><span class="line">        promise3.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);  <span class="comment">// Promise3 rejected</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p><code>Promise.all()</code> 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 变为失败状态的值，并且 reject 的是<strong>第一个</strong>抛出的错误信息。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Promise1 resolved&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Promise2 resolved&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2])</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data[<span class="number">0</span>], data[<span class="number">1</span>]))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure>

<p>当您有多个 promise，并且希望知道所有 promise 何时可以 resolved，这个方法非常有用。例如，如果您正在从不同的 API 请求数据，并且仅当所有请求都成功时才希望对数据执行某些操作。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p><code>Promise.race()</code> 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Promise1 resolved&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise2 rejected&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2])</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data))  <span class="comment">// Promise1 resolved</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure>

<h1 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h1><p>这个方法用于返回第一个成功的 promise 。只要有一个 promise 成功此方法就会终止，它不会等待其他的 promise 全部完成。<br><code>Promise.any()</code> 与 <code>Promise.race()</code> 的区别：<br>不像 <code>Promise.race()</code> 总是返回第一个结果值（resolved / reject）那样，这个方法返回的是第一个成功的值。这个方法将会忽略掉所有被拒绝的 promise，直到第一个 promise 成功。</p>
<h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h1><p><code>Promise.allSettled()</code> 与 <code>Promise.all ()</code> 的区别：</p>
<ul>
<li>它们所返回的数据不太一样，<code>Promise.all()</code> 返回一个直接包裹 resolve 内容的数组，则 <code>Promise.allSettled()</code> 返回一个包裹着对象的数组。</li>
<li>对于 <code>Promise.all()</code> 来说，如果有一个 Promise 对象报错了，则 <code>Promise.all()</code> 无法执行，会直接报错，无法获得其他成功的数据。而 <code>Promise.allSettled()</code> 方法是不管有没有报错，把所有的 Promise 实例的数据都返回回来，放入到一个对象中。如果是 resolve 的数据则 status 值为 fulfilled，否则为 rejected。</li>
</ul>
<p>原文：<br><a href="https://blog.bitsrc.io/understanding-promises-in-javascript-c5248de9ff8f">https://blog.bitsrc.io/understanding-promises-in-javascript-c5248de9ff8f</a><br>参考资料：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br><a href="https://blog.csdn.net/iloveyu123/article/details/116588214">https://blog.csdn.net/iloveyu123/article/details/116588214</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply、bind 辨析（译）</title>
    <url>/2022/01/10/call-apply-bind/</url>
    <content><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>如果您正在学习 JavaScript，您可能已经了解到了 <code>this</code> 关键字。JavaScript 中的 <code>this</code> 关键字的行为与其他编程语言不同，这给不少程序员带来了困惑。<br>在其他面向对象编程语言中，<code>this</code> 关键字总是指向类的当前实例。而在 JavaScript 中，它的值取决于函数的调用方式。<br>我们来通过一些例子说明一下 JavaScript 中的 <code>this</code>。</p>
<h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.printName(); <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p>此处因为我通过 <code>person</code> 对象来调用 <code>printName</code> 函数，所以 <code>this</code> 指向 <code>person</code> 对象。</p>
<p>我们在刚才的代码片段后面添加下面两行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> printFullName = person.printName;</span><br><span class="line">printFullName(); <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure>
<p>我们惊奇地发现打印结果是两个 <code>undefined</code>。</p>
<p><strong>原因是什么？</strong><br>此处我们把 <code>person.printName</code> 的引用存储到了变量 <code>printFullName</code> 中。此后，我们调用它，且没有指明调用它的对象。这种情况下，<code>this</code> 会指向 window 或 undefined（严格模式下）。</p>
<p>因此会输出两个 undefined；若是在严格模式下则会报错。</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">incrementCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, counter.incrementCounter);</span><br></pre></td></tr></table></figure>

<p><code>incrementCounter</code> 中的 <code>this</code> 将会指向谁呢？<br>事实上，在上面的代码中，this 关键字会指向 <code>event</code> 对象，而不是 <code>counter</code> 对象。</p>
<p>根据前面所举的例子，我们可以发现函数中的 <code>this</code> 关键字指向根据函数的调用情况决定。有时候我们会一不小心丢失掉 <code>this</code>。那么我们如何才能防止这种情况的发生呢？</p>
<h1 id="call、bind、apply"><a href="#call、bind、apply" class="headerlink" title="call、bind、apply"></a>call、bind、apply</h1><p>我们知道在 JavaScript 中函数是一种特殊的对象，所以我们可以获取它的方法和属性。为了证明函数也是对象，我们可以做一些诸如下面这样的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">greeting.lang = <span class="string">&#x27;English&#x27;</span>;</span><br><span class="line"><span class="comment">// Prints &#x27;English&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting.lang);</span><br></pre></td></tr></table></figure>
<p>JavaScript 也提供了一些特殊的方法和属性给每一个函数对象。所以 JavaScript 中的每个函数都继承了一些方法，其中就包括 call、apply、bind。</p>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>bind 创建一个新的函数，并把 this 指向传入的对象。<br>语法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.bind(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>举个例子，假如我们有两个人物对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> john = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>bind</code> 方法来让 <code>this</code> 指向 john 和 jane 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greetingJohn = greeting.bind(john);</span><br><span class="line"><span class="comment">// Hi, I am John and I am 24 years old</span></span><br><span class="line">greetingJohn();</span><br><span class="line"><span class="keyword">const</span> greetingJane = greeting.bind(jane);</span><br><span class="line"><span class="comment">// Hi, I am Jane and I am 22 years old</span></span><br><span class="line">greetingJane();</span><br></pre></td></tr></table></figure>

<p>此处 <code>greeting.bind(john)</code> 创建了一个新的函数，且 <code>this</code> 指向了传入的 john 对象，接着把它赋值给了变量 <code>greetingJohn</code></p>
<p>我们也可以使用 bind 来 DOM 操作的情况，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">incrementCounter</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, counter.incrementCounter.bind(counter));</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，this 会正确地指向 <code>counter</code> 对象而不是 <code>event</code> 对象。</p>
<p>注意：多次 <code>bind()</code> 是无效的，只会绑定到第一次调用的对象上</p>
<h2 id="bind-接收多个参数"><a href="#bind-接收多个参数" class="headerlink" title="bind 接收多个参数"></a>bind 接收多个参数</h2><p><code>bind</code> 可以接收多个参数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;lang&#125;</span>: I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> greetingJohn = greeting.bind(john, <span class="string">&#x27;en&#x27;</span>);</span><br><span class="line">greetingJohn();</span><br><span class="line"><span class="keyword">const</span> greetingJane = greeting.bind(jane, <span class="string">&#x27;es&#x27;</span>);</span><br><span class="line">greetingJane();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们把参数 <code>en</code> 传递给了 <code>greeting</code> 函数。</p>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p><code>call</code> 会将 <code>this</code> 指向对象，并立即执行。<br><code>call</code> 和 <code>bind</code> 的区别在于，<code>call</code> 会使函数立即执行，而 <code>bind</code> 会创建一个新的函数，不会马上执行。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Hi, I am John and I am 24 years old</span></span><br><span class="line">greeting.call(john);</span><br><span class="line"><span class="comment">// Hi, I am Jane and I am 22 years old</span></span><br><span class="line">greeting.call(jane);</span><br></pre></td></tr></table></figure>
<p>上面例子我们可以看出 <code>call</code> 的结果是立即执行该函数。</p>
<h2 id="call-接收多个参数"><a href="#call-接收多个参数" class="headerlink" title="call 接收多个参数"></a>call 接收多个参数</h2><p><code>call</code> 可以接收多个参数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">greeting</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Hi, I am John and I am 24 years old</span></span><br><span class="line">greet.call(john, <span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line"><span class="comment">// Hello, I am Jane and I am 22 years old</span></span><br><span class="line">greet.call(jane, <span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p><code>apply</code> 和 <code>call</code> 非常相像，不同之处在于 <code>apply</code> 的参数是一个数组，而 <code>call</code> 的参数是分散开的。</p>
<p>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">greeting, lang</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(lang);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Hi, I am John and I am 24 years old</span></span><br><span class="line">greet.apply(john, [<span class="string">&#x27;Hi&#x27;</span>, <span class="string">&#x27;en&#x27;</span>]);</span><br><span class="line"><span class="comment">// Hello, I am Jane and I am 22 years old</span></span><br><span class="line">greet.apply(jane, [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;es&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>原文：<br><a href="https://blog.bitsrc.io/understanding-call-bind-and-apply-methods-in-javascript-33dbf3217be">https://blog.bitsrc.io/understanding-call-bind-and-apply-methods-in-javascript-33dbf3217be</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>js 作用域和作用域链详解（译）</title>
    <url>/2022/01/10/js-scope-and-scope-chain/</url>
    <content><![CDATA[<h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>JavaScript 中的作用域是指变量的可访问性或可见性。也就是说，程序的哪些部分可以访问变量。</p>
<h1 id="作用域的重要性"><a href="#作用域的重要性" class="headerlink" title="作用域的重要性"></a>作用域的重要性</h1><ul>
<li>作用域的主要好处是具有安全性。也就是说，变量只能从程序的某些区域访问。通过作用域，我们可以避免对程序其他部分的变量进行意外的修改。</li>
<li>作用域可以减小命名空间的冲突。也就是说，在不同的作用域中，我们可以使用同名的变量。</li>
</ul>
<h1 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h1><p>作用域有三种类型：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>不在任何函数或块（一对花括号）内的变量都在全局作用域内。全局作用域内的变量可以从程序中的任何位置访问。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">greet();</span><br></pre></td></tr></table></figure>

<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数中声明的变量在函数作用域内，这些变量只能从该函数的内部访问，不能从外部区域访问。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">greet();</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure>

<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>对于 ES6 的 let 和 const 关键字声明的变量，不像 var 声明的变量，它们可以通过最近的一对花括号形成块级作用域。也就是说，在花括号外部不能访问花括号里面声明的变量。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> lang = <span class="string">&#x27;English&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting); <span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &#x27;English&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure>

<h1 id="作用域的嵌套"><a href="#作用域的嵌套" class="headerlink" title="作用域的嵌套"></a>作用域的嵌套</h1><p>就像 JavaScript 的函数一样，一个作用域可以被另一个作用域包裹。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> lang = <span class="string">&#x27;English&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;lang&#125;</span>: <span class="subst">$&#123;greeting&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure>
<p>这里有三个彼此嵌套的作用域，包括前面所说的全局作用域、块级作用域、函数作用域。</p>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>词法作用域（又称静态作用域）的字面意思是在词法分析时（通常称为编译）而不是在运行时确定作用域。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">54</span>;</span><br><span class="line">    printNumber();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints 42</span></span><br><span class="line">log();</span><br></pre></td></tr></table></figure>
<p>这里 <code>console.log(number)</code> 会始终打印出 42，不管函数 <code>printNumber</code> 在什么时候被调用。这与具有动态作用域的语言不同，支持动态作用域的语言中函数的执行结果可能会受其它函数调用的影响。比如上面的代码中，如果是用一种支持动态作用域的语言编写的话，那么 <code>console.log(number)</code> 的输出结果应该是 54。<br>使用词法作用域，我们可以通过查看源代码来确定变量的作用域。然而，在动态作用域的情况下，只有执行代码才能确定作用域。<br>大多数编程语言支持静态作用域，如C、C++、java、JavaScript。Perl 支持静态和动态两种作用域。</p>
<h1 id="什么是作用域链"><a href="#什么是作用域链" class="headerlink" title="什么是作用域链"></a>什么是作用域链</h1><p>在 JavaScript 中使用变量时，JavaScript 引擎将尝试在当前作用域内查找变量的值。如果找不到变量，它将查看外部的作用域，并将继续这样做，直到找到变量或到达全局作用域。<br>如果仍然找不到变量，它将在全局作用域内隐式声明变量（如果不是在严格模式下），或者返回错误（严格模式下）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">    <span class="comment">// Prints &#x27;baz&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(baz);</span><br><span class="line">    <span class="comment">// Prints &#x27;foo&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(number);  <span class="comment">// Prints 42</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>当函数 <code>bar</code> 被执行时，JavaScript 引擎会去寻找变量 <code>baz</code>，然后在当前作用域找到了。接着，它会去寻找变量 <code>foo</code>，然后发现无法在当前作用域中找到。所以它会去外部的作用域中寻找，然后成功找到了该变量。<br>之后，JavaScript 会在当前作用域和外部作用域中寻找 <code>number</code> 变量，但是发现找不到。此时如果是非严格模式，会在全局声明一个变量 <code>number</code> 并给它赋值 42；若是在严格模式下，将会报错。<br>总而言之，当一个变量被使用的时候，JavaScript 引擎会沿着作用域链去遍历这个变量直到找到或到达全局作用域。</p>
<h1 id="作用域和作用域链的工作原理"><a href="#作用域和作用域链的工作原理" class="headerlink" title="作用域和作用域链的工作原理"></a>作用域和作用域链的工作原理</h1><p>为了理解作用域和作用域链的作用原理，我们必须先理解词法环境的概念。</p>
<h2 id="什么是词法环境"><a href="#什么是词法环境" class="headerlink" title="什么是词法环境"></a>什么是词法环境</h2><p>词法环境是用于保存 <code>标识符-变量</code> 的映射的结构。这里标识符是指变量/函数的名称，变量是对实际对象（包括函数对象和数组对象）或基本类型的引用。</p>
<p>简而言之，<strong>词法环境是存储变量和对象引用的地方</strong>。</p>
<p>注意：不要混淆词法作用域和词法环境，词法作用域是在编译时确定的一个范围，词法环境是在程序执行期间存储变量的地方。</p>
<p>一个词法环境可以被抽象地表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    a: 25,</span><br><span class="line">    obj: &lt;ref. to the object&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当词法作用域中的代码执行时，每个词法作用域中会创建一个新的词法环境。词法环境也有对外部词法环境（即外部作用域）的引用。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    a: 25,</span><br><span class="line">    obj: &lt;ref. to the object&gt;</span><br><span class="line">    outer: &lt;outer lexical environemt&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-引擎如何进行变量的查找"><a href="#JavaScript-引擎如何进行变量的查找" class="headerlink" title="JavaScript 引擎如何进行变量的查找"></a>JavaScript 引擎如何进行变量的查找</h2><p>现在我们知道了什么是作用域、作用域链和词法环境，下面让我们了解 JavaScript 引擎如何使用词法环境来确定作用域和作用域链。以下面代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greeting&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">greet();</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载上述脚本时，将创建一个全局词法环境，其中包含在全局作用域内定义的变量和函数。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">globalLexicalEnvironment = &#123;</span><br><span class="line">    greeting: &#x27;Hello&#x27;</span><br><span class="line">    greet: &lt;ref. to greet function&gt;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部作用域设置为 null 的原因是没有全局作用域外部没有别的作用域了。</p>
<p>此后遇到了一个 <code>greet</code> 函数的调用。所以 <code>greet</code> 函数的词法环境会被创建。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionLexicalEnvironment = &#123;</span><br><span class="line">    name: &#x27;Peter&#x27;</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此后，JavaScript 引擎会执行 <code>console.log($&#123;greeting&#125; $&#123;name&#125;)</code> 语句。<br>JavaScript 引擎尝试在函数的词法环境中查找变量 <code>greeting</code> 和 <code>name</code>。它在当前词法环境中找到了 <code>name</code> 变量，但在当前词法环境中找不到 <code>greeting</code> 变量。</p>
<p>所以它去外部的词法环境（此处指全局词法环境）寻找 <code>greeting</code> 变量，并成功找到。</p>
<p>接下来，JavaScript 引擎要执行块内的代码。因此，它为该块创建了一个新的词法环境。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">    greeting: &#x27;Hello World&#x27;,</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着 <code>console.log(greeting)</code> 语句被执行，JavaScript 引擎会在当前此法环境找到 <code>greeting</code> 变量。</p>
<p>注意：新的词法环境只会被 <code>let</code> 和 <code>const</code> 声明创建，而不会被 <code>var</code> 声明创建。<code>var</code> 声明会被添加到当前的词法环境中（全局词法环境或函数词法环境）</p>
<p>总而言之，当在程序中使用变量时，JavaScript 引擎将尝试在当前词法环境中查找该变量，如果在当前词法环境中找不到该变量，它将在外部词法环境中查找该变量。这就是 JavaScript 引擎执行变量查找的方法。</p>
<p>原文：<br><a href="https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53">https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>js 异步原理详解（译）</title>
    <url>/2022/01/10/js-asynchronous/</url>
    <content><![CDATA[<p>JavaScript 是一种单线程编程语言，这意味着每次只能做一件事情。也就是说，JavaScript 引擎在每个线程中一次只能处理一条语句。虽然单线程语言简化了代码的编写，因为您不必担心并发性问题，但这也意味着您无法在不阻塞主线程的情况下执行长时间操作，如网络访问。</p>
<h1 id="JavaScript-同步工作原理"><a href="#JavaScript-同步工作原理" class="headerlink" title="JavaScript 同步工作原理"></a>JavaScript 同步工作原理</h1><p>在深入研究异步 JavaScript 之前，让我们首先了解同步 JavaScript 代码在 JavaScript 引擎中是如何执行的。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> second = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello there!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi there!&#x27;</span>);</span><br><span class="line">    second();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The End&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br></pre></td></tr></table></figure>
<p>为了理解上面的代码在 JavaScript 引擎中是如何执行的，我们必须要理解执行上下文和调用栈（又称执行栈）的概念</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文是一个关于解析和执行 JavaScript 代码的环境的抽象概念。任何代码在 JavaScript 中运行时，实际上都是在执行上下文中运行。函数代码在函数执行上下文中执行，全局代码在全局执行上下文中执行。每个函数都有自己的执行上下文。</p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈是一个具有后进先出结构的栈，用于存储代码执行期间创建的所有执行上下文。<br>JavaScript 只有一个单调栈，因为它是一门单线程编程语言。调用栈具有后进先出结构，这意味着只能从栈顶进行添加或删除操作。<br>我们重新理解一下上面给出的代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> second = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello there!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi there!&#x27;</span>);</span><br><span class="line">    second();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The End&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110111059.png"></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #888;"><b>上述代码的调用栈</b></div>
    <br>
</center>

<h1 id="JavaScript-异步工作原理"><a href="#JavaScript-异步工作原理" class="headerlink" title="JavaScript 异步工作原理"></a>JavaScript 异步工作原理</h1><p>现在我们已经了解了调用栈的基本概念，以及同步 JavaScript 的工作原理，现在让我们再回到异步 JavaScript。</p>
<h2 id="什么是阻塞"><a href="#什么是阻塞" class="headerlink" title="什么是阻塞"></a>什么是阻塞</h2><p>现在假设我们的图片加载和网络请求操作是同步进行，就像下面的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processImage = <span class="function">(<span class="params">image</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * doing some operations on image</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Image processed&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> networkRequest = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * requesting network resource</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">return</span> someData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processImage(logo.jpg);</span><br><span class="line">networkRequest(<span class="string">&#x27;www.somerandomurl.com&#x27;</span>);</span><br><span class="line">greeting();</span><br></pre></td></tr></table></figure>
<p>进行图像处理和网络请求需要时间。因此，当调用 <code>processImage</code> 函数时，需要花费一些时间，具体取决于图像的大小。<br>当 <code>processImage</code> 函数完成时，它将从调用栈中删除。然后调用 <code>networkRequest</code> 函数并将其压入栈中。同样，它的执行也需要一些时间。<br>最后，当 <code>networkRequest</code> 函数完成时，会调用 <code>greeting</code> 函数，因为它只包含一条 <code>console.log</code> 语句，而且 <code>console.log</code> 语句执行得通常很快，因此会接着立即执行 <code>greeting</code> 函数。<br>因此，我们必须等到函数 <code>processImage</code> 和 <code>networkRequest</code> 完成。这意味着这些函数将会阻塞调用栈，也即是阻塞主线程。因此，在执行上述代码时，我们不能执行任何其他操作，这是不理想的，因为会造成不好的用户体验。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最简单普遍的一种方法是使用异步的调用栈。我们通过使用异步的调用栈来使得我们的代码不会阻塞。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> networkRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Async Code&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">networkRequest();</span><br></pre></td></tr></table></figure>
<p>这里我用 <code>setTimeout</code> 函数来模拟网络请求。请牢记 <code>setTimeout</code> 不是 Javascript 引擎的一部分，而是 web API 的一部分。（在 Nodejs 中，web API 被 C/C++ API 所取代）<br>为了理解这段代码是如何执行的，我们需要了解更多的相关概念，比如事件循环和任务队列（也叫消息队列）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220110114417.png"></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #888;"><b>JavaScript 运行时环境的概述</b></div>
    <br>
</center>

<p>事件循环、web API 和任务队列不是 JavaScript 引擎的一部分，而是浏览器 JavaScript 运行时环境或 Nodejs 的 JavaScript 运行时环境的一部分。（在 Nodejs 中，web API 被 C/C++ API 所取代）</p>
<p>现在让我们回到上面的代码，看看它是如何以异步方式执行的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> networkRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Async Code&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">networkRequest();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;The End&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当上述代码被加载到浏览器中时，<code>console.log(‘Hello World’)</code> 被压入执行栈，并在完成执行后弹出执行栈。接下来，遇到了一个 <code>networkRequest</code> 函数的调用，所以它的执行上下文被压入栈中。<br>接着 <code>setTimeout</code>函数被调用了，所以它被压入栈中。<code>setTimeout</code> 函数有两个参数，第一个是回调函数，第二个是延迟的时间（单位是 ms）。<br><code>setTimeout</code> 函数在 web API 环境下开启了一个时长 2s 的定时器。此时，<code>setTimeout</code> 函数已经执行完成并从栈中弹出。此后，<code>console.log(&#39;The End&#39;)</code> 被压入调用栈，执行完成后从栈中移出。<br>接着，当定时器计时时间到达，回调函数被压入到任务队列中。但是任务队列中的回调函数不会被立即执行，这时候事件循环开始起作用了。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环的任务是查看调用栈并确定调用栈是否为空。如果调用栈为空，它将查看任务队列，查看是否有任何回调函数在等待执行。<br>在这个例子中，任务队列中有一个回调函数，而且调用栈是空的，所以事件循环会把这个回调函数压入调用栈中，也就是把 <code>console.log(‘Async Code’)</code> 压入调用栈，执行并从栈中弹出。此后，全局代码调用结束，全局执行上下文从栈中弹出，然后程序运行完成。</p>
<h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><p>任务队列中也包含 DOM 中的事件操作，比如点击事件、键盘事件等。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Button Clicked&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，事件监听器位于 web API 环境中，并等待某个事件（在本例中为点击事件）发生。当该事件发生时，回调函数会被存储进消息队列中等待执行。事件循环会检查调用栈是否为空，如果为空，则将任务队列中事件的回调函数压入栈中并执行。</p>
<h2 id="ES6-的微任务队列"><a href="#ES6-的微任务队列" class="headerlink" title="ES6 的微任务队列"></a>ES6 的微任务队列</h2><p>ES6 引入了微任务队列的概念，用于 Promise 的相关操作。宏任务队列和微任务队列之间的区别在于，微任务队列的优先级高于宏任务队列，这意味着微任务队列中的回调函数执行将优先于宏任务队列中的回调函数。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise resolved&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script End&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script start</span><br><span class="line">Script End</span><br><span class="line">Promise resolved</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>可见 promise 是先于 <code>setTimeout</code> 函数执行的，因为 promise 的 response 会被存储在微任务队列，优先级高于宏任务队列。</p>
<p>我们来看第二个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout 1&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout 2&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 1 resolved&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 2 resolved&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script End&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script start</span><br><span class="line">Script End</span><br><span class="line">Promise 1 resolved</span><br><span class="line">Promise 2 resolved</span><br><span class="line">setTimeout 1</span><br><span class="line">setTimeout 2</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这两个 promise 是在 <code>setTimeout</code> 中的回调函数之前执行的，因为事件循环认为微任务队列中的任务优先于宏任务队列中的任务。<br>当事件循环执行微任务队列中的任务时，如果在此期间存在一个 promise 已经 resolve 了，它将被添加到同一个微任务队列的末尾，并且无论回调等待执行的时间有多长，它都将在宏任务队列中的回调执行之前执行。</p>
<p>比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 1 resolved&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 2 resolved&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Promise 3 resolved&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Script End&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script start</span><br><span class="line">Script End</span><br><span class="line">Promise 1 resolved</span><br><span class="line">Promise 2 resolved</span><br><span class="line">Promise 3 resolved</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>
<p>因此，微任务队列中的所有任务都将在宏任务队列中的任务之前执行。也就是说，在执行宏任务队列中的任何回调函数之前，事件循环将首先清空微任务队列。</p>
<p>原文：<br><a href="https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff">https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2022/01/09/edit-distance/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p>
<p>定义 dp[i][j] 的含义为：word1 的前 i 个字符和 word2 的前 j 个字符的编辑距离。意思就是 word1 的前 i 个字符，变成 word2 的前 j 个字符，最少需要这么多步。</p>
<p>边界：如果其中一个字符串是空串，那么编辑距离是另一个字符串的长度。比如空串 “” 和 “ro” 的编辑距离是 2（做两次“插入”操作）。再比如 “hor” 和空串 “” 的编辑距离是 3（做三次 “删除” 操作）。</p>
<p>状态转移：<br>对于每对字符 s1[i] 和 s2[j]，可以有四种操作：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">    啥都别做（skip）</span><br><span class="line">    i, j 同时向前移动</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    三选一：</span><br><span class="line">        插入（insert）</span><br><span class="line">        删除（delete）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></table></figure>
<ul>
<li>word1 执行插入操作：在 s1[i] 插入一个和 s2[j] 一样的字符，那么 s2[j] 就被匹配了。然后移动 j，让 i 和下一个 j 匹配。dp[i][j] = dp[i][j - 1] + 1<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/leetcode.png"></li>
<li>word1 执行删除操作：直接把 s1[i] 字符删除，那么 s2[j] 就被匹配了。然后继续移动 i，让新的 i 与原来的 j 匹配。dp[i][j] = dp[i - 1][j] + 1<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/leetcode4.png"></li>
<li>word1 执行替换操作：直接把 s1[i] 替换成 s2[j]，这样它们就匹配了。然后 i 和 j 同时移动，进行下一个字符的比较。dp[i][j] = dp[i - 1][j - 1] + 1<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/leetcode3.png"></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = word1.length, n = word2.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] === word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考题解：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/">https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/</a></li>
<li><a href="https://labuladong.gitee.io/algo/3/23/73/">https://labuladong.gitee.io/algo/3/23/73/</a></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2022/01/08/sorting-summary/</url>
    <content><![CDATA[<p>复习手写排序</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的基本思想是，<strong>对相邻的元素进行两两比较</strong>，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 标记是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么第二层循环的结束下标是 len - 1 - i</strong>？<br>随着外层循环的进行，数组尾部的元素会渐渐变得有序当我们走完第 1 轮循环的时候，最大的元素被排到了数组末尾；走完第 2 轮循环的时候，第 2 大的元素被排到了数组倒数第 2 位；走完第3轮循环的时候，第 3 大的元素被排到了数组倒数第 3 位……以此类推，走完第 n 轮循环的时候，数组的后 n 个元素就已经是有序的，所以后面的部分就不需要再排序了。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的基本思想为每一趟从待排序的数据元素中<strong>选择最小</strong>（或最大）的一个元素作为首元素，直到所有元素排完为止。在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex !== i) &#123;</span><br><span class="line">            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>直接插入排序基本思想是每一步将一个待排序的记录，<strong>插入到前面已经排好序的有序序列</strong>中去，直到插完所有元素为止。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。<strong>递归</strong>的将数组两两分开直到只包含一个元素，然后将数组排序<strong>合并</strong>，最终合并为排序好的数组。<br><strong>模拟过程</strong></p>
<ul>
<li>递归分割</li>
<li>[8, 7, 6, 5, 4, 3, 2, 1]</li>
<li>[8, 7, 6, 5,| 4, 3, 2, 1]</li>
<li>[8, 7,| 6, 5,| 4, 3,| 2, 1]</li>
<li>[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]</li>
<li>合并</li>
<li>[7, 8,| 5, 6,| 3, 4,| 1, 2]</li>
<li>[5, 6, 7, 8,| 1, 2, 3, 4]  </li>
<li>[1, 2, 3, 4, 5, 6, 7, 8]  </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割点</span></span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 递归分割左子数组</span></span><br><span class="line">    <span class="keyword">const</span> left = mergeSort(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">    <span class="comment">// 递归分割右子数组</span></span><br><span class="line">    <span class="keyword">const</span> right = mergeSort(arr.slice(mid, len));</span><br><span class="line">    <span class="comment">// 合并左右两个有序数组</span></span><br><span class="line">    arr = merge(left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> len1 = arr1.length, len2 = arr2.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">            res.push(arr1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(arr2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.concat(arr1.slice(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.concat(arr2.slice(j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的基本思想是通过一趟排序将要排序的数据<strong>分割成独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = partion(arr, left, right);</span><br><span class="line">    quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以基准值为轴心，划分左右子数组的过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partion</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">    <span class="comment">// 随机快排，防止遇到有序数组导致复杂度降到 n 方</span></span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (right - left)) + left + <span class="number">1</span>;</span><br><span class="line">    [arr[left], arr[randomIndex]] = [arr[randomIndex], arr[left]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pivot = arr[left];</span><br><span class="line">  <span class="keyword">let</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="comment">// 此处必须先移动 j 后移动 i</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line"></span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [arr[i], arr[left]] = [arr[left], arr[i]];</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ans = quickSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ans);</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，<strong>整个序列的最大值就是堆顶的根节点</strong>。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n - 1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    buildMaxHeap(arr); <span class="comment">// 将传入的数组建立为大根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环，将首个元素（即最大元素）与末尾元素交换，然后剩下的元素重新构建为大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [arr[<span class="number">0</span>], arr[i]] = [arr[i], arr[<span class="number">0</span>]];</span><br><span class="line">        adjustMaxHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustMaxHeap</span>(<span class="params">arr, root, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxIndex, lchild, rchild;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        maxIndex = root; <span class="comment">// 根所在值即最大值</span></span><br><span class="line">        lchild = root * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子下标</span></span><br><span class="line">        rchild = root * <span class="number">2</span> + <span class="number">2</span>; <span class="comment">// 右孩子下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">        <span class="keyword">if</span> (lchild &lt; heapSize &amp;&amp; arr[maxIndex] &lt; arr[lchild]) &#123;</span><br><span class="line">            maxIndex = lchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右子元素存在，且右子元素大于最大值，则更新最大值索引</span></span><br><span class="line">        <span class="keyword">if</span> (rchild &lt; heapSize &amp;&amp; arr[maxIndex] &lt; arr[rchild]) &#123;</span><br><span class="line">            maxIndex = rchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大元素被更新了，则交换位置，以保证根的值最大，同时还要更新根的值</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex !== root) &#123;</span><br><span class="line">            [arr[root], arr[maxIndex]] = [arr[maxIndex], arr[root]];</span><br><span class="line">            root = maxIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未被更新，说明该子树满足大根堆的要求，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length, lastElem = len &gt;&gt; <span class="number">1</span> - <span class="number">1</span>; <span class="comment">// 数组长度，最后一个非叶子元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustMaxHeap(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://juejin.cn/book/6844733800300150797/section/6844733800367439885">https://juejin.cn/book/6844733800300150797/section/6844733800367439885</a><br><a href="https://www.kancloud.cn/pillys/qianduan/2051370">https://www.kancloud.cn/pillys/qianduan/2051370</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第 K 个最大元素</title>
    <url>/2022/01/08/kth-largest-element-in-an-array/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<p>解法分析：快排变种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> target = nums.length - k;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">nums, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (right - left)) + left + <span class="number">1</span>;</span><br><span class="line">            [nums[left], nums[randomIndex]] = [nums[randomIndex], nums[left]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">let</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &gt;= pivot &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &lt;= pivot &amp;&amp; i &lt; j) i++;</span><br><span class="line"></span><br><span class="line">            [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        [nums[i], nums[left]] = [nums[left], nums[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考题解：<br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>codetop</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2022/01/08/permutations/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a><br>解法分析：<br>解决一个回溯问题，实际上就是一个决策树的遍历过程。只需要思考 3 个问题：</p>
<ul>
<li>路径：也就是已经做出的选择</li>
<li>选择列表：也就是你当前可以做的选择</li>
<li>结束条件：也就是到达决策树底层，无法再做选择的条件</li>
</ul>
<p>比如：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220108172212.png"><br>回溯的通用解法:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p>核心可以用一句话总结：<strong>在递归之前做出选择，在递归之后撤销刚才的选择。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// set 用于记录是否访问过，也可以开一个 vis 数组标记</span></span><br><span class="line">    backtrack([]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 回溯边界</span></span><br><span class="line">        <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">            res.push(path.concat());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.has(i)) &#123;</span><br><span class="line">                path.push(nums[i]); <span class="comment">// 做选择</span></span><br><span class="line">                set.add(i); <span class="comment">// 标记</span></span><br><span class="line"></span><br><span class="line">                backtrack(path);</span><br><span class="line"></span><br><span class="line">                path.pop(); <span class="comment">// 撤销选择</span></span><br><span class="line">                set.delete(i); <span class="comment">// 取消标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考题解：</p>
<ol>
<li><a href="https://labuladong.gitee.io/algo/1/5/">https://labuladong.gitee.io/algo/1/5/</a></li>
<li><a href="https://gitee.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.md#javascript">https://gitee.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.md#javascript</a></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>codetop</tag>
      </tags>
  </entry>
  <entry>
    <title>层序遍历</title>
    <url>/2022/01/08/levelorder-traversal/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3">https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3</a><br>解法分析：纯的层序遍历，使用 BFS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment"> *   this.val = x;</span></span><br><span class="line"><span class="comment"> *   this.left = null;</span></span><br><span class="line"><span class="comment"> *   this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param </span>root TreeNode类 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return </span>int整型二维数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [], queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上到下遍历每一层</span></span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelSize = queue.length;</span><br><span class="line">        res.push([]);</span><br><span class="line">        <span class="comment">// 从左到右遍历该层的所有结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentLevelSize; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            res[res.length - <span class="number">1</span>].push(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层的结点放入队列</span></span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">levelOrder</span> : levelOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>前端冷知识</title>
    <url>/2022/01/07/front-end-cold-knowledge/</url>
    <content><![CDATA[<p>本文摘自<a href="https://forum.juejin.cn/youthcamp/category/6950604566098346019">字节青训营社区技术问答板块</a></p>
<h1 id="1-在什么情况下-a-a-1-？（上）"><a href="#1-在什么情况下-a-a-1-？（上）" class="headerlink" title="#1 在什么情况下 a === a - 1 ？（上）"></a>#1 在什么情况下 a === a - 1 ？（上）</h1><ul>
<li>正负 Infinity<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220107232953.png"></li>
<li>给 a 赋一个很大的值（准确地说，是超过 <code>Number.MAX_SAFE_INTEGER</code> 的数）<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220107233143.png"><br>这是因为在 JavaScript 里，整数可以被精确表示的范围是从 <code>-2 ** 53 + 1</code> 到 <code>2 ** 53 - 1</code>，即 -9007199254740991 到 9007199254740991。超过这个数值的整数，都不能被精确表示。</li>
<li>注意 NaN 跟任何值都不相等，包括 NaN 本身<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220107233346.png"></li>
</ul>
<h1 id="2-在什么情况下-a-a-1-？（下）"><a href="#2-在什么情况下-a-a-1-？（下）" class="headerlink" title="#2 在什么情况下 a === a - 1 ？（下）"></a>#2 在什么情况下 a === a - 1 ？（下）</h1><p>使用 <code>defineProperty</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a === a - <span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title>由 setTimeout 引发的连环追问</title>
    <url>/2022/01/06/settimeout-resultd-question/</url>
    <content><![CDATA[<h1 id="基础问"><a href="#基础问" class="headerlink" title="基础问"></a>基础问</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>这段代码的执行结果是什么？<br>答案：立刻输出一个 5，1s 后再一次性输入 5 个 5。<br>解释：</p>
<ul>
<li>因为 setTimeout 是异步函数，每一次 for 循环的时候，setTimeout 都执行一次，但是里面的函数没有被执行，而是被放到了任务队列里，等待执行。只有主线程上的任务执行完，才会执行任务队列里的任务。也就是说它会等到 for 循环全部运行完毕后，才会执行 setTimeout 里面的函数，但是当 for 循环结束后此时 i 的值已经变成了 5，因此控制台上的内容会输出 5 个 5。</li>
<li>关于这 5 个 5 为什么是一次性输出的：这里涉及到 JS 中的<strong>定时器机制</strong>，循环执行过程中，几乎同时设置了 5 个定时器。一般情况下，这些定时器都会在大约 1 秒之后触发，而循环完的输出是立即执行的，因此会立即输出 5 个 5。</li>
</ul>
<h1 id="改造的思路"><a href="#改造的思路" class="headerlink" title="改造的思路"></a>改造的思路</h1><p>如果期望代码的输出变成 1s 后输出 0，1，2，3，4，该怎么改造代码？<br>首先思考为什么会输出 5 个 5 呢？究其缘由，var 声明的变量不存在块级作用域，所以最终的 i 都是同一个 i。也就是说，i 是声明在全局作用域中的。所以如果我们可以使 i 声明在私有作用域中，就可以解决这个 bug。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>因此，我们可以利用闭包，让 i 在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前 i 的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;  <span class="comment">// 相当于 j = i</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>

<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><p>接着我们很自然地会想到使用 let，let 本身当然是可以的，但是此处代码的最后一行十分恶心，要求输出 i，所以会报错。</p>
<h1 id="拆分结构"><a href="#拆分结构" class="headerlink" title="拆分结构"></a>拆分结构</h1><p>闭包解决方法的最大问题就是可读性不好。<br>我们可以利用一个特性：JS 中基本类型的参数传递是<strong>按值传递</strong>的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    output(i); <span class="comment">// 此处传过去的 i 被复制了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>

<h1 id="setTimeout-的第三个参数"><a href="#setTimeout-的第三个参数" class="headerlink" title="setTimeout 的第三个参数"></a>setTimeout 的第三个参数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如果想要每隔-1s-输出一次怎么办"><a href="#如果想要每隔-1s-输出一次怎么办" class="headerlink" title="如果想要每隔 1s 输出一次怎么办"></a>如果想要每隔 1s 输出一次怎么办</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span> * j);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;, <span class="number">1000</span> * i);</span><br></pre></td></tr></table></figure>

<p>这算是一种解决方法，但是太粗暴了（x</p>
<h1 id="使用-ES6-优化（Promise）"><a href="#使用-ES6-优化（Promise）" class="headerlink" title="使用 ES6 优化（Promise）"></a>使用 ES6 优化（Promise）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行异步操作；当异步操作完成之后，输出最后的 i = 5</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="使用-ES7-优化（await）"><a href="#使用-ES7-优化（await）" class="headerlink" title="使用 ES7 优化（await）"></a>使用 ES7 优化（await）</h1><p>使用 <code>await</code> 优化其实是很简单的，实际上就相当于写同步，只要实现一个 sleep 函数就行了。（bks 异步的最终解决方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟其他语言中的 sleep 函数</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeout</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, timeout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;  <span class="comment">// 声明立即执行的 async 函数表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最后的 5</span></span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://juejin.cn/post/6844903474212143117">https://juejin.cn/post/6844903474212143117</a><br><a href="https://juejin.cn/post/6844903612879994887">https://juejin.cn/post/6844903612879994887</a><br><a href="https://juejin.cn/post/6844903841888993287">https://juejin.cn/post/6844903841888993287</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 闭包详解（译）</title>
    <url>/2022/01/06/closure/</url>
    <content><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是一个可以访问外部函数作用域的函数，即便外部函数已经运行完成。这意味着闭包可以记住并访问其外部函数的变量和参数，即使在函数完成之后也是如此。<br>在深入闭包之前，我们首先需要理解词法作用域。</p>
<h1 id="什么是词法作用域"><a href="#什么是词法作用域" class="headerlink" title="什么是词法作用域"></a>什么是词法作用域</h1><p>Javascript 词法作用域是指我们可以获取源代码中变量、函数、对象的物理位置。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(c);   <span class="comment">// prints &#x27;inner&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(b);   <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);   <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a);  </span><br></pre></td></tr></table></figure>
<p>此处函数 <code>inner</code> 可以获取它自己作用域、<code>outer</code> 函数作用域、全局作用域中的变量；<code>outer</code> 函数可以获取它自己作用域、全局作用域中的变量。</p>
<h1 id="闭包的具体实例"><a href="#闭包的具体实例" class="headerlink" title="闭包的具体实例"></a>闭包的具体实例</h1><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们调用了 <code>person</code> 函数，它会返回内部的函数 <code>displayName</code> 并把这个内部函数存储在变量 <code>peter</code> 中。当我们调用函数 <code>peter</code> 时，实际上也就是在调用函数 <code>displayName</code>，因此 console 结果为 Peter。</p>
<p>但是在函数 <code>displayName</code> 里面并不存在一个叫 <code>name</code> 的变量，也就意味着这个函数可以以某种方式获取它外部的函数 <code>person</code> 中的值，甚至在 <code>person</code> 函数返回之后。所以 <code>displayName</code> 函数实际上就是一个闭包。</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这次我们把一个通过 <code>getCounter</code> 返回的匿名函数存储在一个叫做 <code>count</code> 的变量中。因为 <code>count</code> 函数是一个闭包，它可以通过函数 <code>getCounter</code> 获取变量 <code>counter</code> 的值，即便是在 <code>getCounter</code> 函数已经返回之后。</p>
<p><strong>这里我们需要注意的是，变量 <code>counter</code> 在每次调用时，并没有重置为 0。</strong>这似乎有悖我们之前对函数的认知。<br>这是因为每次调用函数 <code>count</code> 的时候，虽然都会创建一个 <code>count</code> 的新的函数作用域，但是对于函数 <code>getCounter</code> 始终只存在一个作用域，而 <code>counter</code> 变量是在 <code>getCounter</code> 的作用域中定义的，所以每次我们调用函数 <code>count</code> 的时候，计数会递增，而不是重置为 0。</p>
<h1 id="闭包的工作原理"><a href="#闭包的工作原理" class="headerlink" title="闭包的工作原理"></a>闭包的工作原理</h1><p>要想清楚地理解闭包的工作原理，我们需要首先理解 Javascript 中的两个重要概念：</p>
<ul>
<li>执行上下文</li>
<li>词法环境</li>
</ul>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>简单来说，执行上下文是关于 Javascript 代码解析和执行的环境的抽象概念。JavaScript 中运行任何的代码都是在执行上下文中运行的。</p>
<p>因为 Javascript 是单线程语言，所以一次只能有一个正在运行的执行上下文，它由一个被称为执行栈或调用栈的数据结构管理。</p>
<p>当前运行的执行上下文将始终位于栈顶，并且当当前函数运行完成时，对应的执行上下文会从栈顶弹出，并将控制权移交给下一个执行上下文。</p>
<p>请看例子：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106201705.png"></p>
<p>当这段代码运行时，Javascript 引擎会创建一个全局执行上下文来运行全局代码，而当遇到函数 <code>first</code> 时，它会为 <code>first</code> 函数创建一个新的执行上下文，并将其压入栈内。</p>
<p>执行栈的图示就像这样：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106201922.png"></p>
<p>当 <code>first</code> 函数执行完成时，它的执行上下文会从执行栈中弹出，然后控制权移交给它下面的执行上下文，也就是全局上下文。</p>
<h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>每当 Javascript 引擎为全局代码或者某个函数创建一个新的执行上下文的时候，它同时也会创建一个新的词法环境，用于存储函数执行过程中出现的变量。</p>
<p>词法环境是一个类似 <code>(标识符, 变量)</code> 的映射数据结构，这里的标识符具体指变量名或者函数名，而变量指的是对象的引用，包括它的函数类型或者初始值。</p>
<p>每一个词法环境有三个组件：</p>
<ul>
<li>环境记录器：环境记录器用于存储变量或函数声明的实际位置</li>
<li>一个对外部环境的引用：外部引用意味着它可以访问它外部（父级）的词法环境</li>
<li>this 的绑定</li>
</ul>
<p>词法环境可以被抽象地表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        &lt;identifier&gt;: &lt;value&gt;,</span><br><span class="line">        &lt;identifier&gt;: &lt;value&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Reference to the parent lexical environment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下面这段代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">25</span>;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Inside global execution context&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>全局作用域的词法环境如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">globalLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        a: &#x27;Hello World!&#x27;,</span><br><span class="line">        first: &lt;reference to function object&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>first</code> 函数的词法环境如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        b: 25,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的外部词法环境被设置为全局词法环境，因为该函数被源代码中的全局作用域包围。</p>
<p>注意：当函数执行完成时，它的执行上下文将从执行栈中弹出，但是它的词法环境<strong>不一定</strong>从内存中删除，这取决于该词法环境是否被它外部词法环境属性中的任意其它的词法环境所引用。</p>
<h1 id="结合实例来看闭包的工作原理"><a href="#结合实例来看闭包的工作原理" class="headerlink" title="结合实例来看闭包的工作原理"></a>结合实例来看闭包的工作原理</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当 <code>person</code> 函数执行的时候，Javascript 引擎会为这个函数创建一个新的<strong>执行上下文</strong>和<strong>词法环境</strong>。在这个函数执行完成后，它会返回 <code>displayName</code> 函数然后将它赋值给变量 <code>peter</code>。<br>词法环境如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">personLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        name: &#x27;Peter&#x27;,</span><br><span class="line">        displayName: &lt;displayName function reference&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数 <code>person</code> 执行完成之后，执行上下文会从执行栈中弹出。但是它的词法环境依然在内存中，因为它的词法环境被它内部的 <code>displayName</code> 函数的词法环境引用了。所以它的变量在内存中依然可以获取。</p>
<p><strong>简单来说就是，执行上下文删除了，但是词法环境还在。</strong>（译者注）</p>
<p>当 <code>peter</code> 函数（实际上是对 <code>displayName</code> 函数的引用）执行时，JavaScript 引擎为该函数创建一个新的执行上下文和词法环境。对应的词法环境如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">displayNameLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;personLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>displayName</code> 函数中没有变量，所以它的环境记录器将为空。在执行此函数期间，JavaScript 引擎将尝试在函数的词法环境中查找变量 <code>name</code>。</p>
<p>而在 <code>displayName</code> 函数的词法环境中没有变量 <code>name</code>，所以它会去外部词法环境中找，也就是还在内存中的 <code>person</code> 函数的词法环境。JavaScript 引擎查找到了变量 <code>name</code> 后，将其打印到控制台。</p>
<p>原文：<br><a href="https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda">https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>js 执行上下文详解（译）</title>
    <url>/2022/01/06/execution-context/</url>
    <content><![CDATA[<h1 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h1><p>简单来说，执行上下文是关于 Javascript 代码解析和执行的<strong>环境</strong>的抽象概念。JavaScript 中运行任何的代码都是在执行上下文中运行的。</p>
<h1 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h1><ul>
<li>全局执行上下文：任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li>
<li>函数执行上下文：每当一个<strong>函数被调用</strong>时, 都会为该函数创建一个新的上下文。每一个函数都有它自己的执行上下文，但它是在函数被调用的时候创建的。函数执行上下文可以有任意多个。</li>
<li>eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但 JavaScript 开发者并不经常使用 eval，所以此处不再赘述。</li>
</ul>
<h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈，也就是调用栈，它用来存储代码运行时创建的所有执行上下文。本质上它就是数据结构中所说的栈，满足先进后出。<br>当 JavaScript 引擎第一次读取你的脚本时，它会创建一个全局执行上下文并将其压入执行栈；每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈。<br>JavaScript 引擎会优先运行执行上下文位于栈顶的函数。当该函数运行结束时，其对应的执行上下文会从栈中弹出，上下文的控制权将被移到当前执行栈的下一个执行上下文。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">    second();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Inside Global Execution Context&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106131015.png"></p>
<ul>
<li>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈</li>
<li>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制权移交给下一个执行上下文，即 <code>first()</code> 函数的执行上下文</li>
<li>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，上下文控制权会被移交给全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文</li>
</ul>
<h1 id="执行上下文是如何创建的"><a href="#执行上下文是如何创建的" class="headerlink" title="执行上下文是如何创建的"></a>执行上下文是如何创建的</h1><p>创建执行上下文有两个阶段：</p>
<ul>
<li>创建阶段</li>
<li>执行阶段</li>
</ul>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>在创建阶段创建执行上下文。在创建阶段会发生以下情况：</p>
<ol>
<li>创建词法环境组件</li>
<li>创建变量环境组件</li>
</ol>
<p>我们可以将其抽象表示为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">    LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">    VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>词法环境是用于保存 <code>标识符-变量</code> 的映射的结构。这里标识符是指变量/函数的名称，变量是对实际对象（包括函数对象和数组对象）或基本类型的引用。</p>
<p>简而言之，<strong>词法环境是存储变量和对象引用的地方</strong>。</p>
<p>根据官方的 ES6 文档，一个词法环境由<strong>环境记录器</strong>和一个可能为空的<strong>对于外部环境的引用</strong>组成。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">40</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的词法环境为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    b: 40,</span><br><span class="line">    foo: &lt;ref. to foo function&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个词法环境有三个组件：</p>
<ul>
<li>环境记录器</li>
<li>一个对外部环境的引用</li>
<li>this 的绑定</li>
</ul>
<h3 id="环境记录器"><a href="#环境记录器" class="headerlink" title="环境记录器"></a>环境记录器</h3><p>环境记录用于在词法环境中存储变量和函数声明的位置。<br>环境记录器有两种类型：</p>
<ul>
<li>声明式环境记录器：顾名思义，它存储变量和函数声明。<strong>函数代码</strong>的词法环境包含声明性环境记录</li>
<li>对象环境记录器：<strong>全局代码</strong>的词法环境包含一个对象环境记录器。除了变量和函数声明外，对象环境记录器还存储全局对象 window。因此，对于每个绑定对象的属性（对于浏览器，它包含浏览器提供给 window 的属性和方法），将会创建一条新的记录</li>
</ul>
<p>注意：对于函数代码，环境记录器还包含一个 arguments 对象。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// argument object</span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对于外部环境的引用"><a href="#对于外部环境的引用" class="headerlink" title="对于外部环境的引用"></a>对于外部环境的引用</h3><p>对外部环境的引用意味着它可以访问外部的词法环境。这意味着，如果是当前词法环境中找不到的变量，JavaScript 引擎可以在外部环境中查找这些变量。</p>
<h3 id="this-的绑定"><a href="#this-的绑定" class="headerlink" title="this 的绑定"></a>this 的绑定</h3><p>在全局执行上下文中，this 的值引用全局对象。（在浏览器中，这指的是窗口对象）<br>在函数执行上下文中，其值取决于函数的调用方式。如果它由对象的引用调用，则此值将设置为该对象，否则，此值将设置为全局对象或 undefined（严格模式）。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;peter&#x27;</span>,</span><br><span class="line">    <span class="attr">birthYear</span>: <span class="number">1994</span>,</span><br><span class="line">    <span class="attr">calcAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2018</span> - <span class="built_in">this</span>.birthYear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.calcAge(); </span><br><span class="line"><span class="comment">// &#x27;this&#x27; refers to &#x27;person&#x27;, because &#x27;calcAge&#x27; was called with //&#x27;person&#x27; object reference</span></span><br><span class="line"><span class="keyword">const</span> calculateAge = person.calcAge;</span><br><span class="line">calculateAge();</span><br><span class="line"><span class="comment">// &#x27;this&#x27; refers to the global window object, because no object reference was given</span></span><br></pre></td></tr></table></figure>

<p>词法环境大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">                // Identifier bindings go here</span><br><span class="line">            &#125;</span><br><span class="line">            outer: &lt;null&gt;,</span><br><span class="line">            this: &lt;global object&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FunctionExectionContext = &#123;</span><br><span class="line">        LexicalEnvironment: &#123;</span><br><span class="line">            EnvironmentRecord: &#123;</span><br><span class="line">                Type: &quot;Declarative&quot;,</span><br><span class="line">                // Identifier bindings go here</span><br><span class="line">            &#125;</span><br><span class="line">            outer: &lt;Global or outer function environment reference&gt;,</span><br><span class="line">            this: &lt;depends on how function is called&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h2><p><strong>它也是一个词法环境</strong>，其环境记录器保存在此执行上下文中由 VariableStatements 创建的绑定。<br>因为变量环境也是一个词法环境，所以它具有上面定义的词法环境的所有属性和组件。<br>在 ES6 中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量（let 和 const）绑定，而后者仅用于存储变量（var）绑定。</p>
<h1 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h1><p>在这个阶段，所有的变量赋值都完成了，代码最终会被执行。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>当上面的代码被执行时，Javascript 引擎会创建一个全局执行上下文来执行全局代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            a: &lt; uninitialized &gt;,</span><br><span class="line">            b: &lt; uninitialized &gt;,</span><br><span class="line">            multiply: &lt; func &gt;</span><br><span class="line">        &#125;</span><br><span class="line">        outer: &lt;null&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            c: undefined,</span><br><span class="line">        &#125;</span><br><span class="line">        outer: &lt;null&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数 <code>multiply(20, 30)</code> 被调用时，一个新的函数执行上下文会被创建来执行函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            g: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此后，执行上下文将经历执行阶段，也就是要完成对函数内变量的赋值。（此处指对变量 g 的赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            g: 20</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数执行完成后，返回值会被存储在变量 c 之中。所以全局的词法环境会被更新。最终，全局的代码被执行完成，程序也运行完成。</p>
<p>注意：你也许注意到了，let 和 const 定义的变量在创建阶段没有任何赋值操作，但是 var 定义的变量被赋值为了 undefined。这也就解释了为什么当你想获取已声明但未定义的变量时，var 声明的变量会得到 undefined，而 let 声明的变量会显示 undeclared。这也就是我们所谓的变量提升。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，我们讨论了 JavaScript 程序内部的执行机制。虽然学习这些概念并不是成为一名出色的 JavaScript 开发人员的必要条件，但对上述概念有一个良好的理解将有助于您更轻松、更深入地理解其他概念，如变量提升、作用域和闭包。</p>
<p>原文：<br><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>js 常见知识清单</title>
    <url>/2022/01/06/js-knowledge-list/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>见 <a href="https://flower-f.github.io/2021/12/11/js-data-types/">js 数据类型</a></p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>相关知识：词法环境、调用栈<br>见 <a href="https://flower-f.github.io/2022/01/06/execution-context/">js 执行上下文详解（译）</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>相关知识：词法作用域、执行上下文、词法环境<br>见 <a href="https://flower-f.github.io/2022/01/06/closure/">js 闭包详解（译）</a></p>
<h1 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h1><p>相关知识：词法环境<br>见 <a href="https://flower-f.github.io/2022/01/10/js-scope-and-scope-chain/">js 作用域和作用域链详解（译）</a></p>
<h1 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h1><p>见 <a href="https://flower-f.github.io/2021/12/13/js-traversal/">js 遍历对象</a></p>
<h1 id="var-amp-const-amp-let"><a href="#var-amp-const-amp-let" class="headerlink" title="var &amp; const &amp; let"></a>var &amp; const &amp; let</h1><p>见 <a href="https://flower-f.github.io/2021/12/11/var-let-const/">var、let、const 辨析</a></p>
<h1 id="bind-amp-apply-amp-call"><a href="#bind-amp-apply-amp-call" class="headerlink" title="bind &amp; apply &amp; call"></a>bind &amp; apply &amp; call</h1><p>见 <a href="https://flower-f.github.io/2022/01/10/call-apply-bind">call、apply、bind辨析（译）</a> &amp; <a href="https://flower-f.github.io/2022/01/10/hand-write-apply-call-bind/">手写实现 call、apply、bind</a></p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>见 <a href="https://flower-f.github.io/2022/01/10/js-promise/">Promise 详解（译）</a> &amp; <a href="https://flower-f.github.io/2022/01/11/hand-write-promise/">手写 Promise</a></p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>见 <a href="https://flower-f.github.io/2021/12/10/instanceof/">instanceof 详解</a></p>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/new/">new 详解</a></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/js-inherit/">js 继承</a></p>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/js-event/">js 事件机制</a></p>
<h1 id="异步工作原理"><a href="#异步工作原理" class="headerlink" title="异步工作原理"></a>异步工作原理</h1><p>相关知识：执行上下文、词法环境、事件循环<br>见 <a href="https://flower-f.github.io/2022/01/10/js-asynchronous/">js 异步原理详解（译）</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构复习提纲</title>
    <url>/2022/01/02/software-artifact-review/</url>
    <content><![CDATA[<h1 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h1><p>软件架构是一组用于推理系统的结构，包含了软件元素、它们之间的关系以及他们的属性</p>
<h1 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h1><ul>
<li>架构影响系统的<strong>驱动质量属性</strong></li>
<li>可以帮助开发者随着系统发展而<strong>推理和管理变更</strong></li>
<li>可以实现对系统质量的<strong>早期预测</strong></li>
<li>架构促进<strong>利益相关者间的沟通</strong></li>
<li>架构是最早产生的设计决策的载体，所以它也是最基础的、最难以改变的<strong>设计决策的载体</strong></li>
<li>架构为后续的实现定义了一系列的<strong>约束</strong></li>
<li>架构决定了<strong>组织结构</strong>，反之亦然</li>
<li>架构提供了<strong>进化原型</strong>的基础</li>
<li>架构可以帮助架构师和项目经理<strong>预估成本和时间</strong></li>
<li>基于架构的开发<strong>关注组件之间的组合</strong>，而不是简单地关注它们的创建</li>
<li>架构可以被设计成一个可转换、可复用的模型，构成<strong>产品线的心脏</strong></li>
<li>通过<strong>限制设计的自由度</strong>，架构引导开发者的创造方向，以减少设计和系统的复杂度</li>
<li>架构可以作为<strong>培训团队新成员</strong>的基础</li>
</ul>
<h1 id="视图、架构和结构的区别与联系"><a href="#视图、架构和结构的区别与联系" class="headerlink" title="视图、架构和结构的区别与联系"></a>视图、架构和结构的区别与联系</h1><ul>
<li>视图是一组耦合的架构元素的<strong>展示</strong>，它由一组元素和元素间的关系组成</li>
<li>结构是元素<strong>集合本身</strong></li>
<li>架构设计结构，<strong>架构将结构的视图文档化</strong></li>
</ul>
<h1 id="三类结构"><a href="#三类结构" class="headerlink" title="三类结构"></a>三类结构</h1><h2 id="三类结构回答的问题"><a href="#三类结构回答的问题" class="headerlink" title="三类结构回答的问题"></a>三类结构回答的问题</h2><h3 id="Module-structures"><a href="#Module-structures" class="headerlink" title="Module structures"></a>Module structures</h3><ul>
<li>What is the primary responsibilities assigned to each module? </li>
<li>What other software elements is a module allowed to use? </li>
<li>What other software does it actually use and depend on?</li>
<li>What modules are related to other modules by generalization or specialization relationships? </li>
</ul>
<h3 id="Component-and-connector-structures-回答的问题"><a href="#Component-and-connector-structures-回答的问题" class="headerlink" title="Component-and-connector structures 回答的问题"></a>Component-and-connector structures 回答的问题</h3><ul>
<li>What are the major executing components and how do they interact at runtime? </li>
<li>What are the major shared data stores?</li>
<li>Which parts of the system are replicated? </li>
<li>How does data progress through the system?</li>
<li>What parts of the system can run in parallel?</li>
<li>Can the system’s structure change as it executes and, if so, how?</li>
</ul>
<h3 id="Allocation-structures-回答的问题"><a href="#Allocation-structures-回答的问题" class="headerlink" title="Allocation structures 回答的问题"></a>Allocation structures 回答的问题</h3><ul>
<li>What processor does each software element execute on?</li>
<li>In what directories or files is each element stored during development, testing, and system building?</li>
<li>What is the assignment of each software element to development teams?</li>
</ul>
<h2 id="Module-structures-模块结构"><a href="#Module-structures-模块结构" class="headerlink" title="Module structures 模块结构"></a>Module structures 模块结构</h2><ul>
<li>Decomposition structure 分解结构：决定了系统的<strong>可修改性</strong>，以确保可能的变化是局部的</li>
<li>Uses structure 使用结构：是一种专门的依赖关系，用来<strong>拓展或缩小系统</strong>，创建子系统</li>
<li>Layered structure 层结构：通过<strong>接口</strong>提供一个有凝聚力的服务集合</li>
<li>Class structure 类结构：允许<strong>重载</strong>功能</li>
<li>Data model 数据模型：描述了数据实体及其关系的信息结构</li>
</ul>
<h2 id="Component-connector-structures-组件连接件结构"><a href="#Component-connector-structures-组件连接件结构" class="headerlink" title="Component-connector structures 组件连接件结构"></a>Component-connector structures 组件连接件结构</h2><ul>
<li>Service structure 服务结构：单位服务与其他服务的协调机制</li>
<li>Concurrency structure 并发结构：确定机会的并行性和资源争夺可能发生的位置</li>
</ul>
<h2 id="Allocation-structures-分配结构"><a href="#Allocation-structures-分配结构" class="headerlink" title="Allocation structures 分配结构"></a>Allocation structures 分配结构</h2><ul>
<li>Deployment structure 部署结构：软件如何被分配给硬件处理和通信，如分布式和并行系统</li>
<li>Implementation structure 实现结构：显示了软件元素如何在系统的开发、集成和配置控制环境中映射到文件结构中</li>
<li>Work assignment structure 工作分配结构：分配责任，实施和整合模块给将要执行它的团队</li>
</ul>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="架构模式的作用"><a href="#架构模式的作用" class="headerlink" title="架构模式的作用"></a>架构模式的作用</h2><ul>
<li>架构模式描述了软件系统里的基本的<strong>结构</strong></li>
<li>架构模式提供一些<strong>预先定义好的子系统</strong>，指定它们的责任，并给出把它们组织在一起的方法</li>
<li><strong>架构模式建立了背景（context）、问题（problem）和解决方案（solution）间的关系</strong></li>
</ul>
<h2 id="常见的架构模式"><a href="#常见的架构模式" class="headerlink" title="常见的架构模式"></a>常见的架构模式</h2><ul>
<li>分层模式 layered pattern</li>
<li>数据共享模式 shared-data pattern</li>
<li>C/S 模式 client-server pattern</li>
<li>多层模式 multi-tier pattern</li>
<li>能力中心和平台 competence center and platform</li>
</ul>
<h2 id="架构的四大背景"><a href="#架构的四大背景" class="headerlink" title="架构的四大背景"></a>架构的四大背景</h2><ul>
<li>技术 technical</li>
<li>项目生命周期  project life cycle</li>
<li>业务 business</li>
<li>专业性 professional</li>
</ul>
<h2 id="什么会影响架构"><a href="#什么会影响架构" class="headerlink" title="什么会影响架构"></a>什么会影响架构</h2><ul>
<li>需求</li>
<li>架构的四大背景</li>
<li>架构本身会影响未来的架构</li>
</ul>
<h2 id="战术-Tactics-与模式-Patterns-的区别"><a href="#战术-Tactics-与模式-Patterns-的区别" class="headerlink" title="战术 Tactics 与模式 Patterns 的区别"></a>战术 Tactics 与模式 Patterns 的区别</h2><ul>
<li>模式建立在战术之上，一个模式包含很多战术</li>
<li>模式用于解决一个特定问题，但是同时会给其他质量属性带来负面影响</li>
</ul>
<h2 id="模块框架-Module-Pattern"><a href="#模块框架-Module-Pattern" class="headerlink" title="模块框架 Module Pattern"></a>模块框架 Module Pattern</h2><h3 id="Layered-pattern-分层模式"><a href="#Layered-pattern-分层模式" class="headerlink" title="Layered pattern 分层模式"></a>Layered pattern 分层模式</h3><ul>
<li>context：关系的<strong>分离</strong></li>
<li>problem：软件在某些情况下需要分离，模块可以单独开发，提高可移植性、可修改性、重用性</li>
<li>solution：分层模式定义了层（每个层是一组模块），和层与层之间<strong>单向调用</strong>的关系，下一层只能使用上一层提供的服务</li>
</ul>
<h2 id="组件-连接件框架-Component-Connector-Pattern"><a href="#组件-连接件框架-Component-Connector-Pattern" class="headerlink" title="组件-连接件框架 Component-Connector Pattern"></a>组件-连接件框架 Component-Connector Pattern</h2><h3 id="Broker-pattern-代理模式"><a href="#Broker-pattern-代理模式" class="headerlink" title="Broker pattern 代理模式"></a>Broker pattern 代理模式</h3><ul>
<li>context：<strong>分布式</strong>服务之间的交互操作</li>
<li>problem：如何构造分布式软件，使用户不需要知道供应商的性质和位置，就可以容易地动态改变用户和供应商之间的绑定</li>
<li>solution：代理模式插入一个称为代理的中介，将服务提供者（服务器）和用户（客户端）分开</li>
</ul>
<h3 id="Model-View-Controller-Pattern-MVC-模式"><a href="#Model-View-Controller-Pattern-MVC-模式" class="headerlink" title="Model-View-Controller Pattern MVC 模式"></a>Model-View-Controller Pattern MVC 模式</h3><ul>
<li>context：从模型分离视图</li>
<li>problem：如何将用户<strong>界面的功能与应用程序的功能分开</strong>，但是仍然可以响应用户的输入，或者改变应用程序数据。当应用数据改变时，如何创建、维护和协调用户界面的多个视图</li>
<li>solution：MVC 模式把应用功能分成三种类型的组件</li>
</ul>
<h3 id="Pipe-and-Filter-Pattern-管道-过滤器模式"><a href="#Pipe-and-Filter-Pattern-管道-过滤器模式" class="headerlink" title="Pipe and Filter Pattern 管道-过滤器模式"></a>Pipe and Filter Pattern 管道-过滤器模式</h3><ul>
<li>context：处理<strong>数据流</strong></li>
<li>problem：一些系统可能被分解为可重用的、松散耦合的组件，这些组件具有简单通用的交互机制</li>
<li>solution：管道和过滤器模式特征就是数据流连续变换</li>
</ul>
<h3 id="Client-Server-Pattern-C-S-模式"><a href="#Client-Server-Pattern-C-S-模式" class="headerlink" title="Client-Server Pattern C/S 模式"></a>Client-Server Pattern C/S 模式</h3><ul>
<li>context：大量的分布式客户希望访问<strong>共享的资源和服务</strong></li>
<li>problem：我们希望通过集中控制资源和服务来提高可扩展性和可用性，同时在多台物理服务器上分配资源</li>
<li>solution：客户端通过请求服务器的服务进行交互，服务器提供一系列的服务</li>
</ul>
<h3 id="Peer-to-Peer-Pattern-P2P-模式"><a href="#Peer-to-Peer-Pattern-P2P-模式" class="headerlink" title="Peer-to-Peer Pattern P2P 模式"></a>Peer-to-Peer Pattern P2P 模式</h3><ul>
<li>context：分布式计算实体被认为是<strong>平等的</strong></li>
<li>problem：如何将一组平等的分布式计算实体通过公共协议相互连接，使得他们能够以高可用性和可扩展性的组织和共享服务</li>
<li>solution：在 P2P 模式中，组件直接作为对等点进行交互，所有的对等点都是平等的，没有对等点对系统的健康来说是至关重要的</li>
</ul>
<h3 id="Service-Oriented-Architecture-Pattern-面向服务的架构模式（SOA）"><a href="#Service-Oriented-Architecture-Pattern-面向服务的架构模式（SOA）" class="headerlink" title="Service Oriented Architecture Pattern 面向服务的架构模式（SOA）"></a>Service Oriented Architecture Pattern 面向服务的架构模式（SOA）</h3><ul>
<li>context：许多<strong>服务需要进行互操作</strong>，但是开发者对它们的内部实现没有任何了解</li>
<li>problem：如何保证在不同的平台上、由不同的语言实现、由不同的组织提供的分布式系统的互操作性</li>
<li>solution：SOA 模式描述了一个提供或使用服务的分布式组件的集合</li>
</ul>
<h3 id="Publish-Subscribe-Pattern-发布-订阅模式"><a href="#Publish-Subscribe-Pattern-发布-订阅模式" class="headerlink" title="Publish-Subscribe Pattern 发布-订阅模式"></a>Publish-Subscribe Pattern 发布-订阅模式</h3><ul>
<li>context：<strong>数据生产者和消费者的确切数量和性质不是预定的或固定的，他们也不共享数据</strong></li>
<li>problem：我们如何创建集成机制，支持在生产者和消费者之间传递信息的能力，使得他们不知道彼此的身份甚至不知道彼此的存在</li>
<li>solution：在发布订阅模式中，组件通过已发布的消息进行交互</li>
</ul>
<h3 id="Shared-Data-Pattern-共享数据模式"><a href="#Shared-Data-Pattern-共享数据模式" class="headerlink" title="Shared-Data Pattern 共享数据模式"></a>Shared-Data Pattern 共享数据模式</h3><ul>
<li>context：各种组件之间需要<strong>共享和操作大量的数据</strong></li>
<li>problem：系统如何存储和操作数据，并保证可以被多个独立的组件访问</li>
<li>solution：数据共享模式中，交互主要通过在多个数据存取器和至少一个共享数据存储之间持续的数据交换进行</li>
</ul>
<h2 id="分配框架-Allocation-Pattern"><a href="#分配框架-Allocation-Pattern" class="headerlink" title="分配框架 Allocation Pattern"></a>分配框架 Allocation Pattern</h2><h3 id="Map-Reduce-Pattern-映射-规约模式"><a href="#Map-Reduce-Pattern-映射-规约模式" class="headerlink" title="Map-Reduce Pattern 映射-规约模式"></a>Map-Reduce Pattern 映射-规约模式</h3><ul>
<li>context：需要<strong>快速分析大量数据</strong></li>
<li>problem：有效地执行大型数据集的分布式并行排序，为程序员指定的分析提供一种简单的方法</li>
<li>problem：map-reduce 模式需要三个部分：一个负责根据需要<strong>分配数据</strong>的基础设施、一个用于<strong>过滤数据</strong>以检索项目的 map、一个<strong>结合映射结果</strong>的 reduce</li>
</ul>
<h3 id="Multi-Tier-Pattern-多层模式"><a href="#Multi-Tier-Pattern-多层模式" class="headerlink" title="Multi-Tier Pattern 多层模式"></a>Multi-Tier Pattern 多层模式</h3><ul>
<li>context：将一个系统的<strong>基础设施分配到不同的子集</strong></li>
<li>problem：如何将系统划分为多个独立计算的执行结构</li>
<li>solution：许多系统的执行结构被组织为一系列组件的逻辑分组，每个组被称为一级</li>
</ul>
<h1 id="七个质量属性场景"><a href="#七个质量属性场景" class="headerlink" title="七个质量属性场景"></a>七个质量属性场景</h1><h2 id="质量属性场景的组成"><a href="#质量属性场景的组成" class="headerlink" title="质量属性场景的组成"></a>质量属性场景的组成</h2><ul>
<li>Source：刺激源，产生刺激的实体，如人、系统等</li>
<li>Stimulus：刺激，系统做出响应的条件</li>
<li>Response：响应，系统在被刺激时采取的行动</li>
<li>Response measure：响应度量，当响应发生时，以某种标准量化该响应</li>
<li>Environment：环境，刺激发生的特定条件</li>
<li>Artifact：制品，可以理解为研究的对象</li>
</ul>
<h2 id="Availability-可达性"><a href="#Availability-可达性" class="headerlink" title="Availability 可达性"></a>Availability 可达性</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>系统<strong>掩盖或修复错误</strong>的能力，使得一定时间内系统的不可用时间小于特定值</p>
<h3 id="general-scenario"><a href="#general-scenario" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：系统内部、系统外部</li>
<li>Stimulus：错误，如疏忽、崩溃、响应错误</li>
<li>Artifact：处理器、进程</li>
<li>Environment：正常操作、降级操作（使用更少的特性）</li>
<li>Response：记录故障；通知用户或系统；根据规则禁止导致错误的源头</li>
<li>Response measure：系统修复时间、系统可用的时间间隔、系统在降级模式下可用的时间间隔</li>
</ul>
<h3 id="concrete-scenario"><a href="#concrete-scenario" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Heartbeat monitor 心跳监控器</li>
<li>Stimulus：Server unresponsive 服务器无响应</li>
<li>Artifact：Process 进程</li>
<li>Environment：Normal operation 正常操作</li>
<li>Response：Inform operator continue to operate 通知操作者继续操作</li>
<li>Response Measure：No downtime 没有停机时间</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>The heartbeat monitor determines that the server is nonresponsive during normal operations. The system informs the operator and continues to operate with no downtime<br>心跳监视器确定服务器在正常操作期间无响应。系统通知操作员继续操作，并在<strong>无停机</strong>的情况下继续运行</p>
<h3 id="战术"><a href="#战术" class="headerlink" title="战术"></a>战术</h3><ul>
<li>检测错误：ping/echo，monitor，timestamp，sanity checking，condition monitoring，voting，self-test，heartbeat</li>
<li>修复错误：主动冗余、被动冗余、备份、回滚、阴影、状态重新同步</li>
<li>防止错误：事务、预测模型、增加能力集</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/150753.jpg"></p>
<h2 id="Interoperability-互操作性"><a href="#Interoperability-互操作性" class="headerlink" title="Interoperability 互操作性"></a>Interoperability 互操作性</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>两个或以上的系统，在一定的背景下，可以通过<strong>接口</strong>有用地交换有意义的信息</p>
<h3 id="general-scenario-1"><a href="#general-scenario-1" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：向另一个系统提出互操作请求的系统</li>
<li>Stimulus：系统之间交换信息的请求</li>
<li>Artifact：互操作的系统</li>
<li>Environment：互操作的系统在运行前就知道对方的存在</li>
<li>Response：互操作引发信息交换</li>
<li>Response measure：被正确处理的信息交换百分比</li>
</ul>
<h3 id="concrete-scenario-1"><a href="#concrete-scenario-1" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Vehicle information system 交通信息系统</li>
<li>Stimulus：Current location sent 发送当前位置</li>
<li>Artifact：Traffic monitoring system 交通监控系统</li>
<li>Environment：Systems known prior to run-time 交通信息系统在运行之前就已经知道交通监控系统的存在</li>
<li>Response：Traffic monitor combines current location with other information, overlays on google maps, and broadcasts 交通监控器将当前位置与其他信息、谷歌地图上的覆盖和广播结合起来</li>
<li>Response Measure：Our information included correctly 99.9% of the time 在规定时间内信息被正确处理的百分比达到 99.9%</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>Our vehicle information system sends our current location to the traffic monitoring system. The traffic monitoring system combines our location with other information, overlays this information on a Google Map, and broadcasts it. Our location information is correctly included with a probability of 99.9%<br>交通信息系统发送当前的地址信息给交通监控系统，交通监控系统需要将我们的位置信息和其他信息组合起来，映射到谷歌地图上，并发布结果。我们的位置信息被正确包含的概率将为 99.9%</p>
<h3 id="战术-1"><a href="#战术-1" class="headerlink" title="战术"></a>战术</h3><ul>
<li>定位：发现服务</li>
<li>管理接口：协调接口、定制接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/151506.jpg"></p>
<h2 id="Modifiability-可修改性"><a href="#Modifiability-可修改性" class="headerlink" title="Modifiability 可修改性"></a>Modifiability 可修改性</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>在一定时限内，软件能被无副作用修改的难易程度</p>
<h3 id="general-scenario-2"><a href="#general-scenario-2" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：开发人员</li>
<li>Stimulus：希望增加、删除、修改功能</li>
<li>Artifact：用户界面、系统</li>
<li>Environment：在设计时、构建时、编译时、运行时</li>
<li>Response：查找需要修改的位置；进行修改而不影响其他功能</li>
<li>Response measure：该修改需要的成本与时间、该修改对其它功能的影响</li>
</ul>
<h3 id="concrete-scenario-2"><a href="#concrete-scenario-2" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Developer 开发者</li>
<li>Stimulus：Wishes to change the UI 想要改变 UI</li>
<li>Artifact：Code 代码</li>
<li>Environment：Design time 设计的时候</li>
<li>Response：Change made and unit tested 所做的更改和单元测试</li>
<li>Response Measure：In three hours with no side effects 三小时内完成，且没有副作用</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>The developer wishes to change the user interface by modifying the code at design time. The modifications are made with no side effects within three hours<br>如果开发人员在设计时希望修改代码来更改用户接口，修改可以确保在三小时内完成更改以及单元测试，而且没有副作用</p>
<h3 id="战术-2"><a href="#战术-2" class="headerlink" title="战术"></a>战术</h3><ul>
<li>修改模块大小：拆分模块</li>
<li>增加内聚：增强语义的一致性</li>
<li>降低耦合：封装、使用中间件</li>
<li>延迟绑定</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152201.jpg"></p>
<h2 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance 性能"></a>Performance 性能</h2><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>软件系统满足时间需求的能力</p>
<h3 id="general-scenario-3"><a href="#general-scenario-3" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：系统内部或外部</li>
<li>Stimulus：定期事件到达；随机事件到达；偶然事件到达</li>
<li>Artifact：<strong>系统</strong></li>
<li>Environment：正常模式、超载模式</li>
<li>Response：处理事件；改变服务的级别（如从正常模式切换到超载模式）</li>
<li>Response measure：等待时间、吞吐率</li>
</ul>
<h3 id="concrete-scenario-3"><a href="#concrete-scenario-3" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Users 用户</li>
<li>Stimulus：Initiate transactions 启动交易</li>
<li>Artifact：System 系统</li>
<li>Environment：Normal operation 正常模式</li>
<li>Response：Transactions are processed 交易被处理</li>
<li>Response Measure：Average latency of two seconds 平均等待时间为 2 秒</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>Users initiate transactions under normal operations. The system processes the transactions with an average latency of two seconds<br>用户在正常操作下启动会话。系统处理事件的平均延迟为 2 秒</p>
<h3 id="战术-3"><a href="#战术-3" class="headerlink" title="战术"></a>战术</h3><ul>
<li>控制资源需求：管理采样率、限制事件响应、为事件划分优先级</li>
<li>管理资源：引入并发、维护多个数据副本、维护多个计算副本、限制任务队列的大小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152231.jpg"></p>
<h2 id="Security-安全性"><a href="#Security-安全性" class="headerlink" title="Security 安全性"></a>Security 安全性</h2><h3 id="含义-4"><a href="#含义-4" class="headerlink" title="含义"></a>含义</h3><p>系统保护数据免受未授权访问和能够被授权访问的能力</p>
<h3 id="general-scenario-4"><a href="#general-scenario-4" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：授权或非授权用户、访问了有限资源或大量资源</li>
<li>Stimulus：尝试修改数据、尝试访问系统服务</li>
<li>Artifact：系统服务、系统数据</li>
<li>Environment：在线或离线、联网或断网</li>
<li>Response：对用户进行身份验证，允许或阻止用户访问数据或服务</li>
<li>Response measure：防范成功的概率</li>
</ul>
<h3 id="concrete-scenario-4"><a href="#concrete-scenario-4" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Disgruntled employee from remote location 来自远程位置的不满员工</li>
<li>Stimulus：Attempts to modify pay rate 试图修改工资比率</li>
<li>Artifact：Data within the system 系统内的数据</li>
<li>Environment：Normal operations 正常操作</li>
<li>Response：System maintains audit trails 系统维护审计跟踪</li>
<li>Response Measure：Correct data is restored within a day and source of tampering identified 在一天内恢复正确的数据，并确定篡改源</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>A disgruntled employee from a remote location attempts to modify the pay rate table during normal operations. The system maintains an audit trail and the correct data is restored within a day<br>一个对工资不满的员工试图在正常操作期间远程修改工资率表。系统将保留审核跟踪，并在一天内恢复正确的数据，确定想做坏事的人是谁</p>
<h3 id="战术-4"><a href="#战术-4" class="headerlink" title="战术"></a>战术</h3><ul>
<li>检测攻击：确认消息的完整性、检测消息的延迟</li>
<li>抵抗攻击：识别参与者、验证参与者、授权参与者、数据加密、限制访问</li>
<li>对攻击做出反应：撤销访问、锁定计算机、通知参与者</li>
<li>从攻击中恢复：维护审计追踪、重新存储</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152600.jpg"></p>
<h2 id="Testability-可测试性"><a href="#Testability-可测试性" class="headerlink" title="Testability 可测试性"></a>Testability 可测试性</h2><h3 id="含义-5"><a href="#含义-5" class="headerlink" title="含义"></a>含义</h3><p>软件可以被证明有错误的容易程度</p>
<h3 id="general-scenario-5"><a href="#general-scenario-5" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：单元测试人员、集成测试人员</li>
<li>Stimulus：完成了一段功能完整的代码，如类、层</li>
<li>Artifact：代码片段、完整应用</li>
<li>Environment：设计时、开发时、编译时、部署时</li>
<li>Response：准备测试的环境、执行测试并捕获结果</li>
<li>Response measure：准备测试的时间、执行测试的时间、测试的覆盖率</li>
</ul>
<h3 id="concrete-scenario-5"><a href="#concrete-scenario-5" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：Unit tester 单元测试人员</li>
<li>Stimulus：Code unit completed 一个代码单元被完成</li>
<li>Artifact：Code unit 一个代码单元</li>
<li>Environment：Development 开发时</li>
<li>Response：Results Captured 捕获测试结果</li>
<li>Response Measure：85% Path Converge in 3 hours 三小时内达到 85% 的路径覆盖率</li>
</ul>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>The unit tester completes a code unit during development and performs a test sequence whose results are captured and that gives 85% path coverage within 3 hours of testing<br>单元测试人员在开发过程中完成一个代码单元，并执行一个测试序列，该序列的结果被捕获，并在测试的 3 小时内提供 85% 的路径覆盖率</p>
<h3 id="战术-5"><a href="#战术-5" class="headerlink" title="战术"></a>战术</h3><ul>
<li>控制和观察系统状态：接口专用化、本地化状态存储、沙盒</li>
<li>限制复杂度：控制结构的复杂度、限制非确定性因素</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/153122.jpg"></p>
<h2 id="Usability-易用性"><a href="#Usability-易用性" class="headerlink" title="Usability 易用性"></a>Usability 易用性</h2><h3 id="含义-6"><a href="#含义-6" class="headerlink" title="含义"></a>含义</h3><p>指用户完成一项任务的容易程度和系统所提供用户支持的种类</p>
<h3 id="general-scenario-6"><a href="#general-scenario-6" class="headerlink" title="general scenario"></a>general scenario</h3><ul>
<li>Source：<strong>最终用户</strong></li>
<li>Stimulus：学习系统特性、学会有效使用系统</li>
<li>Artifact：<strong>系统</strong></li>
<li>Environment：运行时、配置时</li>
<li>Response：上下文相关的帮助系统；撤销操作；取消操作</li>
<li>Response measure：用户学习时间、用户满意度、用户的操作成功率</li>
</ul>
<h3 id="concrete-scenario-6"><a href="#concrete-scenario-6" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul>
<li>Source：User 用户</li>
<li>Stimulus：Downloads a new application 下载一个新的 App</li>
<li>Artifact：System 系统</li>
<li>Environment：Runtime 运行时</li>
<li>Response：User uses application productively 用户高效地使用应用程序</li>
<li>Response Measure：Within two miniutes of experimentation 在两分钟的试用时间内</li>
</ul>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>The user downloads a new application and is using it productively after two minutes of experimentation<br>用户下载一个新的应用程序，并在两分钟的试用后就能有效地使用它</p>
<h3 id="战术-6"><a href="#战术-6" class="headerlink" title="战术"></a>战术</h3><ul>
<li>支持用户的方案：取消、撤销、暂停/恢复</li>
<li>支持系统的方案：维护任务模型、用户模型、系统模型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/153806.jpg"></p>
<h2 id="X-ability-X-质量属性"><a href="#X-ability-X-质量属性" class="headerlink" title="X-ability X 质量属性"></a>X-ability X 质量属性</h2><h3 id="含义-7"><a href="#含义-7" class="headerlink" title="含义"></a>含义</h3><p>指未列出的的质量属性，如 variability 变异性、 portability 可移植性、scalability 可扩展性、elasticity 弹性、deployability 可部署性、mobility 可移动性、monitorability 可监测性等</p>
<h1 id="通用质量属性表格"><a href="#通用质量属性表格" class="headerlink" title="通用质量属性表格"></a>通用质量属性表格</h1><table>
<thead>
<tr>
<th align="center"></th>
<th>avalibility</th>
<th>testability</th>
<th>usability</th>
<th>security</th>
<th>performance</th>
<th>modifiability</th>
</tr>
</thead>
<tbody><tr>
<td align="center">source</td>
<td>系统内部或外部</td>
<td>单元测试人员、集成测试人员</td>
<td>用户</td>
<td>授权或非授权用户、访问了有限资源或大量资源</td>
<td>系统内部或外部</td>
<td>开发人员</td>
</tr>
<tr>
<td align="center">stimulus</td>
<td>错误，如疏忽、崩溃、响应错误</td>
<td>完成了一段功能完整的代码，如类、层；完成了整个应用</td>
<td>学习系统特性、学会有效使用系统</td>
<td>尝试修改数据、尝试访问系统服务</td>
<td>定期事件到达、随机事件到达、偶然事件到达</td>
<td>增加、删除、修改功能</td>
</tr>
<tr>
<td align="center">artifact</td>
<td>处理器、进程</td>
<td>代码片段、完整应用</td>
<td>系统</td>
<td>系统服务、系统数据</td>
<td>系统</td>
<td>用户界面、系统</td>
</tr>
<tr>
<td align="center">environment</td>
<td>正常操作、降级操作</td>
<td>设计时、开发时、编译时、部署时</td>
<td>运行时</td>
<td>在线或离线、联网或断网</td>
<td>正常模式 、超载模式</td>
<td>设计时、构建时、编译时、运行时</td>
</tr>
<tr>
<td align="center">response</td>
<td>记录故障；通知用户或系统；禁止错误的数据源</td>
<td>准备测试环境、执行测试并捕获结果</td>
<td>上下文帮助系统、撤销操作、取消操作</td>
<td>对用户进行身份验证、允许或拒绝用户访问数据或服务</td>
<td>处理事件、改变服务的级别</td>
<td>查找需要修改的位置、对内容进行修改</td>
</tr>
<tr>
<td align="center">response measure</td>
<td>系统修复时间、系统可用时间间隔、系统在降级模式下的可用时间间隔</td>
<td>准备测试的时间、执行测试的时间、测试的覆盖率</td>
<td>用户学习时间、用户满意度、用户的操作成功率</td>
<td>防范成功的比例</td>
<td>等待时间、吞吐率</td>
<td>修改需要的成本、修改对其它功能的影响</td>
</tr>
</tbody></table>
<h1 id="质量属性的建模与分析"><a href="#质量属性的建模与分析" class="headerlink" title="质量属性的建模与分析"></a>质量属性的建模与分析</h1><h2 id="Performance-Modeling-性能建模"><a href="#Performance-Modeling-性能建模" class="headerlink" title="Performance Modeling 性能建模"></a>Performance Modeling 性能建模</h2><ul>
<li>成本：取决于建模参数，如<ul>
<li>The frequency of arrivals from outside the system</li>
<li>The queuing discipline used at the view queue</li>
<li>The time to process a message within the view</li>
<li>The number and size of messages that the view sends to the controller</li>
<li>The bandwidth of the network that connects the view and the controller</li>
</ul>
</li>
<li>作用：估计延迟时间</li>
<li>对参数的估计越准确，对延迟的预测就越准确</li>
<li>当延迟很重要和有问题时，这是值得的；当显然有足够的能力来满足需求时，这是不值得的</li>
</ul>
<h2 id="Availability-Modeling-可达性建模"><a href="#Availability-Modeling-可达性建模" class="headerlink" title="Availability Modeling 可达性建模"></a>Availability Modeling 可达性建模</h2><ul>
<li>可达性建模是为了确定组件的<strong>故障率和恢复时间</strong></li>
<li>Steady-State Availability（实则为平均故障时间占比） 计算公式：<img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/171212.jpg"><ul>
<li>MTBF is the mean time between failure 平均故障时间</li>
<li>MTTR refers to the mean time to repair 平均修复时间</li>
</ul>
</li>
<li>三种提高可达性的主流战术<ul>
<li>主动冗余（热备份）</li>
<li>被动冗余（暖备份）</li>
<li>备份（冷备份）</li>
</ul>
</li>
</ul>
<h1 id="Architecture-in-agile-project-敏捷项目的架构"><a href="#Architecture-in-agile-project-敏捷项目的架构" class="headerlink" title="Architecture in agile project 敏捷项目的架构"></a>Architecture in agile project 敏捷项目的架构</h1><h2 id="什么时候需要敏捷开发"><a href="#什么时候需要敏捷开发" class="headerlink" title="什么时候需要敏捷开发"></a>什么时候需要敏捷开发</h2><ul>
<li>对涉众更加敏感</li>
<li>想要更快地开发用户关注的功能</li>
<li>想在项目生命周期中更多更早地显示项目进展</li>
</ul>
<h2 id="敏捷项目架构关注的问题"><a href="#敏捷项目架构关注的问题" class="headerlink" title="敏捷项目架构关注的问题"></a>敏捷项目架构关注的问题</h2><ul>
<li>应该做多少架构</li>
<li>应该记录多少架构</li>
</ul>
<h2 id="Sweet-Point-甜蜜点"><a href="#Sweet-Point-甜蜜点" class="headerlink" title="Sweet Point 甜蜜点"></a>Sweet Point 甜蜜点</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/174324.jpg"></p>
<ul>
<li>对于 10KSLOC（代码行数）项目，甜蜜点在最左边。 花费大量时间进行前期工作对于一个小型项目来说是一种浪费</li>
<li>对于 100KSLOC 项目，甜蜜点约为项目进度的20％</li>
<li>对于 10,000KSLOC 项目，甜蜜点约为项目进度的40%</li>
<li>结论：<ul>
<li>如果是相对稳定的、易于理解需求的、分布式开发的大型复杂系统，需要大量架构工作</li>
<li>对于需求不稳定的大型项目，从快速设计候选架构开始，即使它省略了许多细节</li>
<li>对于不确定需求的小型项目，至少在采用的主要模式上需要达成一致意见，不要花费太多时间在架构设计、文档或分析</li>
</ul>
</li>
</ul>
<h1 id="ASR-架构关键需求"><a href="#ASR-架构关键需求" class="headerlink" title="ASR 架构关键需求"></a>ASR 架构关键需求</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>对架构有深远影响</li>
<li>具有很高的业务价值</li>
</ul>
<h2 id="收集-ASR-的方法"><a href="#收集-ASR-的方法" class="headerlink" title="收集 ASR 的方法"></a>收集 ASR 的方法</h2><ul>
<li>从<strong>需求文档</strong>收集</li>
<li>采访<strong>利益相关者</strong></li>
<li>举行 <strong>QAW</strong>（Quality attribute workshop 质量属性研讨会）</li>
<li>通过理解<strong>业务目标</strong>获取（PALM）</li>
<li>从<strong>效用树</strong>获取</li>
</ul>
<h2 id="Utility-Tree-效用树"><a href="#Utility-Tree-效用树" class="headerlink" title="Utility Tree 效用树"></a>Utility Tree 效用树</h2><p>效用树是一种用于记录 ASR 的方法</p>
<ul>
<li>首先需要确定每个 ASR 的优先级</li>
<li>根节点是名为 <strong>Utility</strong> 的占位符节点</li>
<li>第二层节点包含广泛的<strong>质量检查</strong>类别</li>
<li>第三层节点用于<strong>细化</strong>这些类别</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220102182333.png"></p>
<p>（业务价值，架构冲击） H=high, M=medium, L=low</p>
<h1 id="Design-Strategies-设计策略"><a href="#Design-Strategies-设计策略" class="headerlink" title="Design Strategies 设计策略"></a>Design Strategies 设计策略</h1><ul>
<li>分解：整个系统被分解成多个部分，每个部分承担一定的质量属性要求</li>
<li>设计 ASR：当设计无法满足 ASR 时，可以<ul>
<li>调整设计</li>
<li>降低要求</li>
<li>更改优先级</li>
</ul>
</li>
<li>生成和测试<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220102182744.png"></li>
</ul>
<h1 id="ADD-属性驱动设计-attribute-driven-design"><a href="#ADD-属性驱动设计-attribute-driven-design" class="headerlink" title="ADD 属性驱动设计 attribute driven design"></a>ADD 属性驱动设计 attribute driven design</h1><h2 id="ADD-步骤"><a href="#ADD-步骤" class="headerlink" title="ADD 步骤"></a>ADD 步骤</h2><ol>
<li>选择系统的一个元素来设计</li>
<li>识别选取元素的 ASR</li>
<li>为所选的元素生成<strong>设计方案</strong></li>
<li>清点未满足的需求，并从中选取下次迭代的输入</li>
<li>重复 1- 4 直至所有 ASR 被满足</li>
</ol>
<h2 id="ADD-输入输出"><a href="#ADD-输入输出" class="headerlink" title="ADD 输入输出"></a>ADD 输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li>功能</li>
<li>质量</li>
<li>约束</li>
</ul>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul>
<li>信息流</li>
<li>交互</li>
<li>责任</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/110856.jpg"></p>
<h1 id="架构评估"><a href="#架构评估" class="headerlink" title="架构评估"></a>架构评估</h1><h2 id="三种评估形式"><a href="#三种评估形式" class="headerlink" title="三种评估形式"></a>三种评估形式</h2><ul>
<li>设计过程中由<strong>设计者</strong>评估</li>
<li>设计过程中由<strong>同行</strong>评估</li>
<li>设计完成后由<strong>外部</strong>评估</li>
</ul>
<h2 id="ATAM"><a href="#ATAM" class="headerlink" title="ATAM"></a>ATAM</h2><p>Architecture Tradeoff Analysis Method 架构权衡评估<strong>方法</strong></p>
<h3 id="参与人"><a href="#参与人" class="headerlink" title="参与人"></a>参与人</h3><ul>
<li>评估小组</li>
<li>项目决策人</li>
<li>利益相关者</li>
</ul>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><ul>
<li>简明的架构介绍</li>
<li>明确的业务目标</li>
<li>以质量属性场景表示的、已经划分了优先级的质量属性需求</li>
<li>一组风险点和非风险点</li>
<li>一组风险主题</li>
<li>一组敏感点和权衡点</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>展示与介绍 <strong>ATAM 相关事项</strong>，如步骤、过程、结果等</li>
<li>说明<strong>业务</strong>，如系统重要功能、约束、干系人、目标与背景、ASR</li>
<li>展示<strong>架构</strong>，如解释说明重要的质量属性问题</li>
<li><strong>标识</strong>架构方法，如架构模式和战术</li>
<li>生成<strong>效用树</strong>。评估小组与项目决策者共同识别、排序和完善系统的重要质量属性目标</li>
<li><strong>分析</strong>架构方法。识别风险点、非风险点、敏感点、权衡点</li>
<li><strong>头脑风暴</strong> &amp; <strong>场景优先级排序</strong>。通过头脑风暴收集场景，通过投票确定优先级。将结果与效用树进行比较，若不一致则说明系统要实现的目标存在分歧</li>
<li><strong>分析</strong>架构方法。与第 6 步类似，但是使用的是最新的方案</li>
<li>展示结果</li>
</ol>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/113943.jpg"></p>
<h2 id="轻量级架构评估-lightweight-architecture-evaluation"><a href="#轻量级架构评估-lightweight-architecture-evaluation" class="headerlink" title="轻量级架构评估 lightweight architecture evaluation"></a>轻量级架构评估 lightweight architecture evaluation</h2><p>一个 ATAM 过程通常需要 20-30 天，只适用于大型昂贵的项目。所以发展出了轻量级架构评估，一般只需要一天甚至半天，只涉及组织内部的人员。这个评估方法不产生最终报告，而是由抄写员负责收集结果。只有组织内部成员来评估可能得出不客观的结果，缺乏创新和讨论。但是这个评估方法快速廉价，所以可以被快速部署，无论项目是否需要关于架构质量保证的合理性检查（sanity check）</p>
<h1 id="云"><a href="#云" class="headerlink" title="云"></a>云</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>按需供给</li>
<li>资源池。资源池可以提高性能</li>
<li>网络访问便捷、范围广</li>
<li>性能具备弹性，可以自己伸缩</li>
<li>让开发者更专注于业务本身，资源消费者不需要关注资源所在的位置</li>
<li>节省成本，一是运维成本，另一方面是因为弹性原因，消费者只需要支付自己使用部分的金额</li>
<li>便于监视、查看资源使用情况</li>
</ul>
<h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><h3 id="Software-as-a-Service-SaaS"><a href="#Software-as-a-Service-SaaS" class="headerlink" title="Software as a Service (SaaS)."></a>Software as a Service (SaaS).</h3><ul>
<li>消费者是一个终端用户</li>
<li>消费者使用恰好在云上运行的应用程序</li>
<li>示例：e-mail</li>
</ul>
<h3 id="Platform-as-a-Service-PaaS"><a href="#Platform-as-a-Service-PaaS" class="headerlink" title="Platform as a Service (PaaS)"></a>Platform as a Service (PaaS)</h3><ul>
<li>为用户提供在云上开发和部署应用程序的编程语言和工具</li>
<li>消费者是一个开发人员</li>
<li>示例：谷歌 App 引擎，微软 Azure</li>
</ul>
<h3 id="Infrastructure-as-a-Service-IaaS"><a href="#Infrastructure-as-a-Service-IaaS" class="headerlink" title="Infrastructure as a Service (IaaS)"></a>Infrastructure as a Service (IaaS)</h3><ul>
<li>为了提供处理、存储、网络和其他基本计算资源，消费者能够<strong>部署和运行</strong>任意软件，其中可以包括操作系统和应用程序</li>
<li>在这种情况下，消费者是开发人员或系统管理员</li>
<li>示例：亚马逊 EC2</li>
</ul>
<h2 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h2><ul>
<li>公有云：云基础设施向公众开放，并由销售云服务的组织拥有</li>
<li>私有云：云基础设施仅由单一组织拥有，并仅为该组织拥有的应用程序运行</li>
<li>社区云：云基础设施由几个组织共享，并支持一个有共同关注点的特定社区</li>
<li>混合云：云基础设施由两个或更多种类的云组成</li>
</ul>
<h1 id="云环境下的架构"><a href="#云环境下的架构" class="headerlink" title="云环境下的架构"></a>云环境下的架构</h1><h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>负载平衡。负载平衡是为了跨多个计算资源分配工作负载，以避免单个资源的过载</li>
<li>弹性缩放是一种方法，其中计算资源的数量，通常根据负载自动缩放</li>
</ul>
<h3 id="可获得性"><a href="#可获得性" class="headerlink" title="可获得性"></a>可获得性</h3><p>故障是云计算中常见的情况。云提供商确保云本身将保持可用，但有一些例外</p>
<ul>
<li>利用冗余来多次部署所有的服务：我们可以用两个服务器，两个负载均衡器，两个交换机，两个防火墙</li>
<li>HDFS（分布式文件系统）</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>多租户带来了对非云环境的额外关注</p>
<ul>
<li>无意的信息共享</li>
<li>虚拟机转义（脱离虚拟机并与主机操作系统交互）</li>
<li>拒绝服务攻击（一个用户可以通过消耗主机服务器的资源，以拒绝其他用户的使用）</li>
</ul>
]]></content>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 总结和 2022 目标</title>
    <url>/2022/01/01/from-2021-to-2022/</url>
    <content><![CDATA[<p>去年对我而言是非常特殊的一年，也是从去年的暑假开始，我正式决定要走 web 前端的路。</p>
<p>去年主要的学习时间都放在了前端的知识点，包括 html、css、js、webpack5、node.js、react hooks 等，但是感觉好像目前还没有哪个方向研究得比较深入。前端的知识体系庞大复杂，而且涉及到的计算机基础知识也很多，让人很容易迷失学习方向。但是通过这半年来的逐渐摸索，我也大概知道了一些主流的技术栈以及学习的方向，这算是一件让人高兴的事情。不过去年最高兴的事情还是恢复了单身（</p>
<p>今年要开始找实习了，寒假也马上要到来了，在这画画饼做个寒假计划：</p>
<ul>
<li>复习前端三件套，熟悉 ES6+ 语法</li>
<li>复习计网知识</li>
<li>复习浏览器工作原理</li>
<li>争取看完《代码随想录》</li>
<li>复习 web 性能优化方法</li>
<li>复习 react hooks + redux 的使用</li>
<li>复习 node.js 基础</li>
<li>复习数据库基础</li>
<li>复习 os 基础</li>
<li>学习重点的 react hooks 源码</li>
<li>学习 redux 和 react-router 实现原理</li>
<li>学习 webpack 及其重要原理</li>
<li>熟悉 koa.js 使用并学习部分源码</li>
<li>用 react hooks + koa.js 做一个有一定难度的小程序或者网页</li>
</ul>
<p>备选：</p>
<ul>
<li>学习 three.js 基础</li>
<li>学习 nest.js 使用</li>
</ul>
<p>最后，新的一年，最大的愿望就是身边的人和我都能快快乐乐的！</p>
]]></content>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO 优化</title>
    <url>/2021/12/31/seo/</url>
    <content><![CDATA[<h1 id="前端需要注意的-SEO-优化"><a href="#前端需要注意的-SEO-优化" class="headerlink" title="前端需要注意的 SEO 优化"></a>前端需要注意的 SEO 优化</h1><ul>
<li>合理使用 title、description、keywords：title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li>
<li>使用语义化的 HTML 代码，让搜索引擎更容易理解网页</li>
<li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用 js 输出，因为爬虫不会获取 js 添加的内容</li>
<li>少用 iframe，因为搜索引擎不会抓取 iframe 中的内容</li>
<li>非装饰性图片必须加 alt</li>
<li>提高网站速度，因为网站速度是搜索引擎排序的一个重要指标</li>
</ul>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础知识</title>
    <url>/2021/12/31/html-basics/</url>
    <content><![CDATA[<h1 id="行内元素、块级元素、空元素有哪些"><a href="#行内元素、块级元素、空元素有哪些" class="headerlink" title="行内元素、块级元素、空元素有哪些"></a>行内元素、块级元素、空元素有哪些</h1><p>行内：span, a, label 不独占一行，不能设置宽高<br>块级：div, footer, header, section, p, h1-h6 独占一行，可以设置宽高<br>空元素：br, hr 不独占一行，可以设置宽高</p>
<h1 id="标签语义化的理解"><a href="#标签语义化的理解" class="headerlink" title="标签语义化的理解"></a>标签语义化的理解</h1><ul>
<li>HTML 语义化就是让页面的内容结构化，便于对浏览器解析，便于搜索引擎捕获，可以优化 SEO</li>
<li>提高代码可读性</li>
</ul>
<h1 id="HTML5-的新特性"><a href="#HTML5-的新特性" class="headerlink" title="HTML5 的新特性"></a>HTML5 的新特性</h1><ul>
<li>新增选择器 document.querySelector、document.querySelectorAll</li>
<li>拖拽释放（Drag and drop） API</li>
<li>媒体播放的 video 和 audio</li>
<li>本地存储 localStorage 和 sessionStorage</li>
<li>离线应用 manifest</li>
<li>语义化标签 article、footer、header、nav、section</li>
<li>跨域资源共享（CORS） Access-Control-Allow-Origin</li>
<li>canvas</li>
</ul>
<h1 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的"></a>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的</h1><ul>
<li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源</li>
</ul>
<h1 id="cookie，sessionStorage-和-localStorage-的区别"><a href="#cookie，sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别"></a>cookie，sessionStorage 和 localStorage 的区别</h1><ul>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），也就是说它会在浏览器和服务器之间来回传递；sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li>
<li>cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 甚至更大</li>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非人为主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
<h1 id="iframe-的缺点"><a href="#iframe-的缺点" class="headerlink" title="iframe 的缺点"></a>iframe 的缺点</h1><ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li>
</ul>
<h1 id="src-与-href的区别"><a href="#src-与-href的区别" class="headerlink" title="src 与 href的区别"></a>src 与 href的区别</h1><p>src 用于<strong>替换</strong>当前元素，href 用于在当前文档和引用资源之间<strong>确立联系</strong></p>
<ul>
<li>src 是 source 的缩写，指向外部资源的位置，指向的内容将会<strong>嵌入到文档中当前标签所在位置</strong>；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 iframe 等元素</li>
<li>href 是 Hypertext Reference 的缩写，指向网络资源所在位置。如果我们在文档中添加 <code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code> 那么浏览器会识别该文档为 CSS 文件，然后<strong>并行</strong>下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 <code>link</code> 方式来加载 CSS，而不是 <code>@import</code> 方式</li>
</ul>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>图片格式选择</title>
    <url>/2021/12/31/picture-format-chosen/</url>
    <content><![CDATA[<h1 id="JPG-JPEG"><a href="#JPG-JPEG" class="headerlink" title="JPG / JPEG"></a>JPG / JPEG</h1><p>优点：</p>
<ul>
<li>有损压缩</li>
<li>不支持透明</li>
<li>适合色彩丰富的照片</li>
<li>体积小、加载快</li>
</ul>
<p>缺点：当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显</p>
<h1 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h1><p>优点：</p>
<ul>
<li>无损压缩</li>
<li>有 PNG8 和 PNG24</li>
<li>适合图标、背景、按钮</li>
</ul>
<p>缺点：体积大</p>
<h1 id="PNG-还是-JPG"><a href="#PNG-还是-JPG" class="headerlink" title="PNG 还是 JPG"></a>PNG 还是 JPG</h1><ul>
<li>复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储</li>
<li>考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等</li>
</ul>
<h1 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h1><p>优点：</p>
<ul>
<li>文件体积更小，可压缩性更强</li>
<li>矢量图，图片可无限放大而不失真</li>
<li>兼容性好</li>
</ul>
<p>缺点：渲染成本比较高，会影响性能</p>
<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p><strong>Base64 并非一种图片格式，而是一种编码方式</strong><br>优点：Base64 通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数</p>
<p>缺点：图片大小会膨胀为原文件的 4/3，因此只有在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势</p>
<p>使用场景：</p>
<ul>
<li>图片的实际尺寸很小</li>
<li>图片不适合以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）</li>
<li>图片的更新频率非常低，如 logo</li>
</ul>
<h1 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h1><p>优点：<br>WebP 支持有损和无损，它可以像 JPG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片。总而言之，它集多种图片文件格式的优点于一身。</p>
<p>缺点：<br>兼容性不好</p>
<p>我们可以使用这样的处理方案：在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式</p>
<p>参考资料：<br><a href="https://juejin.cn/book/6844733750048210957/section/6844733750106914830">https://juejin.cn/book/6844733750048210957/section/6844733750106914830</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>rgba 和 opacity 的透明效果比较</title>
    <url>/2021/12/31/rgbaopacity/</url>
    <content><![CDATA[<h1 id="rgba-和-opacity-的透明效果比较"><a href="#rgba-和-opacity-的透明效果比较" class="headerlink" title="rgba 和 opacity 的透明效果比较"></a>rgba 和 opacity 的透明效果比较</h1><p>rgba 和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，而 rgba 只作用于元素的颜色或其背景色。（换言之，设置 rgba 透明的元素的子元素不会继承透明效果！）</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>行高的三种赋值方式</title>
    <url>/2021/12/31/line-height-assignment/</url>
    <content><![CDATA[<h1 id="line-height-三种赋值方式之间的区别"><a href="#line-height-三种赋值方式之间的区别" class="headerlink" title="line-height 三种赋值方式之间的区别"></a>line-height 三种赋值方式之间的区别</h1><h2 id="带单位"><a href="#带单位" class="headerlink" title="带单位"></a>带单位</h2><p>px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</p>
<h2 id="纯数字"><a href="#纯数字" class="headerlink" title="纯数字"></a>纯数字</h2><p>会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</p>
<h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>会将计算后的值传递给后代。例如，父级行高为 150%，font-size 是 20px，那么行高就是 20px * 150% = 30px，子元素也是 30px</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>常见 CSS 布局</title>
    <url>/2021/12/30/css-layout/</url>
    <content><![CDATA[<h1 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h1><p>要求：左右固定，中间自适应。<br>原理：一个左浮，一个右浮，中间宽度自适应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h1><p>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽。<br>优点：重要内容放在文档流前面，可以被优先渲染</p>
<p>首先完成页面基础布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 避免出现奇怪 bug */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><ul>
<li>先给 container 设置左右 padding，把位置空出来<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>left 设置 margin-left 为 -100%，来到最左边<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>right 设置 margin-left 为 -自身宽度，来到最右边<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
完成后如图：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/232316.jpg"></li>
</ul>
<p>接下来只要给 left 和 right 分别一个 <code>position: relative</code> 将它们自身定位到两端即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><ul>
<li>首先在 main 里面添加一个子节点 content，若不设置此节点，main 的内容将无法显示<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>container 不需要设置 padding</li>
<li>left 和 right 不需要设置 relative 定位</li>
<li>调整子节点 content 位置<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">100px</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="多列等高布局"><a href="#多列等高布局" class="headerlink" title="多列等高布局"></a>多列等高布局</h1><p>考虑兼容性的情况下，可以使用很大的负 margin-bottom 和很大的正 padding-bottom 对冲实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span> -<span class="number">9999px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#5182e6</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">            测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</span><br><span class="line">            测试测试测试测试测试测试测试测试测试</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一家将客户利益置于首位的经纪商<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/164755.jpg"></p>
<p>参考资料：<br><a href="https://juejin.cn/post/6955482100426342430">https://juejin.cn/post/6955482100426342430</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>如何一次性插入一万条数据</title>
    <url>/2021/12/30/how-to-input-ten-thousand-data-at-one-time/</url>
    <content><![CDATA[<p>如果要在一个 ul 节点中一次性插入 10000 个 li 元素怎么办？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 插入一万条数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(i.toString());</span><br><span class="line">    child.appendChild(text);</span><br><span class="line">    parent.appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样对 DOM 反复操作会导致页面重绘、回流，效率非常低，而且页面可能会被卡死。</p>
<h1 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h1><p>DocumentFragment 翻译过来就是文档片段的意思。<br>简单来说就是在内存中提供了一个 DOM 对象，当我们需要频繁操作 DOM 的时候，可以在内存先中创建一个 DocumentFragment 文档片段，然后对这个文档片段中进行一系列频繁的 DOM 操作，当操作结束后直接插入真实的 DOM 节点中，这样所有的节点会被一次插入到真实的文档中，而这个操作仅发生一个<strong>重绘</strong>的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(i.toString());</span><br><span class="line">    child.appendChild(text);</span><br><span class="line">    fragment.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line">parent.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://juejin.cn/post/6950553806484537357">https://juejin.cn/post/6950553806484537357</a></p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>重绘和重排</title>
    <url>/2021/12/30/repaint-and-reflow/</url>
    <content><![CDATA[<h1 id="什么是重绘与重排"><a href="#什么是重绘与重排" class="headerlink" title="什么是重绘与重排"></a>什么是重绘与重排</h1><ul>
<li>重绘指更改外观属性而不影响几何属性的渲染；重排也叫回流，指几何属性改变的渲染。</li>
<li>注意：JS 获布局相关的属性值时（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流，因为浏览器需要通过回流计算最新值。</li>
<li>回流必将引起重绘，而重绘不一定会引起回流</li>
</ul>
<h1 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h1><h2 id="几何属性"><a href="#几何属性" class="headerlink" title="几何属性"></a>几何属性</h2><p>几何属性包括布局、尺寸等可用数学几何衡量的属性<br>布局：display、float、position、list、table、flex、columns、grid<br>尺寸：margin、padding、border、width、height</p>
<h2 id="外观属性"><a href="#外观属性" class="headerlink" title="外观属性"></a>外观属性</h2><p>外观属性包括界面、文字等可用状态向量描述的属性<br>界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip<br>文字：text、font、word</p>
<h1 id="如何减少重绘和回流"><a href="#如何减少重绘和回流" class="headerlink" title="如何减少重绘和回流"></a>如何减少重绘和回流</h1><ul>
<li>dom 离线修改：需要对元素进行复杂的操作时，可以先隐藏使用 <code>display: none;</code> 隐藏元素，操作完成后再显示</li>
<li>需要创建多个 dom 节点时，使用 DocumentFragment 创建完后一次性的加入文档</li>
<li>尽量避免用 table 布局（table 一旦触发回流就会导致 table 里所有的其它元素回流）</li>
<li>避免使用 css 表达式，因为每次调用都会重新计算值（包括加载页面）</li>
<li>批量修改元素样式：一次性修改完成后再更改元素类名</li>
<li>使用 transform 替代绝对定位，因为 tranform 会开启新图层，使用 GPU 进行渲染。如果图片未改变，GPU 可以直接使用缓存来绘制图层，所以很快。类似的 CSS 属性还有 opacity 和 filter</li>
</ul>
<p>参考资料：<br><a href="https://juejin.cn/book/6850413616484040711/section/6850413616559194119">https://juejin.cn/book/6850413616484040711/section/6850413616559194119</a><br><a href="https://blog.csdn.net/duola8789/article/details/79237553">https://blog.csdn.net/duola8789/article/details/79237553</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>link 和 @import 的区别</title>
    <url>/2021/12/30/link-import/</url>
    <content><![CDATA[<h1 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h1><ul>
<li>link是 html 方式， @import 是 css 方式。@import 只有导入样式表的作用；link 不仅可以加载 CSS 文件，还可以定义其他属性，如 shortcut</li>
<li>加载页面时，link 标签引入的 CSS 被同时并行加载；@import引入的 CSS 将在页面加载完毕后被加载，会出现 FOUC（文档样式短暂失效）</li>
<li>浏览器对 link 支持早于 @import，兼容性更好</li>
<li>可以通过 JS 操作 DOM ，插入 link 标签来改变样式；JS 无法使用 @import 的方式插入样式</li>
</ul>
<h1 id="补充：什么是-FOUC"><a href="#补充：什么是-FOUC" class="headerlink" title="补充：什么是 FOUC"></a>补充：什么是 FOUC</h1><p>FOUC（Flash Of Unstyled Content）：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。<br>解决方法：把样式表放到文档的 <code>&lt;head&gt;</code></p>
<p>参考资料：<br><a href="https://www.cnblogs.com/my--sunshine/p/6872224.html">https://www.cnblogs.com/my--sunshine/p/6872224.html</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>display、overflow 和 opacity</title>
    <url>/2021/12/30/display-overflow-opacity/</url>
    <content><![CDATA[<h1 id="display-none-与-visibility-hidden-与-opacity-0-的区别"><a href="#display-none-与-visibility-hidden-与-opacity-0-的区别" class="headerlink" title="display: none 与 visibility: hidden 与 opacity: 0 的区别"></a>display: none 与 visibility: hidden 与 opacity: 0 的区别</h1><p>联系：它们都能让元素不可见<br>区别：</p>
<ul>
<li><code>opacity: 0</code> 设置后元素还可以进行交互，如点击事件之类的</li>
<li><code>display:none;</code> 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code> 不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li>
<li><code>display: none;</code> 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility: hidden;</code> 是继承属性，子孙节点消失由于继承了 hidden，通过设置 <code>visibility: visible;</code> 可以让子孙节点显式</li>
<li>修改 display 通常会造成文档重排；修改 visibility 只会造成元素重绘</li>
<li>读屏器不会读取 <code>display: none;</code> 元素内容；会读取 <code>visibility: hidden;</code> 元素内容</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动的方法</title>
    <url>/2021/12/30/clearfix/</url>
    <content><![CDATA[<p>示例代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span>:after &#123;</span></span><br><span class="line"><span class="css">        content: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line"><span class="css">        <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span> &#123;</span></span><br><span class="line"><span class="css">        *zoom: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent clearfix&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="父元素设置具体高度"><a href="#父元素设置具体高度" class="headerlink" title="父元素设置具体高度"></a>父元素设置具体高度</h1><p>给父元素设置具体高度后，即可清除浮动。但是这样相当于把高度写死了，很不灵活。</p>
<h1 id="父元素结束标签之前插入空元素"><a href="#父元素结束标签之前插入空元素" class="headerlink" title="父元素结束标签之前插入空元素"></a>父元素结束标签之前插入空元素</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="给父元素添加伪元素（推荐）"><a href="#给父元素添加伪元素（推荐）" class="headerlink" title="给父元素添加伪元素（推荐）"></a>给父元素添加伪元素（推荐）</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 兼容 IE */</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear 属性只有块级元素才有效的，而 ::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 为 block 的原因</p>
<h1 id="利用-BFC"><a href="#利用-BFC" class="headerlink" title="利用 BFC"></a>利用 BFC</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="父元素浮动或者绝对定位"><a href="#父元素浮动或者绝对定位" class="headerlink" title="父元素浮动或者绝对定位"></a>父元素浮动或者绝对定位</h1><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://juejin.cn/post/6844903504545316877">https://juejin.cn/post/6844903504545316877</a><br><a href="https://www.kancloud.cn/pillys/qianduan/2049767">https://www.kancloud.cn/pillys/qianduan/2049767</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>width 自适应不同取值的区别</title>
    <url>/2021/12/30/width-assignment/</url>
    <content><![CDATA[<h1 id="width-100-与-width-auto-的区别"><a href="#width-100-与-width-auto-的区别" class="headerlink" title="width: 100% 与 width: auto 的区别"></a>width: 100% 与 width: auto 的区别</h1><ol>
<li><p>width:100% 并不包含 margin-left 和 margin-right 的属性值，直接取其父容器的宽度加上含 margin-left 和 margin-right 的值。如果设置了 margin 那新的 width 值是容器的宽度加上 margin 的值。</p>
</li>
<li><p>width:auto 包含 margin-left 和 margin-right 的属性值。width:auto 总是占据整行，margin 的值已经包含其中了。</p>
</li>
<li><p>一般 width:auto 使用的多，因为这样灵活，而 width:100% 使用比较少，因为在增加 padding 或者 margin 的时候，容易使其突破父级框，破环布局。</p>
</li>
</ol>
<p>举例来说，<br>当 child 没有加 margin，两者之间没什么区别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">195</span>, <span class="number">229</span>, <span class="number">236</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者改成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果都一样<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/202858.jpg"></p>
<p>但是当 child 加上 margin 后，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>width: 100%</code> 的情况会变为<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/203137.jpg"><br><code>width: auto</code> 的情况会变为<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/203252.jpg"></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的 CSS 兼容性问题</title>
    <url>/2021/12/30/browser-css-compatibility/</url>
    <content><![CDATA[<h1 id="浏览器默认的-margin-和-padding-不同"><a href="#浏览器默认的-margin-和-padding-不同" class="headerlink" title="浏览器默认的 margin 和 padding 不同"></a>浏览器默认的 margin 和 padding 不同</h1><p>解决方案：加一个全局的 <code>* &#123;margin: 0; padding: 0;&#125;</code> 来统一</p>
<h1 id="双边距"><a href="#双边距" class="headerlink" title="双边距"></a>双边距</h1><p>在 IE6 下，如果对元素设置了浮动，同时又设置了 margin-left 或 margin-right，margin 值会加倍</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况之下 IE6 会产生 20px 的距离<br>解决方案：在float的标签样式控制中加入 <code>_display:inline;</code> 将其转化为行内属性(_这个符号只有 IE6 会识别)</p>
<h1 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h1><p>IE 下，event 对象有 x、y 属性，但是没有 pageX、pageY 属性；Firefox下，event 对象有 pageX、pageY属性，但是没有 x、y 属性</p>
<h1 id="Chrome-文本大小"><a href="#Chrome-文本大小" class="headerlink" title="Chrome 文本大小"></a>Chrome 文本大小</h1><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示<br>可以使用 <code>-webkit-transform: scale(0.5);</code><br>注意 <code>-webkit-transform: scale(0.75);</code> 收缩的是整个 span 的大小，这时候，必须要将 span 转换成块元素，可以使用 <code>display：block/inline-block/...</code>。</p>
<h1 id="hover"><a href="#hover" class="headerlink" title="hover"></a>hover</h1><p>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不再具有 hover 和 active 了<br>解决方法：改变 CSS 属性的排列顺序 L-V-H-A，即 link &gt; visited &gt; hover &gt; active</p>
<h1 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h1><p>IE8 以下，没有 opacity 属性<br>解决方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>元素居中的方法</title>
    <url>/2021/12/30/element-middle-method/</url>
    <content><![CDATA[<h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><h2 id="margin-0-auto"><a href="#margin-0-auto" class="headerlink" title="margin: 0 auto"></a>margin: 0 auto</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">子元素块级元素，设置 `<span class="attribute">margin</span>: <span class="number">0</span> auto`</span><br></pre></td></tr></table></figure>

<h2 id="text-align-center"><a href="#text-align-center" class="headerlink" title="text-align: center"></a>text-align: center</h2><p>子元素行内元素，父亲设置 <code>text-align: center</code> 即可</p>
<h1 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h1><h2 id="负数-margin"><a href="#负数-margin" class="headerlink" title="负数 margin"></a>负数 margin</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">75px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transfrom"><a href="#transfrom" class="headerlink" title="transfrom"></a>transfrom</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://www.jianshu.com/p/a7552ce07c88">https://www.jianshu.com/p/a7552ce07c88</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 选择器</title>
    <url>/2021/12/30/css-selector/</url>
    <content><![CDATA[<h1 id="CSS-选择器种类"><a href="#CSS-选择器种类" class="headerlink" title="CSS 选择器种类"></a>CSS 选择器种类</h1><ul>
<li>id 选择器 #myid</li>
<li>类选择器 .classname</li>
<li>标签选择器 div</li>
<li>后代选择器 div p</li>
<li>子选择器 div &gt; p</li>
<li>兄弟选择器 div ~ p</li>
<li>相邻兄弟选择器 div + p</li>
<li>属性选择器 a[rel=&quot;external&quot;]</li>
<li>伪类选择器 a:hover，li:first-child</li>
<li>伪元素选择器 a::before，a:after</li>
<li>通配符选择器 *</li>
</ul>
<h1 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h1><ul>
<li>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态</li>
<li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过 ::before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中</li>
</ul>
<h1 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h1><h2 id="权重大小"><a href="#权重大小" class="headerlink" title="权重大小"></a>权重大小</h2><ul>
<li>!important，权重无穷大</li>
<li>行内样式，权重 1000</li>
<li>id 选择器，权重 100</li>
<li>类选择器、属性选择器和伪类选择器，权重 10</li>
<li>标签选择器和伪元素选择器，权重 1</li>
<li>通配符，权重 0</li>
</ul>
<h2 id="权重作用"><a href="#权重作用" class="headerlink" title="权重作用"></a>权重作用</h2><ul>
<li>一般来说，权重大的样式生效</li>
<li>相同的权重，后面的规则覆盖前面的规则</li>
<li>拥有更高权重等级的 css 权重更高。例如 11 个 class 和一个 id，利用前述的计算方法 11 个 class 的权重为 110，id 权重为 100，class 权重值更大，但是这并不成立，这种情况下之前的计算方法不再适用。</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>盒子模型</title>
    <url>/2021/12/30/box-model/</url>
    <content><![CDATA[<h1 id="盒子模型的分类"><a href="#盒子模型的分类" class="headerlink" title="盒子模型的分类"></a>盒子模型的分类</h1><p>有 3 种盒子模型：IE 盒模型（border-box）、标准盒模型（content-box）、padding-box<br>盒模型一般都由四部分组成：内容（content）、填充（padding）、边界（margin）、边框（border）</p>
<h1 id="盒子模型之间的区别"><a href="#盒子模型之间的区别" class="headerlink" title="盒子模型之间的区别"></a>盒子模型之间的区别</h1><ul>
<li>标准盒模型：width，height 只包含内容 content，不包含 border 和 padding</li>
<li>IE 盒模型：width，height 包含 content、border 和 padding</li>
<li>padding-box：width，height 包含 content、padding，不包含 border</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/2021/12/30/BFC/</url>
    <content><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>BFC，即 block-formatting-context，块级格式化上下文。通俗来说，BFC 是一个完全独立的区域，在区域内的子元素不会影响到外面的布局。</p>
<h1 id="BFC-创建方法"><a href="#BFC-创建方法" class="headerlink" title="BFC 创建方法"></a>BFC 创建方法</h1><ul>
<li>根元素（html）</li>
<li>浮动元素</li>
<li>定位为 absolute 或 fixed</li>
<li>行内块元素（display: inline-block）</li>
<li>overflow 的值不为 visible</li>
<li>flex box（display: flex 或 inline-flex）</li>
</ul>
<h1 id="BFC-的特征"><a href="#BFC-的特征" class="headerlink" title="BFC 的特征"></a>BFC 的特征</h1><ul>
<li>属于同一个 BFC 的两个相邻元素的 margin 会发生重叠，不同的 BFC 之间 margin 不重合（解决 margin 重叠）</li>
<li>计算 BFC 的高度时，浮动元素也参与计算（清除浮动）</li>
<li>BFC 的区域不会与 float 元素重叠（两栏布局）</li>
</ul>
<h1 id="BFC-可以解决的问题"><a href="#BFC-可以解决的问题" class="headerlink" title="BFC 可以解决的问题"></a>BFC 可以解决的问题</h1><h2 id="防止-margin-重叠"><a href="#防止-margin-重叠" class="headerlink" title="防止 margin 重叠"></a>防止 margin 重叠</h2><h3 id="使用-BFC-前"><a href="#使用-BFC-前" class="headerlink" title="使用 BFC 前"></a>使用 BFC 前</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/150941.jpg"><br>因为 margin 塌陷，实际两者之间只间隔了 100 px。</p>
<h3 id="使用-BFC-后"><a href="#使用-BFC-后" class="headerlink" title="使用 BFC 后"></a>使用 BFC 后</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/151538.jpg"></p>
<p>水平方向和嵌套同理。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h3 id="使用-BFC-前-1"><a href="#使用-BFC-前-1" class="headerlink" title="使用 BFC 前"></a>使用 BFC 前</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/151744.jpg"></p>
<h3 id="使用-BFC-后-1"><a href="#使用-BFC-后-1" class="headerlink" title="使用 BFC 后"></a>使用 BFC 后</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152029.jpg"></p>
<h2 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h2><h3 id="使用-BFC-前-2"><a href="#使用-BFC-前-2" class="headerlink" title="使用 BFC 前"></a>使用 BFC 前</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#f66</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152919.jpg"></p>
<h3 id="使用-BFC-后-2"><a href="#使用-BFC-后-2" class="headerlink" title="使用 BFC 后"></a>使用 BFC 后</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/153139.jpg"></p>
<p>参考资料：<br><a href="https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md">https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md</a></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU 缓存机制</title>
    <url>/2021/12/24/lru-cache/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/lru-cache/">https://leetcode-cn.com/problems/lru-cache/</a><br>解法分析：LRU 经典模拟题，使用双链表 + 哈希组合的方法解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> DoubleLinkedListNode = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> LRUCache = <span class="function"><span class="keyword">function</span>(<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 通过 dummy 节点减少边界处理</span></span><br><span class="line">    <span class="built_in">this</span>.dummyHead = <span class="keyword">new</span> DoubleLinkedListNode(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.dummyTail = <span class="keyword">new</span> DoubleLinkedListNode(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next = <span class="built_in">this</span>.dummyTail;</span><br><span class="line">    <span class="built_in">this</span>.dummyTail.prev = <span class="built_in">this</span>.dummyHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype._isFull = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map.size === <span class="built_in">this</span>.capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;DoubleLinkedListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;DoubleLinkedListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype._removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;DoubleLinkedListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype._addToHead = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="built_in">this</span>.dummyHead.next;</span><br><span class="line">    node.next = head;</span><br><span class="line">    head.prev = node;</span><br><span class="line">    node.prev = <span class="built_in">this</span>.dummyHead;</span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.map.has(key)) &#123;</span><br><span class="line">        <span class="comment">// get 的要放到链表头</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="built_in">this</span>.map.get(key);</span><br><span class="line">        <span class="built_in">this</span>._addToHead(<span class="built_in">this</span>._removeNode(node));</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.map.has(key)) &#123;</span><br><span class="line">        <span class="comment">// 若已存在，修改值，然后将其放到链表头</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="built_in">this</span>.map.get(key);</span><br><span class="line">        node.value = value;</span><br><span class="line">        <span class="built_in">this</span>._addToHead(<span class="built_in">this</span>._removeNode(node));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._isFull()) &#123;</span><br><span class="line">            <span class="comment">// 容量已满，去除尾节点，同时删除哈希表中的对应 key</span></span><br><span class="line">            <span class="keyword">const</span> node = <span class="built_in">this</span>.dummyTail.prev;</span><br><span class="line">            <span class="built_in">this</span>.map.delete(node.key);</span><br><span class="line">            <span class="built_in">this</span>._removeNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加头节点</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> DoubleLinkedListNode(key, value);</span><br><span class="line">        <span class="built_in">this</span>.map.set(key, node);</span><br><span class="line">        <span class="built_in">this</span>._addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS画棵动态圣诞树</title>
    <url>/2021/12/22/css-merry-christmas/</url>
    <content><![CDATA[<p>偶然在 b 站看到的视频，然后用 react 还原了一下，并部署到了 vercel。</p>
<p>仓库地址：<br><a href="https://github.com/Flower-F/merry-christmas">https://github.com/Flower-F/merry-christmas</a><br>在线体验：<br><a href="https://merry-christmas-taupe.vercel.app/">https://merry-christmas-taupe.vercel.app/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Merry Christmas</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;tree&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;iconfont icon-iconcollect-copy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;top&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">90deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">180deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">270deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;top&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">translateY</span>(<span class="attr">78px</span>)&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">90deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">180deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">270deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;top&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">translateY</span>(<span class="attr">156px</span>)&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">90deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">180deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">270deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;top&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">translateY</span>(<span class="attr">234px</span>)&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">90deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">180deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">270deg</span>) <span class="attr">rotateX</span>(<span class="attr">30deg</span>) <span class="attr">translateZ</span>(<span class="attr">86px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">translateZ</span>(<span class="attr">30px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">90deg</span>) <span class="attr">translateZ</span>(<span class="attr">30px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">180deg</span>) <span class="attr">translateZ</span>(<span class="attr">30px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span> &#x27;<span class="attr">rotateY</span>(<span class="attr">270deg</span>) <span class="attr">translateZ</span>(<span class="attr">30px</span>)&#x27; &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;shadow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* App.css */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.App</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e8ffe8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(-<span class="number">20deg</span>) <span class="built_in">rotateY</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">animation</span>: movie <span class="number">7s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> movie &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(-<span class="number">20deg</span>) <span class="built_in">rotateY</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(-<span class="number">20deg</span>) <span class="built_in">rotateY</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">&#x27;Segoe UI&#x27;</span>, Roboto, Oxygen, Ubuntu, Cantarell, <span class="string">&#x27;Open Sans&#x27;</span>, <span class="string">&#x27;Helvetica Neue&#x27;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> <span class="selector-class">.icon-iconcollect-copy</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">1rem</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">10rem</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: yellow <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> <span class="selector-class">.top</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#69c069</span>, <span class="number">#77dd77</span>);</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">0%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">100%</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid <span class="number">#000000</span>19;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> <span class="selector-class">.bottom</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">30px</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#bb4622</span>, <span class="number">#df7214</span>);</span><br><span class="line">  <span class="comment">/* clip-path: polygon(50% 0%, 0% 100%, 100% 100%); */</span></span><br><span class="line">  <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid <span class="number">#000000</span>55;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tree</span> <span class="selector-class">.shadow</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>2;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(-<span class="number">280px</span>);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://www.youtube.com/watch?v=hrv2XAY27gU">https://www.youtube.com/watch?v=hrv2XAY27gU</a></p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2021/12/18/rotate-list/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/rotate-list/">https://leetcode-cn.com/problems/rotate-list/</a><br>解法分析：<br>解法一：直接法。假设链表长度为 n。首先显然需要 k % n，然后只需要将链表的后 k 个节点移动到链表的最前面，然后将链表的后 k 个节点和前 n - k 个节点连接到一块即可。问题就转变成了找到链表的尾节点、头节点（已知）、第 n - k 个节点。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotateRight</span>(<span class="params">head: ListNode | <span class="literal">null</span>, k: <span class="built_in">number</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || k === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里要返回 head，不能返回 null</span></span><br><span class="line">        <span class="comment">// return null</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">// 存储尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p = head; p !== <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">    k %= n;</span><br><span class="line">    <span class="keyword">let</span> nk = head; <span class="comment">// 第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nk = nk.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = head;</span><br><span class="line">    head = nk.next;</span><br><span class="line">    nk.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法二：<br>首先思考一下如何返回链表倒数第 k 个节点。</p>
<ul>
<li>采用快慢指针</li>
<li>快指针与慢指针都以每步一个节点的速度向后遍历</li>
<li>快指针比慢指针先走 k 步</li>
<li>当快指针到达终点时，慢指针正好是倒数第 k 个节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> slow = (fast = head);</span><br><span class="line"><span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (k-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  fast = fast.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以解法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        now = head;</span><br><span class="line">    <span class="keyword">while</span> (now) &#123;</span><br><span class="line">        now = now.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    k = k % count;</span><br><span class="line">    <span class="keyword">let</span> slow = (fast = head);</span><br><span class="line">    <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast.next = head;</span><br><span class="line">    <span class="keyword">let</span> res = slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>参考题解：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/solution/xuan-zhuan-lian-biao-tu-jie-lian-biao-zu-ku33/">https://leetcode-cn.com/problems/rotate-list/solution/xuan-zhuan-lian-biao-tu-jie-lian-biao-zu-ku33/</a></li>
<li>公众号力扣加加</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵 I &amp;&amp; 螺旋矩阵 II</title>
    <url>/2021/12/13/spiral-matrix/</url>
    <content><![CDATA[<h1 id="螺旋矩阵-I"><a href="#螺旋矩阵-I" class="headerlink" title="螺旋矩阵 I"></a>螺旋矩阵 I</h1><p>题目链接：<br><a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="literal">false</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">const</span> directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m * n; i++) &#123;</span><br><span class="line">        res.push(matrix[row][col]);</span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> newRow = row + directions[directionIndex][<span class="number">0</span>], </span><br><span class="line">            newCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newRow &gt;= m || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newCol &lt; <span class="number">0</span> || visited[newRow][newCol]) &#123;</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        col = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h1><p>题目链接：<br><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a><br>解法分析：几乎同螺旋矩阵 I</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateMatrix</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> maxNum = n * n;</span><br><span class="line">    <span class="keyword">let</span> curNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]; <span class="comment">// 顺时针</span></span><br><span class="line">    <span class="keyword">let</span> col = <span class="number">0</span>, row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curNum &lt;= maxNum) &#123;</span><br><span class="line">        res[row][col] = curNum;</span><br><span class="line">        curNum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> nextRow = row + direction[directionIndex][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> nextCol = col + direction[directionIndex][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(nextRow &gt;= <span class="number">0</span> &amp;&amp; nextRow &lt; n &amp;&amp; nextCol &gt;= <span class="number">0</span> &amp;&amp; nextCol &lt; n &amp;&amp;</span><br><span class="line">            res[nextRow][nextCol] === <span class="number">0</span>)) &#123;</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 顺时针旋转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row = row + direction[directionIndex][<span class="number">0</span>];</span><br><span class="line">        col = col + direction[directionIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>js 遍历对象</title>
    <url>/2021/12/13/js-traversal/</url>
    <content><![CDATA[<p>本文总结 js 遍历对象的方法。<br>下面是本文所用的测试对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parentObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;aaaaa&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">Symbol</span>(<span class="string">&#x27;bbbbb&#x27;</span>),</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;ccccc&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(parentObj, &#123;</span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;ddddd&#x27;</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;eeeee&#x27;</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;f&#x27;</span>)]: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;fffff&#x27;</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="9-种遍历方法"><a href="#9-种遍历方法" class="headerlink" title="9 种遍历方法"></a>9 种遍历方法</h1><h2 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h2><p>Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的 object 上面<strong>可直接枚举</strong>的属性(<strong>不含 Symbol 属性</strong>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Object.keys(): &#x27;</span>, <span class="built_in">Object</span>.keys(obj)); </span><br><span class="line"><span class="comment">// Object.keys():  [ &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h2><p>Object.values() 返回一个数组，其元素是在对象上找到的<strong>可枚举</strong>属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Object.values():&#x27;</span>, <span class="built_in">Object</span>.values(obj)); </span><br><span class="line"><span class="comment">// Object.values(): [ &#x27;ddddd&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-entries-obj"><a href="#Object-entries-obj" class="headerlink" title="Object.entries(obj)"></a>Object.entries(obj)</h2><p>Object.entries() 返回一个数组，其元素是与直接在 object 上找到的<strong>可枚举属性</strong>键值对相对应的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Object.entries():&#x27;</span>, <span class="built_in">Object</span>.entries(obj)); </span><br><span class="line"><span class="comment">// Object.entries(): [ [ &#x27;d&#x27;, &#x27;ddddd&#x27; ] ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h2><p>Object.getOwnPropertyNames() 方法返回一个由指定对象的所有自身属性的属性名（<strong>包括不可枚举属性但不包括 Symbol 值</strong>作为名称的属性）组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Object.getOwnPropertyNames():&#x27;</span>, <span class="built_in">Object</span>.getOwnPropertyNames(obj)); </span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames(): [ &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h2><p>Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Object.getOwnPropertySymbols()&#x27;</span>, <span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line"><span class="comment">// Object.getOwnPropertySymbols() [ Symbol(f) ]</span></span><br></pre></td></tr></table></figure>

<h2 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h2><p>遍历所有<strong>可枚举</strong>的属性（包括原型上的），然后可利用 hasOwnProperty 判断对象是否包含特定的自身（非继承）属性。<br>注意事项：</p>
<ol>
<li>index 索引为字符串型数字，不能直接进行几何运算</li>
<li>遍历顺序有可能不是按照实际数组的内部顺序</li>
<li>会遍历数组的所有可枚举属性，包括原型</li>
<li>for…in 更适合便利对象，不要使用 for…in 遍历数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;for in:&#x27;</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for in: d</span></span><br><span class="line"><span class="comment">// for in: a</span></span><br><span class="line"><span class="comment">// for in: b</span></span><br><span class="line"><span class="comment">// for in: c</span></span><br></pre></td></tr></table></figure>
<h2 id="for…of…"><a href="#for…of…" class="headerlink" title="for…of…"></a>for…of…</h2><p>必须部署了 <strong>Iterator</strong> 接口后才能使用。使用范围：数组、Set 和 Map 结构、类数组对象（arguments、DOMNodeList对象……）、Generator 对象以及字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">Object</span>.values(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;for of:&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for of: ddddd</span></span><br></pre></td></tr></table></figure>

<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>使用 break 不能中断循环使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(obj).forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;forEach:&#x27;</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// forEach: ddddd</span></span><br></pre></td></tr></table></figure>

<h2 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h2><p>返回一个数组，包含对象自身的<strong>所有属性</strong>，不管属性名是 Symbol 还是字符串，也不管是否可枚举。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Reflect.ownKeys():&#x27;</span>, <span class="built_in">Reflect</span>.ownKeys(obj));</span><br><span class="line"><span class="comment">// Reflect.ownKeys(): [ &#x27;d&#x27;, &#x27;e&#x27;, Symbol(f) ]</span></span><br></pre></td></tr></table></figure>

<h1 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/123131212.JPG"></p>
<h1 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h1><p>上述遍历对象的属性时都遵循同样的属性遍历次序规则：</p>
<ol>
<li>首先遍历所有属性名为<strong>数值</strong>的属性，按照数字排序</li>
<li>其次遍历所有属性名为<strong>字符串</strong>的属性，按照生成时间排序</li>
<li>最后遍历所有属性名为 <strong>Symbol</strong> 值的属性，按照生成时间排序</li>
</ol>
<p>参考资料：公众号前端点线面</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 数据类型</title>
    <url>/2021/12/11/js-data-types/</url>
    <content><![CDATA[<h1 id="8-种数据类型"><a href="#8-种数据类型" class="headerlink" title="8 种数据类型"></a>8 种数据类型</h1><p>最新的 ECMAScript 标准定义了 8 种数据类型：</p>
<h2 id="7-种基本类型"><a href="#7-种基本类型" class="headerlink" title="7 种基本类型"></a>7 种基本类型</h2><ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>undefined</li>
<li>null</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
<h2 id="1-种引用类型"><a href="#1-种引用类型" class="headerlink" title="1 种引用类型"></a>1 种引用类型</h2><ul>
<li>Object</li>
</ul>
<h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p>布尔类型可以有两个值：true 和 false。</p>
<h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p>Null 类型只有一个值： null。</p>
<h1 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h1><p>通过 var 声明的变量，在没有被赋值之前，变量会有个默认值 undefined。</p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>Number 的范围：[-2^53, 2^53]。<br>特殊的 Number：Infinity, -Infinity, NaN。<br>数字类型中只有 0 一个整数有 2 种表示方法： 0 可表示为 -0 和 +0（0 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如 +0 === -0 为真。 但是，在除以0的时候要注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> / +<span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span>; <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<h1 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h1><p>BigInt 表示任意精度的整数。使用 BigInt，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt 是通过在整数末尾附加 n 或调用构造函数来创建的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2n</span> ** <span class="number">53n</span>; <span class="comment">// 9007199254740992n</span></span><br><span class="line"><span class="keyword">const</span> y = x + <span class="number">1n</span>; <span class="comment">// 9007199254740993n</span></span><br></pre></td></tr></table></figure>
<p>BigInt 不能与数字互换操作。否则，将抛出 TypeError。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/205644.jpg"><br>但是，可以基于对原始字符串的操作来创建新的字符串。例如：</p>
<ul>
<li>获取一个字符串的子串可通过选择个别字母或者使用 String.substr()</li>
<li>两个字符串的连接使用连接操作符 +</li>
</ul>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol 值通过Symbol() 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。<strong>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>Symbol函数前不能使用new命令</strong>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// Symbol(foo)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.toString()); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.toString()); <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString() 方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Symbol([object Object])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Symbol(hello)</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值也是不相等的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Symbol 值不能与其他类型的值进行运算，否则会报错。</p>
<p>但是，Symbol 值可以显式转为字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(s)); <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString()); <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，Symbol 值也可以转为布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(s)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!s);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于<strong>一个对象由多个模块构成的情况</strong>非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="string">&#x27;mySymbol&#x27;</span>]); <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。<br>但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols() 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols);</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h2><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。比如，如果你调用 Symbol.for(“cat”) 30 次，每次都会返回同一个 Symbol 值，但是调用 Symbol(“cat”) 30 次，会返回 30 个不同的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h2><p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量s2属于未登记的 Symbol 值，所以返回 undefined。</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>在计算机科学中，对象是指内存中的可以被标识符引用的一块区域。在 JavaScript 里，对象可以被看作是一组属性的集合。一个 JavaScript 对象就是键和值之间的映射。<strong>键是一个字符串（或者 Symbol）</strong>，值可以是任意类型的值。<br>ECMAScript 定义的对象中有两种属性：数据属性和访问器属性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/205941.jpg"></p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/210049.jpg"></p>
<h1 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h1><p>1995 年 JavaScript 诞生时，最初像 Java 一样，只设置了 null 作为表示 “无” 的值。<br>根据 C 语言的传统，null 被设计成可以自动转为 0。<br>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因：</p>
<ul>
<li>首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示 “无” 的值最好不是对象。</li>
<li>其次，JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。<br>因此，Brendan Eich 又设计了一个 undefined。</li>
</ul>
<p>1、undefined 不是关键字，而 null 是关键字。这意味着 undefined 可以被重写，使用起来可能会不安全。<br>2、undefined 和 null 被转换为布尔值的时候，两者都为 false。<br>3、undefined 和 null 进行 == 比较时两者相等，进行 === 比较时两者不等。<br>4、使用 Number() 对 undefined 和 null 进行类型转换，undefined 是 NaN，null 是 0。</p>
<h1 id="为什么需要堆和栈两个存储空间"><a href="#为什么需要堆和栈两个存储空间" class="headerlink" title="为什么需要堆和栈两个存储空间"></a>为什么需要堆和栈两个存储空间</h1><p>因为 JavaScript 引擎需要用栈来维护程序<strong>执行上下文</strong>的状态（调用栈），如果栈空间太大的话（即所有数据都存储在栈空间中），会影响上下文的切换效率，进而影响整个程序的执行效率，所以通常情况下栈空间不会设置太大，用于存储基本类型这样的小数据，而引用类型将存储到堆中，并且会分配一个内存地址。该内存地址会存储到栈空间。</p>
<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><h2 id="什么是包装对象"><a href="#什么是包装对象" class="headerlink" title="什么是包装对象"></a>什么是包装对象</h2><p>JS 的数值，布尔，字符串类型的变量，在一定条件下，也可以自动变成对象，这就是原始类型的包装对象。包装对象其实是一种特殊的引用类型，其与引用类型的主要区别在于<strong>生命周期</strong>：</p>
<ol>
<li>一般的引用类型在使用 new 创建其实例时，在执行流离开当前作用域之前一直都保存在内存中</li>
<li>包装类型的对象只存在该行代码的执行瞬间，然后会<strong>立即销毁</strong>。（也意味着在运行时不能为基本类型添加属性和方法）</li>
</ol>
<p>以字符串为例，来演示该流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> strNew = str.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在运行到 str.substring(0, 2) 的时候其实偷偷执行了以下三步：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(str);</span><br><span class="line"><span class="keyword">const</span> strNew = strObj.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">strObj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol>
<li>包装对象和同样的原始类型的值相等吗？<br>不相等。因为包装对象是引用类型，原始类型是基本类型；包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值（万物皆对象的思想），其次使得原始类型的值可以方便地调用某些方法。</li>
<li>如何给基本类型添加属性和方法？<br>在基本包装对象的原型上添加，每个对象都有原型。</li>
<li>同一个字符串调用两次相同的方法其包装对象相等吗？<br>不相等。调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，这也说明了为什么不能直接给字符串、数字、布尔值添加属性和方法。</li>
</ol>
<p>参考资料：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</a><br><a href="https://es6.ruanyifeng.com/#docs/symbol">https://es6.ruanyifeng.com/#docs/symbol</a><br><a href="https://blog.csdn.net/weixin_42213025/article/details/105809018">https://blog.csdn.net/weixin_42213025/article/details/105809018</a><br><a href="https://www.cnblogs.com/green-jcx/p/9391720.html">https://www.cnblogs.com/green-jcx/p/9391720.html</a><br>公众号前端点线面</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const 辨析</title>
    <url>/2021/12/11/var-let-const/</url>
    <content><![CDATA[<h1 id="var"><a href="#var" class="headerlink" title="var"></a>var</h1><ol>
<li>有变量提升</li>
<li>没有块的概念，可以跨块访问；作用域只存在于函数中，不可以跨函数访问</li>
<li>可以重复声明</li>
</ol>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><ol>
<li>有块级作用域</li>
<li>let 也有变量提升，但是 var 声明的变量会被赋值 undefined，let 和 const 声明的变量不会被初始化</li>
<li>存在暂时性死区。在块级作用域内，let 声明之前的部分被称为暂时性死区，暂时性死区内不可以使用 let 声明的变量</li>
<li>不允许重复声明</li>
<li>let 不会在全局声明时创建 window 对象的属性</li>
</ol>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><ol>
<li>具备 let 所具有的上述特性</li>
<li>一旦声明必须立即赋值</li>
<li>声明之后值不可以改变。（对于引用类型的变量而言，指的是它的地址不能发生改变）</li>
</ol>
<h1 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h1><p>既然 const 对于引用类型只能确保地址不变，那么怎样才能使得声明的引用类型变量上的值无法改变呢？<br>这里我们可以使用 <code>Object.freeze()</code> 方法递归解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFreeze = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            myFreeze(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 的爱恨情仇</title>
    <url>/2021/12/11/js-love-and-hate/</url>
    <content><![CDATA[<p>记录一下关于 js 的奇葩事情</p>
<h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>为什么 typeof null 是 object？<br>js在底层存储变量的时候，会在变量机器码的低位 1-3 位存储其类型信息，其中 object 的低 1-3 位是 000。typeof 通过机器码判断类型，而由于 null 的所有机器码均为 0，该机器码和对象一样，因此 null 直接被当作对象来看待。这个 bug 的改动可能会牵涉到非常多的其他内容变更，所以一直没有被改，因为它的改动很可能会引发更多的其它 bug。</p>
<h1 id="除以-0"><a href="#除以-0" class="headerlink" title="除以 0"></a>除以 0</h1><p>js 里面 0 居然是可以当除数的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> / +<span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span>; <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<h1 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h1><p>如图，记录下这一刻。<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/201438.jpg"><br>2021 年 12 月 15 日，leetcode 提交连续 WA 了无数次。最后才知道原来 js 里面 isNaN 判断空格也是 false。</p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title>将数组分成和相等的三部分</title>
    <url>/2021/12/11/parse-the-array-to-three-equal-parts/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a><br>解法分析：前面部分的思路都很简单，主要说一下最后一行代码为什么要写 &gt;= 而不是 ===，这是因为些特别坑的情况，比如 [0, 0, 0, 0]，或者是像 [-1, 1, -1, 1, -1, 1, -1, 1] 这样的情况。可以看出，当和为 0 的时候，可以分成大于三等份的情况必定也可以分成刚好三等份。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canThreePartsEqualSum = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> part = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        count += arr[i];</span><br><span class="line">        <span class="keyword">if</span>(count === part) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>codetop</tag>
      </tags>
  </entry>
  <entry>
    <title>最后还是 nest.js 吗</title>
    <url>/2021/12/10/my-think-of-nestjs/</url>
    <content><![CDATA[<p>思考和尝试了很久 node 做后端怎样才更方便快捷。首先现在开发肯定要首先 typescript，然后框架方面选择基本也就是 express、koa、egg.js、nest.js、midway.js。一开始我的选择是 nest.js，因为它天然支持 typescript，而且封装程度较高，使用也很方便。但是感觉自己如果要去了解它里面的原理的话难度比较大。出于想要了解原理的目的，我又转向了 koa，因为 koa 的代码是出了名的简短精悍。然后在一晚上的尝试以后， sequelize-typescript 出现了一个不知道缘由的 bug，表无法自动创建。然后我又换成了 typeorm，typeorm 使用起来真的是非常方便。不过这一整套操作下来，安装各种包以及相对应的 @types 包，我又开始怀念起来 nest.js 那种开箱即用的感觉了。尤其是它的命令行配置，以及跟 class-validator 的完美融合使用起来确实是太方便了。总而言之，反反复复思考了很久，最后决定下来了，下次做项目后端还是用 nest.js 吧。</p>
]]></content>
      <tags>
        <tag>闲聊</tag>
        <tag>nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title>instanceof 详解</title>
    <url>/2021/12/10/instanceof/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://www.nowcoder.com/practice/a1169935fd6145899f953ba8fbccb585">https://www.nowcoder.com/practice/a1169935fd6145899f953ba8fbccb585</a></p>
<h1 id="instanceof-用处"><a href="#instanceof-用处" class="headerlink" title="instanceof 用处"></a>instanceof 用处</h1><p><code>instanceof</code> 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。</p>
<h1 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h1><p>instanceof 主要的实现原理：只要右边变量的 prototype 在左边变量的原型链上即可。因此， instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype ，如果查找失败，则会返回 false</p>
<h1 id="instanceof-实现"><a href="#instanceof-实现" class="headerlink" title="instanceof 实现"></a>instanceof 实现</h1><p>过程：</p>
<ol>
<li><p> 获取左边变量的隐式原型（即：<code>__ proto __</code> ,可通过 <code>Object.getPrototypeOf()</code> 获取）</p>
</li>
<li><p>获取右边变量的显示原型（即：<code>prototype</code>）</p>
</li>
<li><p>进行判断，比较 leftVal. __ proto __ . __ proto __ ……  === rightVal.prototype，相等则返回 true，否则返回 false</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leftProto = <span class="built_in">Object</span>.getPrototypeOf(left); <span class="comment">// 左边隐式原型</span></span><br><span class="line">    <span class="keyword">const</span> rightProto = right.prototype; <span class="comment">// 右边显示原型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在左边的原型链上查找</span></span><br><span class="line">    <span class="keyword">while</span>(leftProto !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(leftProto === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftProto = <span class="built_in">Object</span>.getPrototypeOf(leftProto);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：公众号前端点线面</p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平化</title>
    <url>/2021/12/10/array-flaten/</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://www.nowcoder.com/practice/5d7e0cf4634344c98e6ae4eaa2336bed">https://www.nowcoder.com/practice/5d7e0cf4634344c98e6ae4eaa2336bed</a></p>
<p>今天来总结一下数组扁平化的题目。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol>
<li>遍历：for、forEach、reduce</li>
<li>判断元素是否是数组类型：instanceof、Object.prototype.toString、Array.isArray</li>
<li>递归</li>
</ol>
<h1 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]], <span class="number">5</span>, <span class="string">&quot;string&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            res = res.concat(flat(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="reduce-实现-flat"><a href="#reduce-实现-flat" class="headerlink" title="reduce 实现 flat"></a>reduce 实现 flat</h1><p>使用 reduce 展开一层</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.concat(cur), []);</span><br></pre></td></tr></table></figure>

<p>reduce 实现  flat</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flat(cur) : cur);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展运算符和-some-实现-flat"><a href="#扩展运算符和-some-实现-flat" class="headerlink" title="扩展运算符和 some 实现 flat"></a>扩展运算符和 some 实现 flat</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文章：<br><a href="https://juejin.cn/post/6844904025993773063">https://juejin.cn/post/6844904025993773063</a><br><a href="https://blog.csdn.net/qq_41805715/article/details/101232148">https://blog.csdn.net/qq_41805715/article/details/101232148</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript 类型保护</title>
    <url>/2021/12/09/type-protection/</url>
    <content><![CDATA[<h1 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h1><p><code>typeof</code> 类型保护用于判断变量是哪种原始类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">param: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原本是联合类型，由于应用了 typeof，后面作用域的 param 类型就确定了。</span></span><br><span class="line">fn(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 11</span></span><br><span class="line">fn(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>同理还有 instance 保护。</p>
<h1 id="自定义类型保护-is"><a href="#自定义类型保护-is" class="headerlink" title="自定义类型保护 is"></a>自定义类型保护 is</h1><p><code>typeof</code> 和 <code>instanceof</code> 类型保护能够满足一般场景，对于一些更加特殊的，可以通过自定义类型保护来对应类型，比如我们自己定义一个请求参数的接口类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> RequestParams &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">  onSuccess?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onFailed?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidRequestParams</span>(<span class="params">request: <span class="built_in">any</span></span>): <span class="title">request</span> <span class="title">is</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request &amp;&amp; request.url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> request;</span><br><span class="line"><span class="comment">// 检测客户端发送过来的参数</span></span><br><span class="line"><span class="keyword">if</span> (isValidRequestParams(requst)) &#123;</span><br><span class="line">  request.url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面通过判断，我们需要手动告诉编译器通过 <code>isValidRequestParams</code> 的判断以后则 <code>request</code> 就是 <code>RequestParams</code> 类型的参数，编译器通过类型谓词 <code>parameterName is Type</code> 得知，<code>isValidRequestParams</code> 返回了 <code>true</code> 则 <code>request</code> 就是 <code>RequestParams</code> 类型。</p>
<p>参考资料：<br><a href="https://tsejx.github.io/typescript-guidebook/syntax/advanced/type-guards">https://tsejx.github.io/typescript-guidebook/syntax/advanced/type-guards</a></p>
]]></content>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 lighthouse 与网页性能测试</title>
    <url>/2021/12/02/qian-tan-lighthouse/</url>
    <content><![CDATA[<p>今天在写人机交互课程的实验报告，复习了一下之前学到的 web 性能分析的方法，然后突发奇想也给我的网页做了个性能测试，当然结果很不乐观（</p>
<h1 id="网页性能分析的重要性"><a href="#网页性能分析的重要性" class="headerlink" title="网页性能分析的重要性"></a>网页性能分析的重要性</h1><p>简单来说，一方面，提高用户体验；另一方面，提高网页的 SEO 排名。</p>
<h1 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/lighthouse.jpg"></p>
<p>先来看整体的分析情况，Performance 是 61 分，SEO 是 97 分。</p>
<p>性能只能说很不理想，但是可惜的是我没有在新建博客的第一时间就先测一下，以至于我不太清楚影响性能的是 hexo + next 本身的问题，还是因为我后来做的美化导致的。另一方面 hexo 是模板建站，我对于里面的源码基本毫不了解，想要优化也不知道从何做起。总之先来看看这 6 个指标吧。</p>
<h1 id="lighthouse-分析网页的六大指标"><a href="#lighthouse-分析网页的六大指标" class="headerlink" title="lighthouse 分析网页的六大指标"></a>lighthouse 分析网页的六大指标</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/115537.jpg"></p>
<p>简单介绍一下这 6 个指标：</p>
<h2 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h2><p>FCP（First Content Paint），即首次内容绘制，是指浏览器从响应用户输入网络地址，在页面首次绘制文本，图片（包括背景图）、非白色的 canvas 或者 svg 之间的这段时间。以往的话，一般还会提到像 FP（First Paint）、FMP（First Meaning Paint）这两个概念，不过现在已经被 lighthouse 废弃了，FP 指标可以通过 Performance 获取。</p>
<h2 id="TTI"><a href="#TTI" class="headerlink" title="TTI"></a>TTI</h2><p>TTI（Time to Interactive），即可交互时间，指的是网页第一次达到可以交互状态的时间，可交互状态的 UI 组件可以交互，而且页面已经达到了相对稳定流畅的程度。</p>
<p>说到 TTI 一般还会提到 <strong>RAIL</strong> 性能模型，包含四个指标，分别是 Response （响应）、Animation（动画）、Idle（空置状态）和 Load（加载）。</p>
<ul>
<li><p>Response：如果用户点击了一个按钮，你需要保证在用户察觉出延迟之前就得到反馈。只要有输入，这个原则就适用。如果没有在合理的时窗内完成响应，，用户就会察觉到这个延迟，一般而言在这个时间会被定为 100 毫秒。另外，如果用户等待时间可能超出 500ms 的话，需要加上 loading 动画来缓解用户的紧张焦虑。</p>
</li>
<li><p>Animation：如果动画帧率发生变化，用户很可能会注意到。一般而言，web 性能优化的目标是达到每秒生成 60 帧。谈到 Animation，就会想起浏览器的渲染流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/2011110316263715.png"></p>
<p>一般来说渲染流程会被分为这四步，明天的主要笔记内容大概会与此相关；今天主要谈 web 性能测试，就先不细说这部分了。</p>
</li>
<li><p>Idle：可以利用空闲的时间来完成被推迟了的工作。例如，尽可能减少预加载数据，然后利用空闲时间加载剩余的数据。</p>
</li>
<li><p>Load：最终目标是能够在 1000 毫秒以内呈现页面内容，这方面涉及到关键路径的优化问题，我也放到明天再谈。注意这里 1s 内并不需要渲染出所有的页面内容，可以把还未完成的任务留到空闲时间继续完成。</p>
</li>
</ul>
<h2 id="SI"><a href="#SI" class="headerlink" title="SI"></a>SI</h2><p>SI（Speed Index），即首屏时间，代表页面内容渲染所消耗的时间。优化 Speed Index 一般从两方面入手：优化内容效率和优化关键渲染路径。SI 低于 4s 则表示页面加载速度较优。</p>
<h2 id="TBT"><a href="#TBT" class="headerlink" title="TBT"></a>TBT</h2><p>TBT（Total Blocking Time）是衡量用户事件响应的指标。TBT会统计在FCP和TTI时间之间，主线程被阻塞的时间总和。当主线程被阻塞超过 50ms 导致用户事件无法响应，这样的阻塞时长就会被统计到TBT中。TBT越小说明页面能够更好的快速响应用户事件。</p>
<h2 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h2><p>LCP（Largest Content Paintful）是一个页面加载时长的技术指标，用于表示当前页面中占比最大的内容显示出来的时间点。它可以代表当前页面主要内容展示的时间。LCP低于 2.5s 则表示页面加载速度较优。</p>
<h2 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h2><p>CLS（Cumulative Layout Shift）是一个衡量页面内容是否稳定的指标，CLS会将页面加载过程中非预期的页面布局的累积。CLS的分数越低，表明页面的布局稳定性越高，通常低于0.1表示页面稳定性良好。</p>
<h1 id="lighthouse-的优势"><a href="#lighthouse-的优势" class="headerlink" title="lighthouse 的优势"></a>lighthouse 的优势</h1><p>lighthouse 在指出性能不足之处的时候，一般还会具体指出哪些地方可以进行优化，例如这次分析，</p>
<p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/125840.jpg"></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>接下来我先考虑的是要把之前鼠标的交互动画减少一些，然后想办法压缩一下静态资源。去除无用 CSS 和 JS 稍微有些难办，因为里面的代码对我来说就像一个黑盒一样，我也没有足够的课余时间去阅读源码。</p>
<p>参考文章：<br><a href="https://www.cnblogs.com/frank-link/p/15243695.html">https://www.cnblogs.com/frank-link/p/15243695.html</a><br><a href="https://www.cnblogs.com/loveyt/p/13582359.html">https://www.cnblogs.com/loveyt/p/13582359.html</a><br><a href="https://blog.csdn.net/m0_37411791/article/details/106394219">https://blog.csdn.net/m0_37411791/article/details/106394219</a><br><a href="https://zhuanlan.zhihu.com/p/20276064">https://zhuanlan.zhihu.com/p/20276064</a></p>
]]></content>
      <tags>
        <tag>测试</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 美化记录</title>
    <url>/2021/12/01/hexo-prettier/</url>
    <content><![CDATA[<p>搞了一天，遇到了不少的奇葩 bug，这次 hexo 建站目前算是暂时完结。<br>记录一下自己做了哪些优化：</p>
<ul>
<li>添加看板娘</li>
<li>添加鼠标点击爱心特效</li>
<li>添加鼠标点击爆炸特效</li>
<li>添加头像 &amp; 头像旋转功能</li>
<li>添加 fork me on github</li>
<li>添加 RSS</li>
<li>更换字体为思源宋体</li>
<li>修改文章内链接文本样式</li>
<li>修改文章底部的标签样式</li>
<li>在每篇文章末尾添加本文结束标记</li>
<li>通过 leancloud &amp; valine 加上了网站的阅读量功能以及评论功能</li>
<li>实现文章字数统计功能</li>
<li>实现全站总字数统计功能</li>
<li>在文章底部增加版权信息</li>
<li>添加博文置顶功能</li>
<li>修改网站 favicon 图标</li>
<li>添加侧边栏 github 图标</li>
<li>添加了本地搜索功能</li>
<li>最后通过 picgo、jsDelivr 和 github 仓库搭建了一个简易的博客图床</li>
<li>其实还添加了一个动态的背景效果，本地运行没问题，但是部署上去就没有了，尚待解决此bug</li>
</ul>
<p>参考文章：<br><a href="https://www.jianshu.com/p/f054333ac9e6">https://www.jianshu.com/p/f054333ac9e6</a><br><a href="https://www.heson10.com/archives/">https://www.heson10.com/archives/</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>希望实现一个很理想的目标</title>
    <url>/2021/11/30/my-goal/</url>
    <content><![CDATA[<p>希望从今天开始，每天都写一篇小日记记录一下当天新学到的或者复习的知识，包括但不限于计算机基础、Vue、React、前端三件套、浏览器基础、web性能优化、node.js。先定个小目标，坚持 100 天，希望可以持续下去。首先要熬过这段满是大作业和考试的期末周。总是感觉我现在的知识储备还不足以去应对面试，希望能通过记录笔记让我的知识体系变得更加系统。首先第一步就是要把博客搭建好，美化好，之前使用过 Next.js 搭建了一个博客，但是总觉得不太好看，后来想了想其实博客本身更多的还是一个记录自己学习经历的东西，所以也许简约一些反而更好，所以最后决定用 hexo 来搭建这个博客。</p>
]]></content>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2021/11/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
