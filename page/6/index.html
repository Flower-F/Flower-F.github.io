<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"flower-f.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一个算法学不好的前端爱好者博客"><meta property="og:type" content="website"><meta property="og:title" content="My Front End Blog"><meta property="og:url" content="https://flower-f.github.io/page/6/index.html"><meta property="og:site_name" content="My Front End Blog"><meta property="og:description" content="一个算法学不好的前端爱好者博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Flower F"><meta property="article:tag" content="前端 程序员 代码 学习 分享 bug"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://flower-f.github.io/page/6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>My Front End Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="My Front End Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Flower-F" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><div class="bg_content"><canvas id="canvas"></canvas></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">My Front End Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">From Flower-F</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时光轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/06/closure/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/06/closure/" class="post-title-link" itemprop="url">js 闭包详解（译）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-06 16:43:42" itemprop="dateCreated datePublished" datetime="2022-01-06T16:43:42+08:00">2022-01-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2022/01/06/closure/" class="post-meta-item leancloud_visitors" data-flag-title="js 闭包详解（译）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/06/closure/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/06/closure/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是一个可以访问外部函数作用域的函数，即便外部函数已经运行完成。这意味着闭包可以记住并访问其外部函数的变量和参数，即使在函数完成之后也是如此。<br>在深入闭包之前，我们首先需要理解词法作用域。</p><h1 id="什么是词法作用域"><a href="#什么是词法作用域" class="headerlink" title="什么是词法作用域"></a>什么是词法作用域</h1><p>Javascript 词法作用域是指我们可以获取源代码中变量、函数、对象的物理位置。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="string">&#x27;inner&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(c);   <span class="comment">// prints &#x27;inner&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(b);   <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);   <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// prints &#x27;global&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">// prints &#x27;outer&#x27;</span></span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a);  </span><br></pre></td></tr></table></figure><p>此处函数 <code>inner</code> 可以获取它自己作用域、<code>outer</code> 函数作用域、全局作用域中的变量；<code>outer</code> 函数可以获取它自己作用域、全局作用域中的变量。</p><h1 id="闭包的具体实例"><a href="#闭包的具体实例" class="headerlink" title="闭包的具体实例"></a>闭包的具体实例</h1><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们调用了 <code>person</code> 函数，它会返回内部的函数 <code>displayName</code> 并把这个内部函数存储在变量 <code>peter</code> 中。当我们调用函数 <code>peter</code> 时，实际上也就是在调用函数 <code>displayName</code>，因此 console 结果为 Peter。</p><p>但是在函数 <code>displayName</code> 里面并不存在一个叫 <code>name</code> 的变量，也就意味着这个函数可以以某种方式获取它外部的函数 <code>person</code> 中的值，甚至在 <code>person</code> 函数返回之后。所以 <code>displayName</code> 函数实际上就是一个闭包。</p><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(count());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这次我们把一个通过 <code>getCounter</code> 返回的匿名函数存储在一个叫做 <code>count</code> 的变量中。因为 <code>count</code> 函数是一个闭包，它可以通过函数 <code>getCounter</code> 获取变量 <code>counter</code> 的值，即便是在 <code>getCounter</code> 函数已经返回之后。</p><p><strong>这里我们需要注意的是，变量 <code>counter</code> 在每次调用时，并没有重置为 0。</strong>这似乎有悖我们之前对函数的认知。<br>这是因为每次调用函数 <code>count</code> 的时候，虽然都会创建一个 <code>count</code> 的新的函数作用域，但是对于函数 <code>getCounter</code> 始终只存在一个作用域，而 <code>counter</code> 变量是在 <code>getCounter</code> 的作用域中定义的，所以每次我们调用函数 <code>count</code> 的时候，计数会递增，而不是重置为 0。</p><h1 id="闭包的工作原理"><a href="#闭包的工作原理" class="headerlink" title="闭包的工作原理"></a>闭包的工作原理</h1><p>要想清楚地理解闭包的工作原理，我们需要首先理解 Javascript 中的两个重要概念：</p><ul><li>执行上下文</li><li>词法环境</li></ul><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>简单来说，执行上下文是关于 Javascript 代码解析和执行的环境的抽象概念。JavaScript 中运行任何的代码都是在执行上下文中运行的。</p><p>因为 Javascript 是单线程语言，所以一次只能有一个正在运行的执行上下文，它由一个被称为执行栈或调用栈的数据结构管理。</p><p>当前运行的执行上下文将始终位于栈顶，并且当当前函数运行完成时，对应的执行上下文会从栈顶弹出，并将控制权移交给下一个执行上下文。</p><p>请看例子：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106201705.png"></p><p>当这段代码运行时，Javascript 引擎会创建一个全局执行上下文来运行全局代码，而当遇到函数 <code>first</code> 时，它会为 <code>first</code> 函数创建一个新的执行上下文，并将其压入栈内。</p><p>执行栈的图示就像这样：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106201922.png"></p><p>当 <code>first</code> 函数执行完成时，它的执行上下文会从执行栈中弹出，然后控制权移交给它下面的执行上下文，也就是全局上下文。</p><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>每当 Javascript 引擎为全局代码或者某个函数创建一个新的执行上下文的时候，它同时也会创建一个新的词法环境，用于存储函数执行过程中出现的变量。</p><p>词法环境是一个类似 <code>(标识符, 变量)</code> 的映射数据结构，这里的标识符具体指变量名或者函数名，而变量指的是对象的引用，包括它的函数类型或者初始值。</p><p>每一个词法环境有三个组件：</p><ul><li>环境记录器：环境记录器用于存储变量或函数声明的实际位置</li><li>一个对外部环境的引用：外部引用意味着它可以访问它外部（父级）的词法环境</li><li>this 的绑定</li></ul><p>词法环境可以被抽象地表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        &lt;identifier&gt;: &lt;value&gt;,</span><br><span class="line">        &lt;identifier&gt;: &lt;value&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Reference to the parent lexical environment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下面这段代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">25</span>;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Inside global execution context&#x27;</span>);</span><br></pre></td></tr></table></figure><p>全局作用域的词法环境如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">globalLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        a: &#x27;Hello World!&#x27;,</span><br><span class="line">        first: &lt;reference to function object&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>first</code> 函数的词法环境如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        b: 25,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的外部词法环境被设置为全局词法环境，因为该函数被源代码中的全局作用域包围。</p><p>注意：当函数执行完成时，它的执行上下文将从执行栈中弹出，但是它的词法环境<strong>不一定</strong>从内存中删除，这取决于该词法环境是否被它外部词法环境属性中的任意其它的词法环境所引用。</p><h1 id="结合实例来看闭包的工作原理"><a href="#结合实例来看闭包的工作原理" class="headerlink" title="结合实例来看闭包的工作原理"></a>结合实例来看闭包的工作原理</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Peter&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peter = person();</span><br><span class="line">peter(); <span class="comment">// prints &#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure><p>当 <code>person</code> 函数执行的时候，Javascript 引擎会为这个函数创建一个新的<strong>执行上下文</strong>和<strong>词法环境</strong>。在这个函数执行完成后，它会返回 <code>displayName</code> 函数然后将它赋值给变量 <code>peter</code>。<br>词法环境如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        name: &#x27;Peter&#x27;,</span><br><span class="line">        displayName: &lt;displayName function reference&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数 <code>person</code> 执行完成之后，执行上下文会从执行栈中弹出。但是它的词法环境依然在内存中，因为它的词法环境被它内部的 <code>displayName</code> 函数的词法环境引用了。所以它的变量在内存中依然可以获取。</p><p><strong>简单来说就是，执行上下文删除了，但是词法环境还在。</strong>（译者注）</p><p>当 <code>peter</code> 函数（实际上是对 <code>displayName</code> 函数的引用）执行时，JavaScript 引擎为该函数创建一个新的执行上下文和词法环境。对应的词法环境如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">displayNameLexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;personLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>displayName</code> 函数中没有变量，所以它的环境记录器将为空。在执行此函数期间，JavaScript 引擎将尝试在函数的词法环境中查找变量 <code>name</code>。</p><p>而在 <code>displayName</code> 函数的词法环境中没有变量 <code>name</code>，所以它会去外部词法环境中找，也就是还在内存中的 <code>person</code> 函数的词法环境。JavaScript 引擎查找到了变量 <code>name</code> 后，将其打印到控制台。</p><p>原文：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda">https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/06/execution-context/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/06/execution-context/" class="post-title-link" itemprop="url">js 执行上下文详解（译）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-06 12:46:33" itemprop="dateCreated datePublished" datetime="2022-01-06T12:46:33+08:00">2022-01-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2022/01/06/execution-context/" class="post-meta-item leancloud_visitors" data-flag-title="js 执行上下文详解（译）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/06/execution-context/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/06/execution-context/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.6k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h1><p>简单来说，执行上下文是关于 Javascript 代码解析和执行的<strong>环境</strong>的抽象概念。JavaScript 中运行任何的代码都是在执行上下文中运行的。</p><h1 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h1><ul><li>全局执行上下文：任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个<strong>函数被调用</strong>时, 都会为该函数创建一个新的上下文。每一个函数都有它自己的执行上下文，但它是在函数被调用的时候创建的。函数执行上下文可以有任意多个。</li><li>eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但 JavaScript 开发者并不经常使用 eval，所以此处不再赘述。</li></ul><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈，也就是调用栈，它用来存储代码运行时创建的所有执行上下文。本质上它就是数据结构中所说的栈，满足先进后出。<br>当 JavaScript 引擎第一次读取你的脚本时，它会创建一个全局执行上下文并将其压入执行栈；每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈。<br>JavaScript 引擎会优先运行执行上下文位于栈顶的函数。当该函数运行结束时，其对应的执行上下文会从栈中弹出，上下文的控制权将被移到当前执行栈的下一个执行上下文。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">    second();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Inside Global Execution Context&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220106131015.png"></p><ul><li>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈</li><li>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制权移交给下一个执行上下文，即 <code>first()</code> 函数的执行上下文</li><li>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，上下文控制权会被移交给全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文</li></ul><h1 id="执行上下文是如何创建的"><a href="#执行上下文是如何创建的" class="headerlink" title="执行上下文是如何创建的"></a>执行上下文是如何创建的</h1><p>创建执行上下文有两个阶段：</p><ul><li>创建阶段</li><li>执行阶段</li></ul><h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>在创建阶段创建执行上下文。在创建阶段会发生以下情况：</p><ol><li>创建词法环境组件</li><li>创建变量环境组件</li></ol><p>我们可以将其抽象表示为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">    LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">    VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>词法环境是用于保存 <code>标识符-变量</code> 的映射的结构。这里标识符是指变量/函数的名称，变量是对实际对象（包括函数对象和数组对象）或基本类型的引用。</p><p>简而言之，<strong>词法环境是存储变量和对象引用的地方</strong>。</p><p>根据官方的 ES6 文档，一个词法环境由<strong>环境记录器</strong>和一个可能为空的<strong>对于外部环境的引用</strong>组成。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">40</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的词法环境为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    b: 40,</span><br><span class="line">    foo: &lt;ref. to foo function&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个词法环境有三个组件：</p><ul><li>环境记录器</li><li>一个对外部环境的引用</li><li>this 的绑定</li></ul><h3 id="环境记录器"><a href="#环境记录器" class="headerlink" title="环境记录器"></a>环境记录器</h3><p>环境记录用于在词法环境中存储变量和函数声明的位置。<br>环境记录器有两种类型：</p><ul><li>声明式环境记录器：顾名思义，它存储变量和函数声明。<strong>函数代码</strong>的词法环境包含声明性环境记录</li><li>对象环境记录器：<strong>全局代码</strong>的词法环境包含一个对象环境记录器。除了变量和函数声明外，对象环境记录器还存储全局对象 window。因此，对于每个绑定对象的属性（对于浏览器，它包含浏览器提供给 window 的属性和方法），将会创建一条新的记录</li></ul><p>注意：对于函数代码，环境记录器还包含一个 arguments 对象。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// argument object</span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="对于外部环境的引用"><a href="#对于外部环境的引用" class="headerlink" title="对于外部环境的引用"></a>对于外部环境的引用</h3><p>对外部环境的引用意味着它可以访问外部的词法环境。这意味着，如果是当前词法环境中找不到的变量，JavaScript 引擎可以在外部环境中查找这些变量。</p><h3 id="this-的绑定"><a href="#this-的绑定" class="headerlink" title="this 的绑定"></a>this 的绑定</h3><p>在全局执行上下文中，this 的值引用全局对象。（在浏览器中，这指的是窗口对象）<br>在函数执行上下文中，其值取决于函数的调用方式。如果它由对象的引用调用，则此值将设置为该对象，否则，此值将设置为全局对象或 undefined（严格模式）。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;peter&#x27;</span>,</span><br><span class="line">    <span class="attr">birthYear</span>: <span class="number">1994</span>,</span><br><span class="line">    <span class="attr">calcAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2018</span> - <span class="built_in">this</span>.birthYear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.calcAge(); </span><br><span class="line"><span class="comment">// &#x27;this&#x27; refers to &#x27;person&#x27;, because &#x27;calcAge&#x27; was called with //&#x27;person&#x27; object reference</span></span><br><span class="line"><span class="keyword">const</span> calculateAge = person.calcAge;</span><br><span class="line">calculateAge();</span><br><span class="line"><span class="comment">// &#x27;this&#x27; refers to the global window object, because no object reference was given</span></span><br></pre></td></tr></table></figure><p>词法环境大概如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">                // Identifier bindings go here</span><br><span class="line">            &#125;</span><br><span class="line">            outer: &lt;null&gt;,</span><br><span class="line">            this: &lt;global object&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FunctionExectionContext = &#123;</span><br><span class="line">        LexicalEnvironment: &#123;</span><br><span class="line">            EnvironmentRecord: &#123;</span><br><span class="line">                Type: &quot;Declarative&quot;,</span><br><span class="line">                // Identifier bindings go here</span><br><span class="line">            &#125;</span><br><span class="line">            outer: &lt;Global or outer function environment reference&gt;,</span><br><span class="line">            this: &lt;depends on how function is called&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h2><p><strong>它也是一个词法环境</strong>，其环境记录器保存在此执行上下文中由 VariableStatements 创建的绑定。<br>因为变量环境也是一个词法环境，所以它具有上面定义的词法环境的所有属性和组件。<br>在 ES6 中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量（let 和 const）绑定，而后者仅用于存储变量（var）绑定。</p><h1 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h1><p>在这个阶段，所有的变量赋值都完成了，代码最终会被执行。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>当上面的代码被执行时，Javascript 引擎会创建一个全局执行上下文来执行全局代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            a: &lt; uninitialized &gt;,</span><br><span class="line">            b: &lt; uninitialized &gt;,</span><br><span class="line">            multiply: &lt; func &gt;</span><br><span class="line">        &#125;</span><br><span class="line">        outer: &lt;null&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            c: undefined,</span><br><span class="line">        &#125;</span><br><span class="line">        outer: &lt;null&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数 <code>multiply(20, 30)</code> 被调用时，一个新的函数执行上下文会被创建来执行函数代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            g: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，执行上下文将经历执行阶段，也就是要完成对函数内变量的赋值。（此处指对变量 g 的赋值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,</span><br><span class="line">            // Identifier bindings go here</span><br><span class="line">            g: 20</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">        ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数执行完成后，返回值会被存储在变量 c 之中。所以全局的词法环境会被更新。最终，全局的代码被执行完成，程序也运行完成。</p><p>注意：你也许注意到了，let 和 const 定义的变量在创建阶段没有任何赋值操作，但是 var 定义的变量被赋值为了 undefined。这也就解释了为什么当你想获取已声明但未定义的变量时，var 声明的变量会得到 undefined，而 let 声明的变量会显示 undeclared。这也就是我们所谓的变量提升。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，我们讨论了 JavaScript 程序内部的执行机制。虽然学习这些概念并不是成为一名出色的 JavaScript 开发人员的必要条件，但对上述概念有一个良好的理解将有助于您更轻松、更深入地理解其他概念，如变量提升、作用域和闭包。</p><p>原文：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/06/js-knowledge-list/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/06/js-knowledge-list/" class="post-title-link" itemprop="url">js 常见知识清单</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-06 12:16:32" itemprop="dateCreated datePublished" datetime="2022-01-06T12:16:32+08:00">2022-01-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-09 22:25:57" itemprop="dateModified" datetime="2022-03-09T22:25:57+08:00">2022-03-09</time> </span><span id="/2022/01/06/js-knowledge-list/" class="post-meta-item leancloud_visitors" data-flag-title="js 常见知识清单" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/06/js-knowledge-list/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/06/js-knowledge-list/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>346</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>见 <a href="https://flower-f.github.io/2021/12/11/js-data-types/">js 数据类型</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>相关知识：词法环境、调用栈<br>见 <a href="https://flower-f.github.io/2022/01/06/execution-context/">js 执行上下文详解（译）</a></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>相关知识：词法作用域、执行上下文、词法环境<br>见 <a href="https://flower-f.github.io/2022/01/06/closure/">js 闭包详解（译）</a></p><h1 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h1><p>相关知识：词法环境<br>见 <a href="https://flower-f.github.io/2022/01/10/js-scope-and-scope-chain/">js 作用域和作用域链详解（译）</a></p><h1 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h1><p>见 <a href="https://flower-f.github.io/2021/12/13/js-traversal/">js 遍历对象</a></p><h1 id="var-amp-const-amp-let"><a href="#var-amp-const-amp-let" class="headerlink" title="var &amp; const &amp; let"></a>var &amp; const &amp; let</h1><p>见 <a href="https://flower-f.github.io/2021/12/11/var-let-const/">var、let、const 辨析</a></p><h1 id="bind-amp-apply-amp-call"><a href="#bind-amp-apply-amp-call" class="headerlink" title="bind &amp; apply &amp; call"></a>bind &amp; apply &amp; call</h1><p>见 <a href="https://flower-f.github.io/2022/01/10/call-apply-bind">call、apply、bind辨析（译）</a> &amp; <a href="https://flower-f.github.io/2022/01/10/hand-write-apply-call-bind/">手写实现 call、apply、bind</a></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>见 <a href="https://flower-f.github.io/2022/01/10/js-promise/">Promise 详解（译）</a> &amp; <a href="https://flower-f.github.io/2022/01/11/hand-write-promise/">手写 Promise</a></p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>见 <a href="https://flower-f.github.io/2021/12/10/instanceof/">instanceof 详解</a></p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/new/">new 详解</a></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/js-inherit/">js 继承</a></p><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>见 <a href="https://flower-f.github.io/2022/01/11/js-event/">js 事件机制</a></p><h1 id="异步工作原理"><a href="#异步工作原理" class="headerlink" title="异步工作原理"></a>异步工作原理</h1><p>相关知识：执行上下文、词法环境、事件循环<br>见 <a href="https://flower-f.github.io/2022/01/10/js-asynchronous/">js 异步原理详解（译）</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/02/software-artifact-review/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/02/software-artifact-review/" class="post-title-link" itemprop="url">软件架构复习提纲</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-02 18:40:03" itemprop="dateCreated datePublished" datetime="2022-01-02T18:40:03+08:00">2022-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2022/01/02/software-artifact-review/" class="post-meta-item leancloud_visitors" data-flag-title="软件架构复习提纲" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/02/software-artifact-review/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/02/software-artifact-review/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h1><p>软件架构是一组用于推理系统的结构，包含了软件元素、它们之间的关系以及他们的属性</p><h1 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h1><ul><li>架构影响系统的<strong>驱动质量属性</strong></li><li>可以帮助开发者随着系统发展而<strong>推理和管理变更</strong></li><li>可以实现对系统质量的<strong>早期预测</strong></li><li>架构促进<strong>利益相关者间的沟通</strong></li><li>架构是最早产生的设计决策的载体，所以它也是最基础的、最难以改变的<strong>设计决策的载体</strong></li><li>架构为后续的实现定义了一系列的<strong>约束</strong></li><li>架构决定了<strong>组织结构</strong>，反之亦然</li><li>架构提供了<strong>进化原型</strong>的基础</li><li>架构可以帮助架构师和项目经理<strong>预估成本和时间</strong></li><li>基于架构的开发<strong>关注组件之间的组合</strong>，而不是简单地关注它们的创建</li><li>架构可以被设计成一个可转换、可复用的模型，构成<strong>产品线的心脏</strong></li><li>通过<strong>限制设计的自由度</strong>，架构引导开发者的创造方向，以减少设计和系统的复杂度</li><li>架构可以作为<strong>培训团队新成员</strong>的基础</li></ul><h1 id="视图、架构和结构的区别与联系"><a href="#视图、架构和结构的区别与联系" class="headerlink" title="视图、架构和结构的区别与联系"></a>视图、架构和结构的区别与联系</h1><ul><li>视图是一组耦合的架构元素的<strong>展示</strong>，它由一组元素和元素间的关系组成</li><li>结构是元素<strong>集合本身</strong></li><li>架构设计结构，<strong>架构将结构的视图文档化</strong></li></ul><h1 id="三类结构"><a href="#三类结构" class="headerlink" title="三类结构"></a>三类结构</h1><h2 id="三类结构回答的问题"><a href="#三类结构回答的问题" class="headerlink" title="三类结构回答的问题"></a>三类结构回答的问题</h2><h3 id="Module-structures"><a href="#Module-structures" class="headerlink" title="Module structures"></a>Module structures</h3><ul><li>What is the primary responsibilities assigned to each module?</li><li>What other software elements is a module allowed to use?</li><li>What other software does it actually use and depend on?</li><li>What modules are related to other modules by generalization or specialization relationships?</li></ul><h3 id="Component-and-connector-structures-回答的问题"><a href="#Component-and-connector-structures-回答的问题" class="headerlink" title="Component-and-connector structures 回答的问题"></a>Component-and-connector structures 回答的问题</h3><ul><li>What are the major executing components and how do they interact at runtime?</li><li>What are the major shared data stores?</li><li>Which parts of the system are replicated?</li><li>How does data progress through the system?</li><li>What parts of the system can run in parallel?</li><li>Can the system’s structure change as it executes and, if so, how?</li></ul><h3 id="Allocation-structures-回答的问题"><a href="#Allocation-structures-回答的问题" class="headerlink" title="Allocation structures 回答的问题"></a>Allocation structures 回答的问题</h3><ul><li>What processor does each software element execute on?</li><li>In what directories or files is each element stored during development, testing, and system building?</li><li>What is the assignment of each software element to development teams?</li></ul><h2 id="Module-structures-模块结构"><a href="#Module-structures-模块结构" class="headerlink" title="Module structures 模块结构"></a>Module structures 模块结构</h2><ul><li>Decomposition structure 分解结构：决定了系统的<strong>可修改性</strong>，以确保可能的变化是局部的</li><li>Uses structure 使用结构：是一种专门的依赖关系，用来<strong>拓展或缩小系统</strong>，创建子系统</li><li>Layered structure 层结构：通过<strong>接口</strong>提供一个有凝聚力的服务集合</li><li>Class structure 类结构：允许<strong>重载</strong>功能</li><li>Data model 数据模型：描述了数据实体及其关系的信息结构</li></ul><h2 id="Component-connector-structures-组件连接件结构"><a href="#Component-connector-structures-组件连接件结构" class="headerlink" title="Component-connector structures 组件连接件结构"></a>Component-connector structures 组件连接件结构</h2><ul><li>Service structure 服务结构：单位服务与其他服务的协调机制</li><li>Concurrency structure 并发结构：确定机会的并行性和资源争夺可能发生的位置</li></ul><h2 id="Allocation-structures-分配结构"><a href="#Allocation-structures-分配结构" class="headerlink" title="Allocation structures 分配结构"></a>Allocation structures 分配结构</h2><ul><li>Deployment structure 部署结构：软件如何被分配给硬件处理和通信，如分布式和并行系统</li><li>Implementation structure 实现结构：显示了软件元素如何在系统的开发、集成和配置控制环境中映射到文件结构中</li><li>Work assignment structure 工作分配结构：分配责任，实施和整合模块给将要执行它的团队</li></ul><h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="架构模式的作用"><a href="#架构模式的作用" class="headerlink" title="架构模式的作用"></a>架构模式的作用</h2><ul><li>架构模式描述了软件系统里的基本的<strong>结构</strong></li><li>架构模式提供一些<strong>预先定义好的子系统</strong>，指定它们的责任，并给出把它们组织在一起的方法</li><li><strong>架构模式建立了背景（context）、问题（problem）和解决方案（solution）间的关系</strong></li></ul><h2 id="常见的架构模式"><a href="#常见的架构模式" class="headerlink" title="常见的架构模式"></a>常见的架构模式</h2><ul><li>分层模式 layered pattern</li><li>数据共享模式 shared-data pattern</li><li>C/S 模式 client-server pattern</li><li>多层模式 multi-tier pattern</li><li>能力中心和平台 competence center and platform</li></ul><h2 id="架构的四大背景"><a href="#架构的四大背景" class="headerlink" title="架构的四大背景"></a>架构的四大背景</h2><ul><li>技术 technical</li><li>项目生命周期 project life cycle</li><li>业务 business</li><li>专业性 professional</li></ul><h2 id="什么会影响架构"><a href="#什么会影响架构" class="headerlink" title="什么会影响架构"></a>什么会影响架构</h2><ul><li>需求</li><li>架构的四大背景</li><li>架构本身会影响未来的架构</li></ul><h2 id="战术-Tactics-与模式-Patterns-的区别"><a href="#战术-Tactics-与模式-Patterns-的区别" class="headerlink" title="战术 Tactics 与模式 Patterns 的区别"></a>战术 Tactics 与模式 Patterns 的区别</h2><ul><li>模式建立在战术之上，一个模式包含很多战术</li><li>模式用于解决一个特定问题，但是同时会给其他质量属性带来负面影响</li></ul><h2 id="模块框架-Module-Pattern"><a href="#模块框架-Module-Pattern" class="headerlink" title="模块框架 Module Pattern"></a>模块框架 Module Pattern</h2><h3 id="Layered-pattern-分层模式"><a href="#Layered-pattern-分层模式" class="headerlink" title="Layered pattern 分层模式"></a>Layered pattern 分层模式</h3><ul><li>context：关系的<strong>分离</strong></li><li>problem：软件在某些情况下需要分离，模块可以单独开发，提高可移植性、可修改性、重用性</li><li>solution：分层模式定义了层（每个层是一组模块），和层与层之间<strong>单向调用</strong>的关系，下一层只能使用上一层提供的服务</li></ul><h2 id="组件-连接件框架-Component-Connector-Pattern"><a href="#组件-连接件框架-Component-Connector-Pattern" class="headerlink" title="组件-连接件框架 Component-Connector Pattern"></a>组件-连接件框架 Component-Connector Pattern</h2><h3 id="Broker-pattern-代理模式"><a href="#Broker-pattern-代理模式" class="headerlink" title="Broker pattern 代理模式"></a>Broker pattern 代理模式</h3><ul><li>context：<strong>分布式</strong>服务之间的交互操作</li><li>problem：如何构造分布式软件，使用户不需要知道供应商的性质和位置，就可以容易地动态改变用户和供应商之间的绑定</li><li>solution：代理模式插入一个称为代理的中介，将服务提供者（服务器）和用户（客户端）分开</li></ul><h3 id="Model-View-Controller-Pattern-MVC-模式"><a href="#Model-View-Controller-Pattern-MVC-模式" class="headerlink" title="Model-View-Controller Pattern MVC 模式"></a>Model-View-Controller Pattern MVC 模式</h3><ul><li>context：从模型分离视图</li><li>problem：如何将用户<strong>界面的功能与应用程序的功能分开</strong>，但是仍然可以响应用户的输入，或者改变应用程序数据。当应用数据改变时，如何创建、维护和协调用户界面的多个视图</li><li>solution：MVC 模式把应用功能分成三种类型的组件</li></ul><h3 id="Pipe-and-Filter-Pattern-管道-过滤器模式"><a href="#Pipe-and-Filter-Pattern-管道-过滤器模式" class="headerlink" title="Pipe and Filter Pattern 管道-过滤器模式"></a>Pipe and Filter Pattern 管道-过滤器模式</h3><ul><li>context：处理<strong>数据流</strong></li><li>problem：一些系统可能被分解为可重用的、松散耦合的组件，这些组件具有简单通用的交互机制</li><li>solution：管道和过滤器模式特征就是数据流连续变换</li></ul><h3 id="Client-Server-Pattern-C-S-模式"><a href="#Client-Server-Pattern-C-S-模式" class="headerlink" title="Client-Server Pattern C/S 模式"></a>Client-Server Pattern C/S 模式</h3><ul><li>context：大量的分布式客户希望访问<strong>共享的资源和服务</strong></li><li>problem：我们希望通过集中控制资源和服务来提高可扩展性和可用性，同时在多台物理服务器上分配资源</li><li>solution：客户端通过请求服务器的服务进行交互，服务器提供一系列的服务</li></ul><h3 id="Peer-to-Peer-Pattern-P2P-模式"><a href="#Peer-to-Peer-Pattern-P2P-模式" class="headerlink" title="Peer-to-Peer Pattern P2P 模式"></a>Peer-to-Peer Pattern P2P 模式</h3><ul><li>context：分布式计算实体被认为是<strong>平等的</strong></li><li>problem：如何将一组平等的分布式计算实体通过公共协议相互连接，使得他们能够以高可用性和可扩展性的组织和共享服务</li><li>solution：在 P2P 模式中，组件直接作为对等点进行交互，所有的对等点都是平等的，没有对等点对系统的健康来说是至关重要的</li></ul><h3 id="Service-Oriented-Architecture-Pattern-面向服务的架构模式（SOA）"><a href="#Service-Oriented-Architecture-Pattern-面向服务的架构模式（SOA）" class="headerlink" title="Service Oriented Architecture Pattern 面向服务的架构模式（SOA）"></a>Service Oriented Architecture Pattern 面向服务的架构模式（SOA）</h3><ul><li>context：许多<strong>服务需要进行互操作</strong>，但是开发者对它们的内部实现没有任何了解</li><li>problem：如何保证在不同的平台上、由不同的语言实现、由不同的组织提供的分布式系统的互操作性</li><li>solution：SOA 模式描述了一个提供或使用服务的分布式组件的集合</li></ul><h3 id="Publish-Subscribe-Pattern-发布-订阅模式"><a href="#Publish-Subscribe-Pattern-发布-订阅模式" class="headerlink" title="Publish-Subscribe Pattern 发布-订阅模式"></a>Publish-Subscribe Pattern 发布-订阅模式</h3><ul><li>context：<strong>数据生产者和消费者的确切数量和性质不是预定的或固定的，他们也不共享数据</strong></li><li>problem：我们如何创建集成机制，支持在生产者和消费者之间传递信息的能力，使得他们不知道彼此的身份甚至不知道彼此的存在</li><li>solution：在发布订阅模式中，组件通过已发布的消息进行交互</li></ul><h3 id="Shared-Data-Pattern-共享数据模式"><a href="#Shared-Data-Pattern-共享数据模式" class="headerlink" title="Shared-Data Pattern 共享数据模式"></a>Shared-Data Pattern 共享数据模式</h3><ul><li>context：各种组件之间需要<strong>共享和操作大量的数据</strong></li><li>problem：系统如何存储和操作数据，并保证可以被多个独立的组件访问</li><li>solution：数据共享模式中，交互主要通过在多个数据存取器和至少一个共享数据存储之间持续的数据交换进行</li></ul><h2 id="分配框架-Allocation-Pattern"><a href="#分配框架-Allocation-Pattern" class="headerlink" title="分配框架 Allocation Pattern"></a>分配框架 Allocation Pattern</h2><h3 id="Map-Reduce-Pattern-映射-规约模式"><a href="#Map-Reduce-Pattern-映射-规约模式" class="headerlink" title="Map-Reduce Pattern 映射-规约模式"></a>Map-Reduce Pattern 映射-规约模式</h3><ul><li>context：需要<strong>快速分析大量数据</strong></li><li>problem：有效地执行大型数据集的分布式并行排序，为程序员指定的分析提供一种简单的方法</li><li>problem：map-reduce 模式需要三个部分：一个负责根据需要<strong>分配数据</strong>的基础设施、一个用于<strong>过滤数据</strong>以检索项目的 map、一个<strong>结合映射结果</strong>的 reduce</li></ul><h3 id="Multi-Tier-Pattern-多层模式"><a href="#Multi-Tier-Pattern-多层模式" class="headerlink" title="Multi-Tier Pattern 多层模式"></a>Multi-Tier Pattern 多层模式</h3><ul><li>context：将一个系统的<strong>基础设施分配到不同的子集</strong></li><li>problem：如何将系统划分为多个独立计算的执行结构</li><li>solution：许多系统的执行结构被组织为一系列组件的逻辑分组，每个组被称为一级</li></ul><h1 id="七个质量属性场景"><a href="#七个质量属性场景" class="headerlink" title="七个质量属性场景"></a>七个质量属性场景</h1><h2 id="质量属性场景的组成"><a href="#质量属性场景的组成" class="headerlink" title="质量属性场景的组成"></a>质量属性场景的组成</h2><ul><li>Source：刺激源，产生刺激的实体，如人、系统等</li><li>Stimulus：刺激，系统做出响应的条件</li><li>Response：响应，系统在被刺激时采取的行动</li><li>Response measure：响应度量，当响应发生时，以某种标准量化该响应</li><li>Environment：环境，刺激发生的特定条件</li><li>Artifact：制品，可以理解为研究的对象</li></ul><h2 id="Availability-可达性"><a href="#Availability-可达性" class="headerlink" title="Availability 可达性"></a>Availability 可达性</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>系统<strong>掩盖或修复错误</strong>的能力，使得一定时间内系统的不可用时间小于特定值</p><h3 id="general-scenario"><a href="#general-scenario" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：系统内部、系统外部</li><li>Stimulus：错误，如疏忽、崩溃、响应错误</li><li>Artifact：处理器、进程</li><li>Environment：正常操作、降级操作（使用更少的特性）</li><li>Response：记录故障；通知用户或系统；根据规则禁止导致错误的源头</li><li>Response measure：系统修复时间、系统可用的时间间隔、系统在降级模式下可用的时间间隔</li></ul><h3 id="concrete-scenario"><a href="#concrete-scenario" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Heartbeat monitor 心跳监控器</li><li>Stimulus：Server unresponsive 服务器无响应</li><li>Artifact：Process 进程</li><li>Environment：Normal operation 正常操作</li><li>Response：Inform operator continue to operate 通知操作者继续操作</li><li>Response Measure：No downtime 没有停机时间</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>The heartbeat monitor determines that the server is nonresponsive during normal operations. The system informs the operator and continues to operate with no downtime<br>心跳监视器确定服务器在正常操作期间无响应。系统通知操作员继续操作，并在<strong>无停机</strong>的情况下继续运行</p><h3 id="战术"><a href="#战术" class="headerlink" title="战术"></a>战术</h3><ul><li>检测错误：ping/echo，monitor，timestamp，sanity checking，condition monitoring，voting，self-test，heartbeat</li><li>修复错误：主动冗余、被动冗余、备份、回滚、阴影、状态重新同步</li><li>防止错误：事务、预测模型、增加能力集</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/150753.jpg"></p><h2 id="Interoperability-互操作性"><a href="#Interoperability-互操作性" class="headerlink" title="Interoperability 互操作性"></a>Interoperability 互操作性</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>两个或以上的系统，在一定的背景下，可以通过<strong>接口</strong>有用地交换有意义的信息</p><h3 id="general-scenario-1"><a href="#general-scenario-1" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：向另一个系统提出互操作请求的系统</li><li>Stimulus：系统之间交换信息的请求</li><li>Artifact：互操作的系统</li><li>Environment：互操作的系统在运行前就知道对方的存在</li><li>Response：互操作引发信息交换</li><li>Response measure：被正确处理的信息交换百分比</li></ul><h3 id="concrete-scenario-1"><a href="#concrete-scenario-1" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Vehicle information system 交通信息系统</li><li>Stimulus：Current location sent 发送当前位置</li><li>Artifact：Traffic monitoring system 交通监控系统</li><li>Environment：Systems known prior to run-time 交通信息系统在运行之前就已经知道交通监控系统的存在</li><li>Response：Traffic monitor combines current location with other information, overlays on google maps, and broadcasts 交通监控器将当前位置与其他信息、谷歌地图上的覆盖和广播结合起来</li><li>Response Measure：Our information included correctly 99.9% of the time 在规定时间内信息被正确处理的百分比达到 99.9%</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>Our vehicle information system sends our current location to the traffic monitoring system. The traffic monitoring system combines our location with other information, overlays this information on a Google Map, and broadcasts it. Our location information is correctly included with a probability of 99.9%<br>交通信息系统发送当前的地址信息给交通监控系统，交通监控系统需要将我们的位置信息和其他信息组合起来，映射到谷歌地图上，并发布结果。我们的位置信息被正确包含的概率将为 99.9%</p><h3 id="战术-1"><a href="#战术-1" class="headerlink" title="战术"></a>战术</h3><ul><li>定位：发现服务</li><li>管理接口：协调接口、定制接口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/151506.jpg"></p><h2 id="Modifiability-可修改性"><a href="#Modifiability-可修改性" class="headerlink" title="Modifiability 可修改性"></a>Modifiability 可修改性</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>在一定时限内，软件能被无副作用修改的难易程度</p><h3 id="general-scenario-2"><a href="#general-scenario-2" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：开发人员</li><li>Stimulus：希望增加、删除、修改功能</li><li>Artifact：用户界面、系统</li><li>Environment：在设计时、构建时、编译时、运行时</li><li>Response：查找需要修改的位置；进行修改而不影响其他功能</li><li>Response measure：该修改需要的成本与时间、该修改对其它功能的影响</li></ul><h3 id="concrete-scenario-2"><a href="#concrete-scenario-2" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Developer 开发者</li><li>Stimulus：Wishes to change the UI 想要改变 UI</li><li>Artifact：Code 代码</li><li>Environment：Design time 设计的时候</li><li>Response：Change made and unit tested 所做的更改和单元测试</li><li>Response Measure：In three hours with no side effects 三小时内完成，且没有副作用</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>The developer wishes to change the user interface by modifying the code at design time. The modifications are made with no side effects within three hours<br>如果开发人员在设计时希望修改代码来更改用户接口，修改可以确保在三小时内完成更改以及单元测试，而且没有副作用</p><h3 id="战术-2"><a href="#战术-2" class="headerlink" title="战术"></a>战术</h3><ul><li>修改模块大小：拆分模块</li><li>增加内聚：增强语义的一致性</li><li>降低耦合：封装、使用中间件</li><li>延迟绑定</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152201.jpg"></p><h2 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance 性能"></a>Performance 性能</h2><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>软件系统满足时间需求的能力</p><h3 id="general-scenario-3"><a href="#general-scenario-3" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：系统内部或外部</li><li>Stimulus：定期事件到达；随机事件到达；偶然事件到达</li><li>Artifact：<strong>系统</strong></li><li>Environment：正常模式、超载模式</li><li>Response：处理事件；改变服务的级别（如从正常模式切换到超载模式）</li><li>Response measure：等待时间、吞吐率</li></ul><h3 id="concrete-scenario-3"><a href="#concrete-scenario-3" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Users 用户</li><li>Stimulus：Initiate transactions 启动交易</li><li>Artifact：System 系统</li><li>Environment：Normal operation 正常模式</li><li>Response：Transactions are processed 交易被处理</li><li>Response Measure：Average latency of two seconds 平均等待时间为 2 秒</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>Users initiate transactions under normal operations. The system processes the transactions with an average latency of two seconds<br>用户在正常操作下启动会话。系统处理事件的平均延迟为 2 秒</p><h3 id="战术-3"><a href="#战术-3" class="headerlink" title="战术"></a>战术</h3><ul><li>控制资源需求：管理采样率、限制事件响应、为事件划分优先级</li><li>管理资源：引入并发、维护多个数据副本、维护多个计算副本、限制任务队列的大小</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152231.jpg"></p><h2 id="Security-安全性"><a href="#Security-安全性" class="headerlink" title="Security 安全性"></a>Security 安全性</h2><h3 id="含义-4"><a href="#含义-4" class="headerlink" title="含义"></a>含义</h3><p>系统保护数据免受未授权访问和能够被授权访问的能力</p><h3 id="general-scenario-4"><a href="#general-scenario-4" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：授权或非授权用户、访问了有限资源或大量资源</li><li>Stimulus：尝试修改数据、尝试访问系统服务</li><li>Artifact：系统服务、系统数据</li><li>Environment：在线或离线、联网或断网</li><li>Response：对用户进行身份验证，允许或阻止用户访问数据或服务</li><li>Response measure：防范成功的概率</li></ul><h3 id="concrete-scenario-4"><a href="#concrete-scenario-4" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Disgruntled employee from remote location 来自远程位置的不满员工</li><li>Stimulus：Attempts to modify pay rate 试图修改工资比率</li><li>Artifact：Data within the system 系统内的数据</li><li>Environment：Normal operations 正常操作</li><li>Response：System maintains audit trails 系统维护审计跟踪</li><li>Response Measure：Correct data is restored within a day and source of tampering identified 在一天内恢复正确的数据，并确定篡改源</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>A disgruntled employee from a remote location attempts to modify the pay rate table during normal operations. The system maintains an audit trail and the correct data is restored within a day<br>一个对工资不满的员工试图在正常操作期间远程修改工资率表。系统将保留审核跟踪，并在一天内恢复正确的数据，确定想做坏事的人是谁</p><h3 id="战术-4"><a href="#战术-4" class="headerlink" title="战术"></a>战术</h3><ul><li>检测攻击：确认消息的完整性、检测消息的延迟</li><li>抵抗攻击：识别参与者、验证参与者、授权参与者、数据加密、限制访问</li><li>对攻击做出反应：撤销访问、锁定计算机、通知参与者</li><li>从攻击中恢复：维护审计追踪、重新存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/152600.jpg"></p><h2 id="Testability-可测试性"><a href="#Testability-可测试性" class="headerlink" title="Testability 可测试性"></a>Testability 可测试性</h2><h3 id="含义-5"><a href="#含义-5" class="headerlink" title="含义"></a>含义</h3><p>软件可以被证明有错误的容易程度</p><h3 id="general-scenario-5"><a href="#general-scenario-5" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：单元测试人员、集成测试人员</li><li>Stimulus：完成了一段功能完整的代码，如类、层</li><li>Artifact：代码片段、完整应用</li><li>Environment：设计时、开发时、编译时、部署时</li><li>Response：准备测试的环境、执行测试并捕获结果</li><li>Response measure：准备测试的时间、执行测试的时间、测试的覆盖率</li></ul><h3 id="concrete-scenario-5"><a href="#concrete-scenario-5" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：Unit tester 单元测试人员</li><li>Stimulus：Code unit completed 一个代码单元被完成</li><li>Artifact：Code unit 一个代码单元</li><li>Environment：Development 开发时</li><li>Response：Results Captured 捕获测试结果</li><li>Response Measure：85% Path Converge in 3 hours 三小时内达到 85% 的路径覆盖率</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>The unit tester completes a code unit during development and performs a test sequence whose results are captured and that gives 85% path coverage within 3 hours of testing<br>单元测试人员在开发过程中完成一个代码单元，并执行一个测试序列，该序列的结果被捕获，并在测试的 3 小时内提供 85% 的路径覆盖率</p><h3 id="战术-5"><a href="#战术-5" class="headerlink" title="战术"></a>战术</h3><ul><li>控制和观察系统状态：接口专用化、本地化状态存储、沙盒</li><li>限制复杂度：控制结构的复杂度、限制非确定性因素</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/153122.jpg"></p><h2 id="Usability-易用性"><a href="#Usability-易用性" class="headerlink" title="Usability 易用性"></a>Usability 易用性</h2><h3 id="含义-6"><a href="#含义-6" class="headerlink" title="含义"></a>含义</h3><p>指用户完成一项任务的容易程度和系统所提供用户支持的种类</p><h3 id="general-scenario-6"><a href="#general-scenario-6" class="headerlink" title="general scenario"></a>general scenario</h3><ul><li>Source：<strong>最终用户</strong></li><li>Stimulus：学习系统特性、学会有效使用系统</li><li>Artifact：<strong>系统</strong></li><li>Environment：运行时、配置时</li><li>Response：上下文相关的帮助系统；撤销操作；取消操作</li><li>Response measure：用户学习时间、用户满意度、用户的操作成功率</li></ul><h3 id="concrete-scenario-6"><a href="#concrete-scenario-6" class="headerlink" title="concrete scenario"></a>concrete scenario</h3><ul><li>Source：User 用户</li><li>Stimulus：Downloads a new application 下载一个新的 App</li><li>Artifact：System 系统</li><li>Environment：Runtime 运行时</li><li>Response：User uses application productively 用户高效地使用应用程序</li><li>Response Measure：Within two miniutes of experimentation 在两分钟的试用时间内</li></ul><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>The user downloads a new application and is using it productively after two minutes of experimentation<br>用户下载一个新的应用程序，并在两分钟的试用后就能有效地使用它</p><h3 id="战术-6"><a href="#战术-6" class="headerlink" title="战术"></a>战术</h3><ul><li>支持用户的方案：取消、撤销、暂停/恢复</li><li>支持系统的方案：维护任务模型、用户模型、系统模型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/153806.jpg"></p><h2 id="X-ability-X-质量属性"><a href="#X-ability-X-质量属性" class="headerlink" title="X-ability X 质量属性"></a>X-ability X 质量属性</h2><h3 id="含义-7"><a href="#含义-7" class="headerlink" title="含义"></a>含义</h3><p>指未列出的的质量属性，如 variability 变异性、 portability 可移植性、scalability 可扩展性、elasticity 弹性、deployability 可部署性、mobility 可移动性、monitorability 可监测性等</p><h1 id="通用质量属性表格"><a href="#通用质量属性表格" class="headerlink" title="通用质量属性表格"></a>通用质量属性表格</h1><table><thead><tr><th align="center"></th><th>avalibility</th><th>testability</th><th>usability</th><th>security</th><th>performance</th><th>modifiability</th></tr></thead><tbody><tr><td align="center">source</td><td>系统内部或外部</td><td>单元测试人员、集成测试人员</td><td>用户</td><td>授权或非授权用户、访问了有限资源或大量资源</td><td>系统内部或外部</td><td>开发人员</td></tr><tr><td align="center">stimulus</td><td>错误，如疏忽、崩溃、响应错误</td><td>完成了一段功能完整的代码，如类、层；完成了整个应用</td><td>学习系统特性、学会有效使用系统</td><td>尝试修改数据、尝试访问系统服务</td><td>定期事件到达、随机事件到达、偶然事件到达</td><td>增加、删除、修改功能</td></tr><tr><td align="center">artifact</td><td>处理器、进程</td><td>代码片段、完整应用</td><td>系统</td><td>系统服务、系统数据</td><td>系统</td><td>用户界面、系统</td></tr><tr><td align="center">environment</td><td>正常操作、降级操作</td><td>设计时、开发时、编译时、部署时</td><td>运行时</td><td>在线或离线、联网或断网</td><td>正常模式 、超载模式</td><td>设计时、构建时、编译时、运行时</td></tr><tr><td align="center">response</td><td>记录故障；通知用户或系统；禁止错误的数据源</td><td>准备测试环境、执行测试并捕获结果</td><td>上下文帮助系统、撤销操作、取消操作</td><td>对用户进行身份验证、允许或拒绝用户访问数据或服务</td><td>处理事件、改变服务的级别</td><td>查找需要修改的位置、对内容进行修改</td></tr><tr><td align="center">response measure</td><td>系统修复时间、系统可用时间间隔、系统在降级模式下的可用时间间隔</td><td>准备测试的时间、执行测试的时间、测试的覆盖率</td><td>用户学习时间、用户满意度、用户的操作成功率</td><td>防范成功的比例</td><td>等待时间、吞吐率</td><td>修改需要的成本、修改对其它功能的影响</td></tr></tbody></table><h1 id="质量属性的建模与分析"><a href="#质量属性的建模与分析" class="headerlink" title="质量属性的建模与分析"></a>质量属性的建模与分析</h1><h2 id="Performance-Modeling-性能建模"><a href="#Performance-Modeling-性能建模" class="headerlink" title="Performance Modeling 性能建模"></a>Performance Modeling 性能建模</h2><ul><li>成本：取决于建模参数，如<ul><li>The frequency of arrivals from outside the system</li><li>The queuing discipline used at the view queue</li><li>The time to process a message within the view</li><li>The number and size of messages that the view sends to the controller</li><li>The bandwidth of the network that connects the view and the controller</li></ul></li><li>作用：估计延迟时间</li><li>对参数的估计越准确，对延迟的预测就越准确</li><li>当延迟很重要和有问题时，这是值得的；当显然有足够的能力来满足需求时，这是不值得的</li></ul><h2 id="Availability-Modeling-可达性建模"><a href="#Availability-Modeling-可达性建模" class="headerlink" title="Availability Modeling 可达性建模"></a>Availability Modeling 可达性建模</h2><ul><li>可达性建模是为了确定组件的<strong>故障率和恢复时间</strong></li><li>Steady-State Availability（实则为平均故障时间占比） 计算公式：<img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/171212.jpg"><ul><li>MTBF is the mean time between failure 平均故障时间</li><li>MTTR refers to the mean time to repair 平均修复时间</li></ul></li><li>三种提高可达性的主流战术<ul><li>主动冗余（热备份）</li><li>被动冗余（暖备份）</li><li>备份（冷备份）</li></ul></li></ul><h1 id="Architecture-in-agile-project-敏捷项目的架构"><a href="#Architecture-in-agile-project-敏捷项目的架构" class="headerlink" title="Architecture in agile project 敏捷项目的架构"></a>Architecture in agile project 敏捷项目的架构</h1><h2 id="什么时候需要敏捷开发"><a href="#什么时候需要敏捷开发" class="headerlink" title="什么时候需要敏捷开发"></a>什么时候需要敏捷开发</h2><ul><li>对涉众更加敏感</li><li>想要更快地开发用户关注的功能</li><li>想在项目生命周期中更多更早地显示项目进展</li></ul><h2 id="敏捷项目架构关注的问题"><a href="#敏捷项目架构关注的问题" class="headerlink" title="敏捷项目架构关注的问题"></a>敏捷项目架构关注的问题</h2><ul><li>应该做多少架构</li><li>应该记录多少架构</li></ul><h2 id="Sweet-Point-甜蜜点"><a href="#Sweet-Point-甜蜜点" class="headerlink" title="Sweet Point 甜蜜点"></a>Sweet Point 甜蜜点</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/174324.jpg"></p><ul><li>对于 10KSLOC（代码行数）项目，甜蜜点在最左边。 花费大量时间进行前期工作对于一个小型项目来说是一种浪费</li><li>对于 100KSLOC 项目，甜蜜点约为项目进度的20％</li><li>对于 10,000KSLOC 项目，甜蜜点约为项目进度的40%</li><li>结论：<ul><li>如果是相对稳定的、易于理解需求的、分布式开发的大型复杂系统，需要大量架构工作</li><li>对于需求不稳定的大型项目，从快速设计候选架构开始，即使它省略了许多细节</li><li>对于不确定需求的小型项目，至少在采用的主要模式上需要达成一致意见，不要花费太多时间在架构设计、文档或分析</li></ul></li></ul><h1 id="ASR-架构关键需求"><a href="#ASR-架构关键需求" class="headerlink" title="ASR 架构关键需求"></a>ASR 架构关键需求</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>对架构有深远影响</li><li>具有很高的业务价值</li></ul><h2 id="收集-ASR-的方法"><a href="#收集-ASR-的方法" class="headerlink" title="收集 ASR 的方法"></a>收集 ASR 的方法</h2><ul><li>从<strong>需求文档</strong>收集</li><li>采访<strong>利益相关者</strong></li><li>举行 <strong>QAW</strong>（Quality attribute workshop 质量属性研讨会）</li><li>通过理解<strong>业务目标</strong>获取（PALM）</li><li>从<strong>效用树</strong>获取</li></ul><h2 id="Utility-Tree-效用树"><a href="#Utility-Tree-效用树" class="headerlink" title="Utility Tree 效用树"></a>Utility Tree 效用树</h2><p>效用树是一种用于记录 ASR 的方法</p><ul><li>首先需要确定每个 ASR 的优先级</li><li>根节点是名为 <strong>Utility</strong> 的占位符节点</li><li>第二层节点包含广泛的<strong>质量检查</strong>类别</li><li>第三层节点用于<strong>细化</strong>这些类别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220102182333.png"></p><p>（业务价值，架构冲击） H=high, M=medium, L=low</p><h1 id="Design-Strategies-设计策略"><a href="#Design-Strategies-设计策略" class="headerlink" title="Design Strategies 设计策略"></a>Design Strategies 设计策略</h1><ul><li>分解：整个系统被分解成多个部分，每个部分承担一定的质量属性要求</li><li>设计 ASR：当设计无法满足 ASR 时，可以<ul><li>调整设计</li><li>降低要求</li><li>更改优先级</li></ul></li><li>生成和测试<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220102182744.png"></li></ul><h1 id="ADD-属性驱动设计-attribute-driven-design"><a href="#ADD-属性驱动设计-attribute-driven-design" class="headerlink" title="ADD 属性驱动设计 attribute driven design"></a>ADD 属性驱动设计 attribute driven design</h1><h2 id="ADD-步骤"><a href="#ADD-步骤" class="headerlink" title="ADD 步骤"></a>ADD 步骤</h2><ol><li>选择系统的一个元素来设计</li><li>识别选取元素的 ASR</li><li>为所选的元素生成<strong>设计方案</strong></li><li>清点未满足的需求，并从中选取下次迭代的输入</li><li>重复 1- 4 直至所有 ASR 被满足</li></ol><h2 id="ADD-输入输出"><a href="#ADD-输入输出" class="headerlink" title="ADD 输入输出"></a>ADD 输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul><li>功能</li><li>质量</li><li>约束</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li>信息流</li><li>交互</li><li>责任</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/110856.jpg"></p><h1 id="架构评估"><a href="#架构评估" class="headerlink" title="架构评估"></a>架构评估</h1><h2 id="三种评估形式"><a href="#三种评估形式" class="headerlink" title="三种评估形式"></a>三种评估形式</h2><ul><li>设计过程中由<strong>设计者</strong>评估</li><li>设计过程中由<strong>同行</strong>评估</li><li>设计完成后由<strong>外部</strong>评估</li></ul><h2 id="ATAM"><a href="#ATAM" class="headerlink" title="ATAM"></a>ATAM</h2><p>Architecture Tradeoff Analysis Method 架构权衡评估<strong>方法</strong></p><h3 id="参与人"><a href="#参与人" class="headerlink" title="参与人"></a>参与人</h3><ul><li>评估小组</li><li>项目决策人</li><li>利益相关者</li></ul><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><ul><li>简明的架构介绍</li><li>明确的业务目标</li><li>以质量属性场景表示的、已经划分了优先级的质量属性需求</li><li>一组风险点和非风险点</li><li>一组风险主题</li><li>一组敏感点和权衡点</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>展示与介绍 <strong>ATAM 相关事项</strong>，如步骤、过程、结果等</li><li>说明<strong>业务</strong>，如系统重要功能、约束、干系人、目标与背景、ASR</li><li>展示<strong>架构</strong>，如解释说明重要的质量属性问题</li><li><strong>标识</strong>架构方法，如架构模式和战术</li><li>生成<strong>效用树</strong>。评估小组与项目决策者共同识别、排序和完善系统的重要质量属性目标</li><li><strong>分析</strong>架构方法。识别风险点、非风险点、敏感点、权衡点</li><li><strong>头脑风暴</strong> &amp; <strong>场景优先级排序</strong>。通过头脑风暴收集场景，通过投票确定优先级。将结果与效用树进行比较，若不一致则说明系统要实现的目标存在分歧</li><li><strong>分析</strong>架构方法。与第 6 步类似，但是使用的是最新的方案</li><li>展示结果</li></ol><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/113943.jpg"></p><h2 id="轻量级架构评估-lightweight-architecture-evaluation"><a href="#轻量级架构评估-lightweight-architecture-evaluation" class="headerlink" title="轻量级架构评估 lightweight architecture evaluation"></a>轻量级架构评估 lightweight architecture evaluation</h2><p>一个 ATAM 过程通常需要 20-30 天，只适用于大型昂贵的项目。所以发展出了轻量级架构评估，一般只需要一天甚至半天，只涉及组织内部的人员。这个评估方法不产生最终报告，而是由抄写员负责收集结果。只有组织内部成员来评估可能得出不客观的结果，缺乏创新和讨论。但是这个评估方法快速廉价，所以可以被快速部署，无论项目是否需要关于架构质量保证的合理性检查（sanity check）</p><h1 id="云"><a href="#云" class="headerlink" title="云"></a>云</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>按需供给</li><li>资源池。资源池可以提高性能</li><li>网络访问便捷、范围广</li><li>性能具备弹性，可以自己伸缩</li><li>让开发者更专注于业务本身，资源消费者不需要关注资源所在的位置</li><li>节省成本，一是运维成本，另一方面是因为弹性原因，消费者只需要支付自己使用部分的金额</li><li>便于监视、查看资源使用情况</li></ul><h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><h3 id="Software-as-a-Service-SaaS"><a href="#Software-as-a-Service-SaaS" class="headerlink" title="Software as a Service (SaaS)."></a>Software as a Service (SaaS).</h3><ul><li>消费者是一个终端用户</li><li>消费者使用恰好在云上运行的应用程序</li><li>示例：e-mail</li></ul><h3 id="Platform-as-a-Service-PaaS"><a href="#Platform-as-a-Service-PaaS" class="headerlink" title="Platform as a Service (PaaS)"></a>Platform as a Service (PaaS)</h3><ul><li>为用户提供在云上开发和部署应用程序的编程语言和工具</li><li>消费者是一个开发人员</li><li>示例：谷歌 App 引擎，微软 Azure</li></ul><h3 id="Infrastructure-as-a-Service-IaaS"><a href="#Infrastructure-as-a-Service-IaaS" class="headerlink" title="Infrastructure as a Service (IaaS)"></a>Infrastructure as a Service (IaaS)</h3><ul><li>为了提供处理、存储、网络和其他基本计算资源，消费者能够<strong>部署和运行</strong>任意软件，其中可以包括操作系统和应用程序</li><li>在这种情况下，消费者是开发人员或系统管理员</li><li>示例：亚马逊 EC2</li></ul><h2 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h2><ul><li>公有云：云基础设施向公众开放，并由销售云服务的组织拥有</li><li>私有云：云基础设施仅由单一组织拥有，并仅为该组织拥有的应用程序运行</li><li>社区云：云基础设施由几个组织共享，并支持一个有共同关注点的特定社区</li><li>混合云：云基础设施由两个或更多种类的云组成</li></ul><h1 id="云环境下的架构"><a href="#云环境下的架构" class="headerlink" title="云环境下的架构"></a>云环境下的架构</h1><h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li>负载平衡。负载平衡是为了跨多个计算资源分配工作负载，以避免单个资源的过载</li><li>弹性缩放是一种方法，其中计算资源的数量，通常根据负载自动缩放</li></ul><h3 id="可获得性"><a href="#可获得性" class="headerlink" title="可获得性"></a>可获得性</h3><p>故障是云计算中常见的情况。云提供商确保云本身将保持可用，但有一些例外</p><ul><li>利用冗余来多次部署所有的服务：我们可以用两个服务器，两个负载均衡器，两个交换机，两个防火墙</li><li>HDFS（分布式文件系统）</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>多租户带来了对非云环境的额外关注</p><ul><li>无意的信息共享</li><li>虚拟机转义（脱离虚拟机并与主机操作系统交互）</li><li>拒绝服务攻击（一个用户可以通过消耗主机服务器的资源，以拒绝其他用户的使用）</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/01/from-2021-to-2022/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/01/from-2021-to-2022/" class="post-title-link" itemprop="url">2021 总结和 2022 目标</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-01 11:47:10" itemprop="dateCreated datePublished" datetime="2022-01-01T11:47:10+08:00">2022-01-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-20 17:53:50" itemprop="dateModified" datetime="2022-02-20T17:53:50+08:00">2022-02-20</time> </span><span id="/2022/01/01/from-2021-to-2022/" class="post-meta-item leancloud_visitors" data-flag-title="2021 总结和 2022 目标" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/01/from-2021-to-2022/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/01/from-2021-to-2022/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>528</span></span></div></header><div class="post-body" itemprop="articleBody"><p>去年对我而言是非常特殊的一年，也是从去年的暑假开始，我正式决定要走 web 前端的路。</p><p>去年主要的学习时间都放在了前端的知识点，包括 html、css、js、webpack5、node.js、react hooks 等，但是感觉好像目前还没有哪个方向研究得比较深入。前端的知识体系庞大复杂，而且涉及到的计算机基础知识也很多，让人很容易迷失学习方向。但是通过这半年来的逐渐摸索，我也大概知道了一些主流的技术栈以及学习的方向，这算是一件让人高兴的事情。不过去年最高兴的事情还是恢复了单身（</p><p>今年要开始找实习了，寒假也马上要到来了，在这画画饼做个寒假计划：</p><ul><li>复习前端三件套，熟悉 ES6+ 语法</li><li>复习计网知识</li><li>复习浏览器工作原理</li><li>争取看完《代码随想录》</li><li>复习 web 性能优化方法</li><li>复习 react hooks + redux 的使用</li><li>复习 node.js 基础</li><li>复习数据库基础</li><li>复习 os 基础</li><li>学习重点的 react hooks 源码</li><li>学习 redux 和 react-router 实现原理</li><li>学习 webpack 及其重要原理</li><li>熟悉 koa.js 使用并学习部分源码</li><li>用 react hooks + koa.js 做一个有一定难度的小程序或者网页</li></ul><p>备选：</p><ul><li>学习 three.js 基础</li><li>学习 nest.js 使用</li></ul><p>最后，新的一年，最大的愿望就是身边的人和我都能快快乐乐的！</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2021/12/31/browser-input-url/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/31/browser-input-url/" class="post-title-link" itemprop="url">从浏览器地址栏输入 URL 到显示页面的步骤</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 14:49:14" itemprop="dateCreated datePublished" datetime="2021-12-31T14:49:14+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2021/12/31/browser-input-url/" class="post-meta-item leancloud_visitors" data-flag-title="从浏览器地址栏输入 URL 到显示页面的步骤" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/12/31/browser-input-url/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/browser-input-url/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.2k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Chrome-架构"><a href="#Chrome-架构" class="headerlink" title="Chrome 架构"></a>Chrome 架构</h1><ol><li>浏览器进程：界面显示、用户交互、子进程管理、存储</li><li>渲染进程：将 HTML、CSS 和 JavaScript 文件转换为网页。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程<ul><li>GUI 渲染线程：解析 HTML，CSS，构建 DOM 树和 CSSOM 树，渲染浏览器界面；重绘和回流；注意 GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎线程执行时 GUI 渲染线程会停止运行</li><li>JS 引擎线程：负责解析 Javascript 脚本，如 V8 引擎；GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</li><li>事件处理线程：事件循环；任务队列</li><li>定时器线程：通过单独线程来计时并触发定时</li><li>异步 http 请求线程：进行异步请求</li></ul></li><li>GPU 进程：进行 GPU 加速</li><li>网络进程：负责页面的网络资源加载</li><li>插件进程：主要是负责插件的运行。因为插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ol><h1 id="从浏览器地址栏输入-URL-到显示页面的步骤"><a href="#从浏览器地址栏输入-URL-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 URL 到显示页面的步骤"></a>从浏览器地址栏输入 URL 到显示页面的步骤</h1><h2 id="浏览器线程"><a href="#浏览器线程" class="headerlink" title="浏览器线程"></a>浏览器线程</h2><ul><li>在浏览器地址栏输入 url</li><li>浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程</li></ul><h2 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h2><ul><li>浏览器查看是否缓存了该请求资源，如果请求资源在缓存中且未过期<ul><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验缓存是否过期，未过期就直接提供给客户端，否则重新请求（此处涉及缓存相关知识）</li></ul></li><li>DNS 解析：DNS 解析实际上就是进行网址和 IP 地址的转换。进行 DNS 解析时先查找缓存，没有再使用 DNS 服务器解析，查找顺序为：<ul><li>浏览器缓存</li><li>本机缓存</li><li>路由器缓存</li><li>若缓存没有，进行递归查询：先在本地的域名服务器中查找，没有就去 com 顶级域名服务器查找，还没找到就去 13 台根域名服务器查找。如此的类推下去，直到找到 IP 地址，然后把它记录在本地，供下次使用</li></ul></li><li>等待 TCP 队列：一般而言，对于 http1.1，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态</li><li>通过三次握手建立 TCP 连接：TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽建⽴连接就是通过三次握⼿来进⾏的<ul><li>⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态</li><li>客户端会随机初始化一个序号（client_isn），同时把 SYN 标志位置为 1。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，之后客户端处于 SYN-SENT 状态<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/160947.jpg"></li><li>服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（server_isn），其次把 TCP ⾸部的<strong>确认应答号</strong>字段填⼊ client_isn + 1，接着把 SYN 和 ACK 标志位置为 1。最后把该报⽂发给客户端，之后服务端处于 SYN-RCVD 状态<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/161037.jpg"></li><li>客户端收到服务端报⽂后，还要向服务端回应<strong>最后⼀个</strong>应答报⽂，⾸先把 ACK 标志位置为 1 ，其次<strong>确认应答号</strong>字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这次报⽂可以携带客户端到服务器的数据（<strong>之前的两次都可以不携带</strong>），之后客户端处于 ESTABLISHED 状态<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/161341.jpg"></li><li>服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态</li><li>双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数据了</li></ul></li><li>发送 HTTP 请求</li><li>服务器端处理请求</li><li>客户端根据响应报文的状态码处理响应<ul><li>200：检查 Content-Type 字段，如果值为 <code>text/html</code> 说明是HTML文档，如果是 <code>application/octet-stream</code> 说明是文件下载</li><li>301/302：表明服务器已更换域名，需要重定向。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，跳回到 DNS 解析那一步继续进行</li><li>304：表示自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li></ul></li><li>请求结束，当通用首部字段 Connection 不是 Keep-Alive 时，即不为 TCP 持续连接时，通过四次挥手断开 TCP 连接</li></ul><h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/163032.jpg"></p><ul><li>解析 HTML 形成 DOM 树</li><li>解析 CSS 形成 CSSOM 树</li><li>根据 DOM 树和 CSSOM 树构建渲染树<ul><li>从 DOM 树的根节点遍历所有可见节点，不可见节点包括：script、meta 这样本身不可见的标签；被 CSS 隐藏的节点，如 <code>display: none</code></li><li>根据 CSSOM 规则计算样式</li></ul></li><li>JS 解析</li><li>浏览器开始渲染并绘制页面</li></ul><h1 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h1><h1 id="DNS-解析如何优化"><a href="#DNS-解析如何优化" class="headerlink" title="DNS 解析如何优化"></a>DNS 解析如何优化</h1><h1 id="为什么是三次握手而不是两次"><a href="#为什么是三次握手而不是两次" class="headerlink" title="为什么是三次握手而不是两次"></a>为什么是三次握手而不是两次</h1><h1 id="POST-和-GET-请求的区别"><a href="#POST-和-GET-请求的区别" class="headerlink" title="POST 和 GET 请求的区别"></a>POST 和 GET 请求的区别</h1><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>（未完待续）</p><p>参考资料：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/102149546">https://zhuanlan.zhihu.com/p/102149546</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://mp.weixin.qq.com/s/7kdzH_1E0g332GTrtOyU8w">https://mp.weixin.qq.com/s/7kdzH_1E0g332GTrtOyU8w</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/xuanbingbingo/p/8675791.html">https://www.cnblogs.com/xuanbingbingo/p/8675791.html</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/AhuntSun-blog/p/12529920.html">https://www.cnblogs.com/AhuntSun-blog/p/12529920.html</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844903832435032072">https://juejin.cn/post/6844903832435032072</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844903553795014663">https://juejin.cn/post/6844903553795014663</a><br>公众号小林coding<br>公众号前端点线面</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2021/12/31/seo/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/31/seo/" class="post-title-link" itemprop="url">SEO 优化</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 14:28:39" itemprop="dateCreated datePublished" datetime="2021-12-31T14:28:39+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2021/12/31/seo/" class="post-meta-item leancloud_visitors" data-flag-title="SEO 优化" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/12/31/seo/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/seo/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>335</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前端需要注意的-SEO-优化"><a href="#前端需要注意的-SEO-优化" class="headerlink" title="前端需要注意的 SEO 优化"></a>前端需要注意的 SEO 优化</h1><ul><li>合理使用 title、description、keywords：title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li><li>使用语义化的 HTML 代码，让搜索引擎更容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出，因为爬虫不会获取 js 添加的内容</li><li>少用 iframe，因为搜索引擎不会抓取 iframe 中的内容</li><li>非装饰性图片必须加 alt</li><li>提高网站速度，因为网站速度是搜索引擎排序的一个重要指标</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2021/12/31/html-basics/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/31/html-basics/" class="post-title-link" itemprop="url">html 简单面试题</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 14:18:46" itemprop="dateCreated datePublished" datetime="2021-12-31T14:18:46+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2021/12/31/html-basics/" class="post-meta-item leancloud_visitors" data-flag-title="html 简单面试题" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/12/31/html-basics/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/html-basics/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.4k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="行内元素、块级元素、空元素有哪些"><a href="#行内元素、块级元素、空元素有哪些" class="headerlink" title="行内元素、块级元素、空元素有哪些"></a>行内元素、块级元素、空元素有哪些</h1><p>行内：span, a, label 不独占一行，不能设置宽高<br>块级：div, footer, header, section, p, h1-h6 独占一行，可以设置宽高<br>空元素：br, hr 不独占一行，可以设置宽高</p><h1 id="标签语义化的理解"><a href="#标签语义化的理解" class="headerlink" title="标签语义化的理解"></a>标签语义化的理解</h1><ul><li>HTML 语义化就是让页面的内容结构化，便于对浏览器解析，便于搜索引擎捕获，可以优化 SEO</li><li>提高代码可读性</li></ul><h1 id="HTML5-的新特性"><a href="#HTML5-的新特性" class="headerlink" title="HTML5 的新特性"></a>HTML5 的新特性</h1><ul><li>新增选择器 document.querySelector、document.querySelectorAll</li><li>拖拽释放（Drag and drop） API</li><li>媒体播放的 video 和 audio</li><li>本地存储 localStorage 和 sessionStorage</li><li>离线应用 manifest</li><li>语义化标签 article、footer、header、nav、section</li><li>跨域资源共享（CORS） Access-Control-Allow-Origin</li><li>canvas</li></ul><h1 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的"></a>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的</h1><ul><li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li><li>离线的情况下，浏览器就直接使用离线存储的资源</li></ul><h1 id="cookie，sessionStorage-和-localStorage-的区别"><a href="#cookie，sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别"></a>cookie，sessionStorage 和 localStorage 的区别</h1><ul><li>cookie 数据始终在同源的 http 请求中携带（即使不需要），也就是说它会在浏览器和服务器之间来回传递；sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li><li>cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 甚至更大</li><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非人为主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><h1 id="iframe-的缺点"><a href="#iframe-的缺点" class="headerlink" title="iframe 的缺点"></a>iframe 的缺点</h1><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li></ul><h1 id="src-与-href的区别"><a href="#src-与-href的区别" class="headerlink" title="src 与 href的区别"></a>src 与 href的区别</h1><p>src 用于<strong>替换</strong>当前元素，href 用于在当前文档和引用资源之间<strong>确立联系</strong></p><ul><li>src 是 source 的缩写，指向外部资源的位置，指向的内容将会<strong>嵌入到文档中当前标签所在位置</strong>；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 iframe 等元素</li><li>href 是 Hypertext Reference 的缩写，指向网络资源所在位置。如果我们在文档中添加 <code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code> 那么浏览器会识别该文档为 CSS 文件，然后<strong>并行</strong>下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 <code>link</code> 方式来加载 CSS，而不是 <code>@import</code> 方式</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2021/12/31/display-assignment/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/31/display-assignment/" class="post-title-link" itemprop="url">display 取值</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 13:50:42" itemprop="dateCreated datePublished" datetime="2021-12-31T13:50:42+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2021/12/31/display-assignment/" class="post-meta-item leancloud_visitors" data-flag-title="display 取值" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/12/31/display-assignment/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/display-assignment/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>60</span></span></div></header><div class="post-body" itemprop="articleBody"><ul><li>none 隐藏元素</li><li>block 转换为块级元素</li><li>inline 转换为内联元素</li><li>inline-block 转换为行内块元素</li><li>table 表格</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2021/12/31/css-triangle/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/12/31/css-triangle/" class="post-title-link" itemprop="url">CSS 画三角形</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 13:33:03" itemprop="dateCreated datePublished" datetime="2021-12-31T13:33:03+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2021/12/31/css-triangle/" class="post-meta-item leancloud_visitors" data-flag-title="CSS 画三角形" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2021/12/31/css-triangle/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/css-triangle/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>219</span></span></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;triangle&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.triangle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-color</span>: black transparent transparent transparent;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/135106.jpg"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Flower F" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">Flower F</p><div class="site-description" itemprop="description">一个算法学不好的前端爱好者博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">118</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/flower-f" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;flower-f" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"></span> <span class="author" itemprop="copyrightHolder">Flower F</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">274k</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共95.5k字</span></div></div></footer></div><script color="34,34,34" opacity="0.5" zindex="-1" count="200" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"KDfducB8SxPnkLaWp3IDrYkW-gzGzoHsz",appKey:"CfgFpbeT1UKlX7K2k9fQnuI6",placeholder:"留下你来过的痕迹~",avatar:"",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/dynamic_bg.js"></script>