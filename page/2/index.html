<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"flower-f.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一个算法学不好的前端爱好者博客"><meta property="og:type" content="website"><meta property="og:title" content="My Front End Blog"><meta property="og:url" content="https://flower-f.github.io/page/2/index.html"><meta property="og:site_name" content="My Front End Blog"><meta property="og:description" content="一个算法学不好的前端爱好者博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Flower F"><meta property="article:tag" content="前端 程序员 代码 学习 分享 bug"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://flower-f.github.io/page/2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>My Front End Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="My Front End Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Flower-F" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><div class="bg_content"><canvas id="canvas"></canvas></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">My Front End Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">From Flower-F</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时光轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/22/sum-questions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/22/sum-questions/" class="post-title-link" itemprop="url">N 数之和</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-22 17:05:25 / 修改时间：17:10:16" itemprop="dateCreated datePublished" datetime="2022-01-22T17:05:25+08:00">2022-01-22</time> </span><span id="/2022/01/22/sum-questions/" class="post-meta-item leancloud_visitors" data-flag-title="N 数之和" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/22/sum-questions/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/22/sum-questions/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.3k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, map.get(target - nums[i])];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/3sum/">三数之和</a></h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环遍历第一个数，转变为两数之和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 剪枝，如果这一项大于 0， 后面的必然也大于 0</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前遍历的数字与上一个遍历的数字相同，为避免重复所以跳过</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[left] + nums[right] + nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 两个指针之和太大，右指针左移</span></span><br><span class="line">        right--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] + nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 两个指针之和太小，左指针右移</span></span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了和为零的组合</span></span><br><span class="line">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">        <span class="comment">// 左右指针向内缩小</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left - <span class="number">1</span>] === nums[left]) left++;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right + <span class="number">1</span>] === nums[right]) right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/21/byte-fe-training-6-part-two/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/21/byte-fe-training-6-part-two/" class="post-title-link" itemprop="url">字节前端青训营第 6 天（下）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-21 14:05:55" itemprop="dateCreated datePublished" datetime="2022-01-21T14:05:55+08:00">2022-01-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-22 10:24:29" itemprop="dateModified" datetime="2022-01-22T10:24:29+08:00">2022-01-22</time> </span><span id="/2022/01/21/byte-fe-training-6-part-two/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 6 天（下）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/21/byte-fe-training-6-part-two/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/21/byte-fe-training-6-part-two/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.6k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>Cross-Site Scripting，跨站脚本攻击。指攻击者通过某种方式把恶意脚本注入你写的页面。</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121214536.png"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul><li>开发者盲目相信用户提交的内容</li><li>直接把用户的提交转换成了 DOM，如 <code>document.write(xxx)</code>、<code>elem.innerHTML = xxx</code></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>通常难以从 UI 上感知</li><li>窃取用户信息（cookie / token）</li><li>因为可以操作 js，所以可以绘制 UI，诱骗用户填写表单</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; content, id &#125; = ctx.request.body;</span><br><span class="line">  <span class="comment">// 没有对 content 进行过滤</span></span><br><span class="line">  <span class="keyword">await</span> db.save(&#123;</span><br><span class="line">    content,</span><br><span class="line">    id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; content &#125; = <span class="keyword">await</span> db.query(&#123;</span><br><span class="line">    <span class="attr">id</span>: ctx.query.id</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 又没有对 content 进行过滤</span></span><br><span class="line">  ctx.body = <span class="string">`&lt;div&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导致攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121215645.png"></p><h2 id="Stored-XSS-存储型"><a href="#Stored-XSS-存储型" class="headerlink" title="Stored XSS 存储型"></a>Stored XSS 存储型</h2><ul><li>恶意脚本被保存在数据库中</li><li>访问页面 -&gt; 读数据 -&gt; 被攻击</li><li>危害最大，对全部用户可见</li></ul><p>比如说一个用户在视频中插入一个 XSS 攻击，然后某一刻脚本被启动了，此时所有的在浏览这个页面的用户都会被脚本攻击，造成信息泄露。</p><h2 id="Reflected-XSS-反射型"><a href="#Reflected-XSS-反射型" class="headerlink" title="Reflected XSS 反射型"></a>Reflected XSS 反射型</h2><p>不涉及数据库，而是从 URL 进行攻击</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220034.png"></p><p>把字段直接生成 HTML 字段，然后被成功攻击</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220057.png"></p><h2 id="Dom-based-XSS"><a href="#Dom-based-XSS" class="headerlink" title="Dom-based XSS"></a>Dom-based XSS</h2><p>不需要服务器参与，恶意攻击的发起与执行都在浏览器完成。</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220034.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220433.png"></p><h2 id="Mutation-XSS"><a href="#Mutation-XSS" class="headerlink" title="Mutation XSS"></a>Mutation XSS</h2><p>利用了浏览器渲染 DOM 的特性，对于不同的浏览器执行会有区别。</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220622.png"></p><p>代码会被渲染为：</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121220828.png"></p><p>又由于 src 属性不符合规范，然后会触发 <code>onerror</code> 事件，也就完成了 XSS 攻击。</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>Cross-site request forgery，跨站请求伪造</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>用户不知情</li><li>利用用户权限</li><li>构造指定的 HTTP 请求，窃取或修改用户的敏感信息</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221305.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221625.png"></p><p>在这个例子中，用户并没有直接请求银行，但是这个请求却被成功执行了，这就是一个经典的 CSRF 攻击。</p><h1 id="Injection-注入"><a href="#Injection-注入" class="headerlink" title="Injection 注入"></a>Injection 注入</h1><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121221710.png"></p><p>删库跑路示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121223501.png"></p><p>其余注入：</p><ul><li>CLI</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121224200.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121224547.png"></p><p>因为没有过滤导致成功删除跑路</p><ul><li>读取 + 修改</li></ul><p>以 Nginx 为例，如果用户可以读取 Nginx 的配置文件，就能把我们的网站转到另一个网站</p><ul><li>SSRF Server-Side Request Forgery（严格来说不算注入）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232106.png"></p><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p>Denial of Service，服务拒绝。通过某种方式构造特定的请求，导致服务器资源被显著消耗，来不及响应更多的请求，导致请求积压，进而引发雪崩效应。</p><h2 id="Regex-DOS"><a href="#Regex-DOS" class="headerlink" title="Regex DOS"></a>Regex DOS</h2><h2 id="正则贪婪模式"><a href="#正则贪婪模式" class="headerlink" title="正则贪婪模式"></a>正则贪婪模式</h2><p><strong>书写正则的时候是否写 ?</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232454.png"></p><p>这里的第一行就是贪婪模式</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121232755.png"></p><p>因为贪婪引发回溯</p><h2 id="DDOS-分布式拒绝服务"><a href="#DDOS-分布式拒绝服务" class="headerlink" title="DDOS 分布式拒绝服务"></a>DDOS 分布式拒绝服务</h2><p>短时间内，收到大量来自僵尸设备的请求流量，服务器不能及时完成全部的请求，导致请求堆积，进而引发雪崩效应，无法响应新的请求。</p><p><em>不搞复杂的，量大就完事儿</em></p><h3 id="攻击特点"><a href="#攻击特点" class="headerlink" title="攻击特点"></a>攻击特点</h3><ul><li>直接访问 IP 而不是域名</li><li>使用任意的 API</li><li>消耗掉大量的带宽，直至耗尽</li></ul><h3 id="洪水攻击"><a href="#洪水攻击" class="headerlink" title="洪水攻击"></a>洪水攻击</h3><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121233159.png"></p><p>攻击者发起大量的 TCP 请求，然后就会产生大量的 SYN，发送给服务器。然后服务器就会产生大量的 ACK 和 SYN 给攻击者。但是，攻击者不会返回第三次 ACK，进而导致三次握手失败，连接无法被释放，于是很快就会到达最大连接次数，所有的新请求就无法被响应。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121233703.png"></p><p>为什么中间人攻击可以成立？</p><ul><li>HTTP 报文使用明文方式发送，可能被第三方窃听。</li><li>HTTP 报文可能被第三方拦截后修改通信内容，接收方没有办法发现报文内容的修改。</li><li>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</li></ul><h1 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h1><ul><li>永远不要信任用户提交的任何内容</li><li>永远不要把用户提交的内容直接转换成 DOM，而应该转换成字符串</li><li>主流的框架（React &amp; Vue）其实默认会防御 XSS 攻击</li></ul><p><strong>如果有需求不讲武德，必须动态生成 DOM 呢？</strong></p><ul><li>如果要把 string 直接生成 DOM，必须要对 string 进行转义</li><li>如果允许上传 SVG 文件，需要对 SVG 文件进行扫描，因为 SVG 中允许嵌套 script 标签</li><li>如果允许用户自定义跳转链接，必须进行检查过滤<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121234430.png"><br>像上图这样，用户可以插入 js 代码</li><li>如果允许自定义样式，必须进行检查过滤<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121234605.png"></li></ul><h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>Content Security Policy</p><ul><li>允许开发者定义哪些源（域名）是安全的</li><li>来自安全源的脚本可以执行，否则直接报错</li><li>对于 eval 或内联的脚本直接报错</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235018.png"></p><p>第一行：只允许同源；第二行：除了同源之外，还另外允了 domain.com</p><p>我们也可以在浏览器端进行设置：</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235151.png"></p><h1 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h1><p>只要我们限制请求的来源，就可以限制伪造请求。可以根据 Origin 或者 Referer 判断。</p><h2 id="token-防御机制"><a href="#token-防御机制" class="headerlink" title="token 防御机制"></a>token 防御机制</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235423.png"></p><ul><li>token 必须和具体的用户绑定，才能确保不会被其它的用户所利用。</li><li>token 必须有过期时间，否则万一 token 泄露，之前的所有请求都可以被利用</li></ul><h2 id="iframe-攻击"><a href="#iframe-攻击" class="headerlink" title="iframe 攻击"></a>iframe 攻击</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121235650.png"></p><p>首先在视觉上，让 button 覆盖住 iframe，然后用户就看不出来了。接着通过 button 的设置导致点击事件穿透了，然后传递给了 iframe，iframe 中的请求没有跨域，因此可以完成攻击。</p><p>可以设置 HTTP 响应头 <code>X-Frame-Options: DENY/SAMEORIGIN</code> （不允许加载 iframe 或只允许加载同源的 iframe）</p><h2 id="CSRF-反模式"><a href="#CSRF-反模式" class="headerlink" title="CSRF 反模式"></a>CSRF 反模式</h2><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122000110.png"></p><p>GET !== GET + POST</p><p>一旦被攻击，信息不单止可能泄露，甚至还会被篡改。</p><h2 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h2><p>限制 cookie 的 domain 属性。我页面的 cookie 只能为我所用，只有同域才能使用这个 cookie，第三方服务的请求不能带上我页面的 cookie。</p><p><strong>但是如果服务依赖于第三方的 cookie 怎么办？</strong></p><p>比如内嵌了一个 b 站的播放器，需要识别用户的登录状态。</p><p>可以设置 <code>SetCookie: SameSite=None; Secure;</code></p><p>即不限制 same site，但是必须确保 cookie 是安全的（只能通过 HTTPS 传输）。</p><p><strong>SameSite VS 同源策略</strong>：SameSite 主要针对 cookie，同源策略 针对的是请求的资源。</p><h2 id="防御-CSRF-的正确姿势"><a href="#防御-CSRF-的正确姿势" class="headerlink" title="防御 CSRF 的正确姿势"></a>防御 CSRF 的正确姿势</h2><p>用 Node 做一个中间件防范攻击。</p><h1 id="Injection-防御"><a href="#Injection-防御" class="headerlink" title="Injection 防御"></a>Injection 防御</h1><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>对 SQL 语句做一些 prepare 处理</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122095147.png"></p><h2 id="其余注入"><a href="#其余注入" class="headerlink" title="其余注入"></a>其余注入</h2><ul><li>命令不要通过 sudo 执行，不要给 root 权限</li><li>拒绝像 rm 这种极其危险的行为</li><li>对 URL 类型参数进行协议、域名、IP 等的限制</li></ul><h1 id="DOS-防御"><a href="#DOS-防御" class="headerlink" title="DOS 防御"></a>DOS 防御</h1><h2 id="Regex-DOS-1"><a href="#Regex-DOS-1" class="headerlink" title="Regex DOS"></a>Regex DOS</h2><ul><li>避免写出贪婪的正则匹配</li><li>扫描代码找出里面的所有正则，然后做正则性能测试</li><li>拒绝使用用户提供的正则</li></ul><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p>过滤：</p><ul><li>负载均衡</li><li>API 网关</li></ul><p>抗量：</p><ul><li>快速自动扩容</li><li>非核心服务降级</li></ul><h1 id="传输层防御"><a href="#传输层防御" class="headerlink" title="传输层防御"></a>传输层防御</h1><p>使用 HTTPS，其中 HTTP3 内置了 TLS</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/31121131121.png"></p><h1 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h1><p>HTTP Strict Transport Security，HTTO 严格传输安全协议。</p><p>HSTS 的作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。服务器开启 HSTS 的方法是，当客户端通过 HTTPS 发出请求时，在服务器返回的超文本传输协议（HTTP）响应头中包含 Strict-Transport-Security 字段。非加密传输时设置的 HSTS 字段无效。<br>比如，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://example.com/">https://example.com/</a> 的响应头含有 Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：</p><ul><li>在接下来的 31536000 秒（即一年）中，浏览器向 example.com 或其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如，用户点击超链接或在地址栏输入 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.example.com/">http://www.example.com/</a> ，浏览器应当自动将 http 转写成 https，然后直接向 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.example.com/">https://www.example.com/</a> 发送请求。</li><li>在接下来的一年中，如果 example.com 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。</li></ul><h1 id="SRI"><a href="#SRI" class="headerlink" title="SRI"></a>SRI</h1><p>Subresource Integrity，子资源完整性。</p><p>Web 性能优化中很重要的一点是加快请求完成速度，让可缓存的资源走 CDN 是最通用的做法。CDN 服务提供商通过分布在各地的节点，让用户从最近的节点加载内容，大幅提升速度。但是 CDN 的安全性一直是一个风险点：对于网站来说，让请求从第三方服务器经过，由第三方响应，安全方面肯定不如自己服务器可控。</p><p>我们知道 CSP（Content Security Policy） 的外链白名单机制可以在现代浏览器下减小 XSS 风险。但针对 CDN 内容被篡改而导致的 XSS，CSP 并不能防范，因为网站所使用的 CDN 域名，肯定在 CSP 白名单之中。这时候，SRI 就应运而生了。</p><p>它通过对比 hash 值，来确保文件的安全性，可以在一定程度上防范 XSS 攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220122101625.png"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/21/byte-fe-training-6-part-one/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/21/byte-fe-training-6-part-one/" class="post-title-link" itemprop="url">字节前端青训营第 6 天（上）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-21 10:02:29 / 修改时间：14:54:09" itemprop="dateCreated datePublished" datetime="2022-01-21T10:02:29+08:00">2022-01-21</time> </span><span id="/2022/01/21/byte-fe-training-6-part-one/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 6 天（上）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/21/byte-fe-training-6-part-one/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/21/byte-fe-training-6-part-one/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>363</span></span></div></header><div class="post-body" itemprop="articleBody"><p>这部分的入门门槛太高了，等我先把基础学好了再研究吧。</p><h1 id="现代图形系统"><a href="#现代图形系统" class="headerlink" title="现代图形系统"></a>现代图形系统</h1><ul><li>光栅 Raster：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li><li>像素 Pixel：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li><li>帧缓存 Frame Buffer：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li><li>CPU (Central Processing Unit)：中央处理单元，负责逻辑计算。</li><li>GPU (Graphics Processing Unit)：图形处理单元，负责图形计算。</li></ul><h1 id="CPU-VS-GPU"><a href="#CPU-VS-GPU" class="headerlink" title="CPU VS GPU"></a>CPU VS GPU</h1><h1 id="WebGL-Startup"><a href="#WebGL-Startup" class="headerlink" title="WebGL Startup"></a>WebGL Startup</h1><ol><li>创建 WebGL 上下文（Canvas）</li><li>创建 WebGL Program（顶点选择器、片源选择器）</li><li>将数据存入缓冲区（比如顶点颜色）</li><li>将缓冲区数据读取到 GPU</li><li>GPU 执行 WebGL 程序，输出结果</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/20/byte-fe-training-5-part-two/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/20/byte-fe-training-5-part-two/" class="post-title-link" itemprop="url">字节前端青训营第 5 天（下）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-20 14:00:28" itemprop="dateCreated datePublished" datetime="2022-01-20T14:00:28+08:00">2022-01-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-21 14:54:30" itemprop="dateModified" datetime="2022-01-21T14:54:30+08:00">2022-01-21</time> </span><span id="/2022/01/20/byte-fe-training-5-part-two/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 5 天（下）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/20/byte-fe-training-5-part-two/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/20/byte-fe-training-5-part-two/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.1k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>前端工程化</li><li>服务端</li><li>Electron 跨端桌面应用</li></ul><h1 id="编写-Http-Server"><a href="#编写-Http-Server" class="headerlink" title="编写 Http Server"></a>编写 Http Server</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收请求</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bufs = [];</span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buf</span>) =&gt;</span> &#123;</span><br><span class="line">    bufs.push(buf);</span><br><span class="line">  &#125;)</span><br><span class="line">  req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = Buffer.concat(bufs).toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">JSON</span>.parse(buf);</span><br><span class="line">      <span class="keyword">const</span> msg = result.msg || <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> responseMsg = &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">`receive: <span class="subst">$&#123;msg&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">      res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">      res.end(<span class="built_in">JSON</span>.stringify(responseMsg));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      res.end(<span class="string">&#x27;invalid json data&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发请求</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;Hello Byte Dance&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bufs = [];</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buf</span> =&gt;</span> &#123;</span><br><span class="line">    bufs.push(buf);</span><br><span class="line">  &#125;)</span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = Buffer.concat(bufs);</span><br><span class="line">    <span class="keyword">const</span> json = <span class="built_in">JSON</span>.parse(buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;json msg is: &#x27;</span>, json.msg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.end(body);</span><br></pre></td></tr></table></figure><h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folderPath = path.resolve(__dirname, <span class="string">&#x27;./static&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> info = url.parse(req.url);</span><br><span class="line">  <span class="keyword">const</span> filePath = path.resolve(folderPath, <span class="string">&#x27;.&#x27;</span> + info.pathname);</span><br><span class="line">  <span class="keyword">const</span> fileStream = fs.createReadStream(filePath);</span><br><span class="line"></span><br><span class="line">  fileStream.pipe(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ReactDomServer = <span class="built_in">require</span>(<span class="string">&#x27;react-dom/server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&#x27;h1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello SSR&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Nodejs&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;ReactDomServer.renderToString(</span></span></span><br><span class="line"><span class="subst"><span class="string">        React.createElement(App)</span></span></span><br><span class="line"><span class="subst"><span class="string">      )&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/body &gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><ul><li>守护进程：当进程退出以后</li><li>多进程：通过 cluster 模块便捷地利用多进程</li><li>记录进程状态：用于诊断</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/20/byte-fe-training-5-part-one/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/20/byte-fe-training-5-part-one/" class="post-title-link" itemprop="url">字节前端青训营第 5 天（上）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-20 10:14:49" itemprop="dateCreated datePublished" datetime="2022-01-20T10:14:49+08:00">2022-01-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-22 09:33:00" itemprop="dateModified" datetime="2022-01-22T09:33:00+08:00">2022-01-22</time> </span><span id="/2022/01/20/byte-fe-training-5-part-one/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 5 天（上）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/20/byte-fe-training-5-part-one/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/20/byte-fe-training-5-part-one/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.6k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h1><ul><li>Hyper Text Transfer Protocol 超文本传输协议</li><li>应用层协议，基于 TCP 协议</li><li>分为两部分：请求 &amp; 响应</li><li>可拓展，比如可以自定义 Header</li><li>无状态，每个请求之间都是孤立的</li></ul><h1 id="HTTP-历史"><a href="#HTTP-历史" class="headerlink" title="HTTP 历史"></a>HTTP 历史</h1><h2 id="HTTP-0-9（单行协议）"><a href="#HTTP-0-9（单行协议）" class="headerlink" title="HTTP/0.9（单行协议）"></a>HTTP/0.9（单行协议）</h2><ul><li>只有一个请求行，没有请求头和请求体</li><li>请求方法只有 GET</li><li>响应只有 HTML 文档</li><li>文件格式只局限于 ASCII 编码</li><li>存在的问题：<ul><li>只支持 HTML 文件，其余类型文件无法传输</li><li>文件格式不再仅仅局限于 ASCII 编码</li></ul></li></ul><h2 id="HTTP-1-0（可拓展性）"><a href="#HTTP-1-0（可拓展性）" class="headerlink" title="HTTP/1.0（可拓展性）"></a>HTTP/1.0（可拓展性）</h2><ul><li>引入了请求头和响应头</li><li>增加了状态码</li><li>支持多种的文档类型</li><li>提供了 Cache 机制（If-Modified-Since、Last-Modified、Expires）</li><li>请求头加入了 User-Agent</li><li>存在的问题：<ul><li>每次通信都需要经过建立 TCP 连接、传输数据、断开 TCP 连接三个阶段，开销很大</li><li>在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，也就是所谓的<strong>队头阻塞</strong></li><li>每个域名绑定唯一 IP 地址，因此一个服务器只支持一个域名</li><li>需要在响应头设置 Content-Length，然后浏览器再根据设置的数据大小来接收数据，对于动态生成的数据无能为力</li><li>不支持断点续传（在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度。）</li></ul></li></ul><h2 id="HTTP-1-1（标准化协议）"><a href="#HTTP-1-1（标准化协议）" class="headerlink" title="HTTP/1.1（标准化协议）"></a>HTTP/1.1（标准化协议）</h2><ul><li>增加了持久连接，默认开启 Connection: Keep-Alive。只要浏览器或服务器没有明确断开连接，那么连接会一直保持</li><li>虚拟主机的发展可以让一个 IP 对应多个域名。<ul><li>请求头增加了 Host 字段，用来表示当前域名地址</li><li>域名分片机制：引入 CDN 之后，每个域名可以维护 6 个连接</li></ul></li><li>引入了 cookie 机制和安全机制</li><li>新的缓存方案（If-None-Match、ETag）</li><li>存在的问题：<ul><li>TCP 的慢启动</li><li>同时开启多条 TCP 连接时，连接之间会竞争带宽</li><li>队头阻塞问题依然无法解决</li><li>由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</li></ul></li></ul><h2 id="HTTP-2-（表现更优异）"><a href="#HTTP-2-（表现更优异）" class="headerlink" title="HTTP/2 （表现更优异）"></a>HTTP/2 （表现更优异）</h2><ul><li>HTTP/2 是一个二进制协议。在 HTTP/1.1 中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为<strong>帧</strong></li><li>实现了多路复用。HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了队头阻塞问题</li><li>使用了数据流的概念。<strong>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求</strong>。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li>实现了头信息压缩。由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，<strong>以后就不发送同样字段了，只发送索引号</strong>，这样就能提高速度了。</li><li>允许服务器推送。HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。</li><li>存在的问题：因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。这也导致了<strong>队头阻塞</strong>。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</li></ul><h2 id="HTTP-3（QUIC-协议）"><a href="#HTTP-3（QUIC-协议）" class="headerlink" title="HTTP/3（QUIC 协议）"></a>HTTP/3（QUIC 协议）</h2><ul><li>Quick UDP Internet Connection</li><li>基于 UDP 实现了类似 TCP 的流量控制、可靠传输机制</li><li>集成了 TLS 安全加密</li><li>实现了 HTTP/2 多路复用技术，QUIC 实现了在同一个物理连接中可以有多个独立的逻辑数据流，实现了数据流单独传输，解决了 TCP 队头阻塞的问题</li><li>实现了快速握手功能（因为是基于 UDP 的）</li><li>存在的问题：<ul><li>服务器和浏览器还没有对其提供较完整的支持</li><li>可能存在安全性问题</li></ul></li></ul><h1 id="常用请求方法"><a href="#常用请求方法" class="headerlink" title="常用请求方法"></a>常用请求方法</h1><table><thead><tr><th align="center">请求方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">GET</td><td align="left">请求指定的资源，并返回实体</td></tr><tr><td align="center">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和已有资源的修改</td></tr><tr><td align="center">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的内容</td></tr><tr><td align="center">DELETE</td><td align="left">请求服务器删除指定的数据</td></tr><tr><td align="center">OPTIONS</td><td align="left">在采取具体资源的请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</td></tr><tr><td align="center">CONNECT</td><td align="left">HTTP/1.1 协议中预留于能够将连接改为管道方式</td></tr><tr><td align="center">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有请求体</td></tr></tbody></table><h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li>安全的方法：不好修改服务器数据，如 GET、HEAD、OPTIONS</li><li>幂等的方法：同样的请求执行一次，与连续执行多次效果相同。包括上面所有的安全方法，还包括 PUT、DELETE 这两个不安全但是幂等的方法</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码概览：</p><ul><li>1XX：请求已接受，正在继续处理</li><li>2XX：请求成功，处理完毕</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务端错误</li></ul><p>常见状态码总结：</p><table><thead><tr><th align="left">状态码 &amp; 英文描述</th><th align="left">详细说明</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">服务器收到了请求的一部分，并且希望客户端继续发送其余部分</td></tr><tr><td align="left">101 Switching Protocols</td><td align="left">切换协议，服务端根据客户端请求的头信息切换协议</td></tr><tr><td align="left">200 OK</td><td align="left">请求成功，且被服务端成功处理</td></tr><tr><td align="left">201 Created</td><td align="left">成功请求，且创建了新的资源</td></tr><tr><td align="left">202 Accepted</td><td align="left">服务器已接受请求，但未处理完成</td></tr><tr><td align="left">204 No Content</td><td align="left">请求成功处理，但是没有资源可以返回</td></tr><tr><td align="left">206 Partial Content</td><td align="left">服务器成功处理了部分 GET 请求</td></tr><tr><td align="left">301 Moved Permanently</td><td align="left">永久重定向。请求的资源被分配了新的 URL，之后应使用<strong>更改</strong>的URL</td></tr><tr><td align="left">302 Found</td><td align="left">临时重定向。表示请求的资源被分配了新的 URL，希望<strong>本次</strong>访问使用新的 URL</td></tr><tr><td align="left">304 Not Modified</td><td align="left"><strong>缓存</strong>相关的状态码。自从上次请求后，请求的资源未被修改过。 服务器返回此响应时，不会返回任何资源。客户端的请求中带有 If-Modified-Since 或者 If-None-Match</td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">类似 302，但是 307 会遵照浏览器标准，请求方法不会从 POST 变成 GET</td></tr><tr><td align="left">400 Bad Request</td><td align="left">请求报文中存在语法错误</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">用户未授权</td></tr><tr><td align="left">403 Forbidden</td><td align="left">服务器拒绝该次访问</td></tr><tr><td align="left">404 Not Found</td><td align="left">服务器上无法找到请求的资源</td></tr><tr><td align="left">408 Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">500 Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">502 Bad Gateway</td><td align="left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">服务器超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>一种 API 设计风格，有以下特点：</p><ul><li>每个 URI 代表一种资源</li><li>URI 只用于表示资源的名称，而不包括资源的操作</li><li>接口应该使用标准的 HTTP 方法如 GET，PUT 和 POST，并遵循这些方法的<strong>语义</strong></li></ul><p>CRUD 应该遵循以下语义：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220120225230.png"></p><p>示例：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220120225441.png"></p><h2 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h2><table><thead><tr><th align="left">请求头</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">浏览器可接受的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a></td></tr><tr><td align="left">Content-Type</td><td align="left">资源属于什么 MIME 类型</td></tr><tr><td align="left">Cache-Control</td><td align="left">用于指定缓存机制。常见的值有 no-cache（不直接使用缓存，要向服务器发起请求确认资源是否更改，也就是我们常说的<strong>协商缓存</strong>），no-store（不使用任何缓存），max-age=xxx（缓存内容在 xxx 秒后失效）</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">对应于服务端的 Last-Modified，若所请求的内容在指定的日期之后没有修改过，则返回 304 Not Modified，精度达到秒</td></tr><tr><td align="left">If-None-Match</td><td align="left">对应于服务端的 ETag，若所请求的内容在指定的日期之后没有修改过，则返回 304 Not Modified，精度非常准确</td></tr><tr><td align="left">Cookie</td><td align="left">有 cookie 而且同域的时候会自动带上</td></tr><tr><td align="left">User-Agent</td><td align="left">浏览器类型</td></tr><tr><td align="left">Connection</td><td align="left">若为 Keep-Alive，或者协议是 HTTP/1.1，则开启持久连接</td></tr><tr><td align="left">Location</td><td align="left">一般用来表示重定向的地址</td></tr><tr><td align="left">Expires</td><td align="left">缓存过期时间，在此时间内不需要发起请求，可以直接使用缓存</td></tr><tr><td align="left">Authorization</td><td align="left">授权信息</td></tr><tr><td align="left">Referer</td><td align="left">说明该页面的来源 URL。用处：防止盗链；避免 CSRF 攻击</td></tr><tr><td align="left">Origin</td><td align="left">类似于 Referer，把 URI 剥离成 {协议，域名，端口} 的三元组，用于指明当前请求来自于哪个站点。Origin 的出现就是为了实现跨域。</td></tr></tbody></table><h2 id="常用响应头"><a href="#常用响应头" class="headerlink" title="常用响应头"></a>常用响应头</h2><table><thead><tr><th align="left">响应头</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Content-Type</td><td align="left">资源属于什么 MIME 类型</td></tr><tr><td align="left">Cache-Control</td><td align="left">用于指定缓存机制。常见的值有 no-cache（不直接使用缓存，要向服务器发起请求确认资源是否更改，也就是我们常说的<strong>协商缓存</strong>），no-store（不使用任何缓存），max-age=xxx（缓存内容在 xxx 秒后失效）</td></tr><tr><td align="left">Last-Modified</td><td align="left">最后修改时间。客户端可以通过 If-Modified-Since 请求头提供一个日期，只有改动时间迟于指定时间，才会返回新的资源，否则返回一个 304 Not Modified</td></tr><tr><td align="left">ETag</td><td align="left">资源特定的标识符。客户端可以通过 If-None-Match 请求头提供一个标识符，如果客户端标识符与服务端不同才会返回新的资源，否则返回一个 304 Not Modified</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置页面相关的 Cookie</td></tr><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">服务器允许请求的 Origin，如果设置为 * 则表示允许所有的 Origin</td></tr><tr><td align="left">Expires</td><td align="left">缓存过期时间。在此时间内不需要发起请求，可以直接使用缓存</td></tr><tr><td align="left">Max-age</td><td align="left">本地缓存应该缓存多久，开启了 Cache-Control 后才生效</td></tr></tbody></table><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据 Expires 和 Cache-control 判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信</strong>。</p><p><strong>Expires VS max-age</strong></p><ul><li>Expires 是一个<strong>时间戳</strong>，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 Expires 的时间戳，如果本地时间小于 Expires 设定的过期时间，那么就直接去缓存中取这个资源。由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 Expires 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求，<strong>若服务器与客户端存在时差，将带来意料之外的结果</strong>。</li><li>max-age 是一个相对时间，这就意味着它有能力规避掉 Expires 可能会带来的时差问题。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的起始时间和当前时间都来源于客户端，因此能够实现更加精准的判断。</li><li>Cache-Control 的 max-age 配置项相对于 Expires 的优先级更高。当 Cache-Control 与 Expires 同时出现时，我们以 Cache-Control 为准。</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动，资源会被<strong>重定向到浏览器缓存</strong>（解释了为什么它是 3XX 开头），这种情况下网络请求对应的状态码是 304。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h4><p>含义：指最后一次修改资源的时间。开启了协商缓存之后，我们的每次请求都会带上 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 Last-Modified 值。服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值，否则返回 304 Not Modified。</p><p>弊端：</p><ul><li>有时候可能我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li><li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since <strong>只能检查到以秒为最小计量单位</strong>的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li></ul><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><p>Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是<strong>基于文件内容编码</strong>的，只要文件内容不同，它们对应的 Etag 就是不同的；相反，只要文件内容相同，ETag 就是相同的。因此 Etag 能够<strong>精准地感知文件的变化</strong>。它的作用原理和 If-Modified-Since 类似，都是客户端带上然后去跟服务端进行比较，不同就返回资源以及新的 ETag，相同就返回 304 Not Modified。</p><p>弊端：Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p><p>示例图：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220121095649.png"><br>简单来说就是：</p><ul><li>有强缓存且新鲜，就用，否则，就看有没有协商缓存</li><li>协商缓存 ETag 优先级高于 If-Modified-Since</li><li>什么缓存都没有，或者缓存不新鲜，就去重新请求</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>&lt;cookie-name&gt;=&lt;cookie-value&gt;</code></td><td align="left">cookie 的键值对。</td></tr><tr><td align="left">Path</td><td align="left">指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 cookie。</td></tr><tr><td align="left">Domain</td><td align="left">指定 cookie 可以送达的主机名。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。</td></tr><tr><td align="left">Sec</td><td align="left">规定必须通过安全的 HTTPS 连接来传输 cookie。</td></tr><tr><td align="left">HttpOnly</td><td align="left">JS 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击。</td></tr><tr><td align="left">Expires</td><td align="left">规定 cookie 的最长有效时间。形式为符合 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date">HTTP-Date</a> 规范的时间戳。</td></tr><tr><td align="left">Max-Age</td><td align="left">在 cookie 失效之前需要经过的秒数。假如 Expires 和 Max-Age 均存在，那么 Max-Age 优先级更高。</td></tr><tr><td align="left">SameSite=[Strict, Lax]</td><td align="left">允许服务器设定 cookie 不随着跨域请求一起发送，这样可以在一定程度上防范 CSRF 攻击。</td></tr></tbody></table><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ul><li>HTTP 报文使用<strong>明文</strong>方式发送，可能被第三方窃听。</li><li>HTTP 报文可能被第三方<strong>拦截</strong>后修改通信内容，接收方没有办法发现报文内容的修改。</li><li>HTTP 还存在认证的问题，第三方可以<strong>冒充</strong>他人参与通信。</li></ul><h2 id="HTTPS-的解决方案"><a href="#HTTPS-的解决方案" class="headerlink" title="HTTPS 的解决方案"></a>HTTPS 的解决方案</h2><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。优点有：</p><ul><li>所有的信息都是加密的，第三方没有办法窃听。</li><li>它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。</li><li>配备了身份证书，防止身份被冒充的情况出现。</li></ul><h2 id="TLS-握手安全的原理"><a href="#TLS-握手安全的原理" class="headerlink" title="TLS 握手安全的原理"></a>TLS 握手安全的原理</h2><ul><li>对称加密：双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。因此还需要非对称加密。</li><li>非对称加密：我们拥有两个秘钥，一个公钥，一个私钥。公钥是公开的，私钥是保密的。<strong>用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。</strong>我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，然后我们就可以对应的私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密速度很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</li><li>非对称与对称的权衡：因为对称加密的方式的缺点是无法保证秘钥的安全传输，非对称加密的缺点是加密速度很慢，因此我们可以<strong>用非对称加密的方式来对对称加密的密钥进行传输，然后以后的通信使用对称加密的方式来加密</strong>，这样就解决了两个方法各自存在的问题。<strong>注意，只有传输这个加密的密钥的时候我们才需要使用非对称的加密。</strong></li><li>数字证书：但是这样依然无法确保安全性。因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，拦截了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个<strong>信息摘要</strong>，然后让有公信力的认证中心（简称 CA ）用它的私钥对信息摘要加密，形成<strong>签名</strong>。最后将原始的信息和签名合在一起，称为<strong>数字证书</strong>。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最重要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。</li></ul><p>示例图：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/31121131121.png"></p><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>静态资源方案：缓存 + CDN + 文件名 hash（确保用户能拿到最新的文件）</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>Content Delivery Network，内容分发网络，是由分布在不同区域的边缘节点服务器组成的分布式网络。开启 CDN 之后，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时也分担了源服务器的访问压力。</p><p><strong>是否开启 CDN 的区别</strong></p><p>不开启 CDN：<br>用户输入域名 -&gt; DNS 解析获取 IP -&gt; 向该 IP 对应服务器发送访问请求 -&gt; 返回资源</p><p>开启 CDN：<br>用户输入域名 -&gt; 智能 DNS 解析 -&gt; 获取缓存服务器 IP -&gt; 若缓存有目标资源，返回资源；若没有就向源服务器发起请求，把获取的资源保存到缓存服务器，再把资源返回给用户</p><h1 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h1><p>在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。这种方式减少了由登录产生的时间消耗，辅助了用户管理。</p><p>用户在授权访问后会获得一个凭证，之后访问相关的应用时也会带上这个凭证，所以用户就可以在不需要再次登录的情况下直接登录访问。</p><h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>常用的跨域解决方案主要有五种：</p><ul><li>JSONP</li><li>CORS</li><li>WebSocket</li><li>Node 正向代理</li><li>Nginx 反向代理</li></ul><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax 五部曲</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：创建 xhr 对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span><br><span class="line"><span class="comment">// 第三步：发送请求</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">// 第四步：绑定事件</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readState</span></span><br><span class="line">  <span class="comment">// 0 表示未初始化</span></span><br><span class="line">  <span class="comment">// 1 表示 open 完毕</span></span><br><span class="line">  <span class="comment">// 2 表示 send 完毕 </span></span><br><span class="line">  <span class="comment">// 3 表示服务端返回了部分结果 </span></span><br><span class="line">  <span class="comment">// 4 表示服务端返回了所有结果</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 第五步：处理结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/19/status-code/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/19/status-code/" class="post-title-link" itemprop="url">常见状态码总结</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-19 21:59:51" itemprop="dateCreated datePublished" datetime="2022-01-19T21:59:51+08:00">2022-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-20 22:45:22" itemprop="dateModified" datetime="2022-01-20T22:45:22+08:00">2022-01-20</time> </span><span id="/2022/01/19/status-code/" class="post-meta-item leancloud_visitors" data-flag-title="常见状态码总结" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/19/status-code/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/19/status-code/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>736</span></span></div></header><div class="post-body" itemprop="articleBody"><table><thead><tr><th align="left">状态码 &amp; 英文描述</th><th align="left">详细说明</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">服务器收到了请求的一部分，并且希望客户端继续发送其余部分</td></tr><tr><td align="left">101 Switching Protocols</td><td align="left">切换协议，服务端根据客户端请求的头信息切换协议</td></tr><tr><td align="left">200 OK</td><td align="left">请求成功，且被服务端成功处理</td></tr><tr><td align="left">201 Created</td><td align="left">成功请求，且创建了新的资源</td></tr><tr><td align="left">202 Accepted</td><td align="left">服务器已接受请求，但未处理完成</td></tr><tr><td align="left">204 No Content</td><td align="left">请求成功处理，但是没有资源可以返回</td></tr><tr><td align="left">206 Partial Content</td><td align="left">服务器成功处理了部分 GET 请求</td></tr><tr><td align="left">301 Moved Permanently</td><td align="left">永久重定向。请求的资源被分配了新的 URL，之后应使用<strong>更改</strong>的URL</td></tr><tr><td align="left">302 Found</td><td align="left">临时重定向。表示请求的资源被分配了新的 URL，希望<strong>本次</strong>访问使用新的 URL</td></tr><tr><td align="left">304 Not Modified</td><td align="left"><strong>缓存</strong>相关的状态码。自从上次请求后，请求的资源未被修改过。 服务器返回此响应时，不会返回任何资源。客户端的请求中带有 If-Modified-Since 或者 if-Match</td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">类似 302，但是 307 会遵照浏览器标准，请求方法不会从 POST 变成 GET</td></tr><tr><td align="left">400 Bad Request</td><td align="left">请求报文中存在语法错误</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">用户未授权</td></tr><tr><td align="left">403 Forbidden</td><td align="left">服务器拒绝该次访问</td></tr><tr><td align="left">404 Not Found</td><td align="left">服务器上无法找到请求的资源</td></tr><tr><td align="left">408 Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">500 Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">502 Bad Gateway</td><td align="left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">服务器超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/19/byte-fe-training-4-part-two/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/19/byte-fe-training-4-part-two/" class="post-title-link" itemprop="url">字节前端青训营第 4 天（下）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-19 16:45:33" itemprop="dateCreated datePublished" datetime="2022-01-19T16:45:33+08:00">2022-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-20 10:13:19" itemprop="dateModified" datetime="2022-01-20T10:13:19+08:00">2022-01-20</time> </span><span id="/2022/01/19/byte-fe-training-4-part-two/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 4 天（下）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/19/byte-fe-training-4-part-two/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/19/byte-fe-training-4-part-two/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.8k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="动画基本原理"><a href="#动画基本原理" class="headerlink" title="动画基本原理"></a>动画基本原理</h1><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>无论动画多么简单，始终需要定义两个基本状态，即开始状态和结束状态。没有它们，我们将无法定义插值状态，从而填补两者之间的空白。<br>插值可能是颜色，也可能是位置等属性，可以理解为是对某个上下文中一个值或多个值的估计。当图形的变化可以由线性方程表示，就是线性插值。</p><h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><ul><li>帧：连续变换的多张画面，其中的每一幅画面都是一帧。</li><li>帧率:用于度量一定时间段内的帧数，通常的测量单位是 FPS (frame per second)。</li><li>帧率与人眼：一般每秒 10-12 帧人会认为画面是连贯的，这个现象称为视觉暂留。对于一些电脑动画和游戏来说低于 30FPS 会感受到明显卡顿，目前主流的屏幕、显卡输出为 60FPS，效果会明显更流畅。</li></ul><h2 id="空白补全"><a href="#空白补全" class="headerlink" title="空白补全"></a>空白补全</h2><p>空白的补全方式有以下两种</p><ul><li>补间动画：传统动画，主画师绘制关键帧，交给清稿部门，清稿部门的补间动画师补充关键帧进行交付。（类比到这里， 补间动画师由浏览器来担任，如 keyframe，transition）</li><li>逐帧动画（Frame By Frame）：从词语来说意味着全片每一帧逐帧都是纯手绘。（如 css 的 steps 实现精灵动画）</li></ul><h1 id="前端动画分类"><a href="#前端动画分类" class="headerlink" title="前端动画分类"></a>前端动画分类</h1><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><p>优点:</p><ul><li>浏览器会对 CSS3 动画做一些优化，导致 CSS3 动画性能上稍有优势。（新建一个图层来跑动画）</li><li>CSS3 动画的代码相对简单。</li></ul><p>缺点:</p><ul><li>动画控制上不够灵活。</li><li>兼容性不佳。</li><li>部分动画无法实现。（视差效果、滚动动画）</li></ul><p>主要属性：</p><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a>：可以用于图形的旋转、移动、缩放等</li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition"><code>transition</code></a>：处理开始状态到结束状态的过渡效果</li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation"><code>animation</code></a>：通过 keyframe 定义开始状态、结束状态以及多个中间态，相比于 <code>transition</code> 可以处理更复杂的动画</li></ul><h2 id="SVG-动画"><a href="#SVG-动画" class="headerlink" title="SVG 动画"></a>SVG 动画</h2><p>优点：通过矢量元素实现动画，不同的屏幕下均可获得较好的清晰度。可以用于实现一些特殊的效果，如：描字，形变，墨水扩散等。</p><p>缺点：使用方式较为复杂，过多使用可能会带来性能问题。</p><p>实现 SVG 动画通常有三种方式，SMIL、JS、CSS</p><h3 id="SMIL"><a href="#SMIL" class="headerlink" title="SMIL"></a>SMIL</h3><p>兼容性不理想，因此不过多讨论</p><h3 id="JS-操作-SVG"><a href="#JS-操作-SVG" class="headerlink" title="JS 操作 SVG"></a>JS 操作 SVG</h3><ul><li>Snap.svg</li><li>anime.js</li><li>HTML 原生的 Web Animation</li></ul><p>例一：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://codepen.io/jiangxiang/pen/MWmdjeY">SVG 文字变形</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">CSS 属性 filter</a>：可以将模糊或颜色偏移等效果应用于元素，它的属性 url 可以传入一个 svg</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elts.text2.style.filter = <span class="string">`blur(<span class="subst">$&#123;<span class="built_in">Math</span>.min(<span class="number">8</span> / fraction - <span class="number">8</span>, <span class="number">100</span>)&#125;</span>px)`</span>;</span><br><span class="line">elts.text2.style.opacity = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.pow(fraction, <span class="number">0.4</span>) * <span class="number">100</span>&#125;</span>%`</span>;</span><br><span class="line"></span><br><span class="line">fraction = <span class="number">1</span> - fraction;</span><br><span class="line">elts.text1.style.filter = <span class="string">`blur(<span class="subst">$&#123;<span class="built_in">Math</span>.min(<span class="number">8</span> / fraction - <span class="number">8</span>, <span class="number">100</span>)&#125;</span>px)`</span>;</span><br><span class="line">elts.text1.style.opacity = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.pow(fraction, <span class="number">0.4</span>) * <span class="number">100</span>&#125;</span>%`</span>;</span><br></pre></td></tr></table></figure><p>通过上面的代码控制 <code>blur</code> 和 <code>opacity</code> 不断地变化。每次切换单词的时候，当它的模糊程度快没有，就直接通过透明度把它隐藏掉，造成一种文字溶解的错觉。</p><p>例二：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://codepen.io/jiangxiang/pen/eYWagxq">JS 画笔</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://codepen.io/jiangxiang/pen/LYzvvxd">JS 画笔的原理</a>：<br><code>stroke-dashoffset</code>、<code>stroke-dasharray</code> 配合使用实现笔画效果。</p><ul><li>属性 <code>stroke-dasharray</code> 可控制用来描边的点划线的图案范式。它是一个数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2 等同于 5,3,2,5,3,2。</li><li><code>stroke-dashoffset</code> 属性指定了 dash 模式到路径开始的距离。（当使用了 <code>stroke-dasharray</code>，就进入了 dash 模式）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">line</span> <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5, 5&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;190&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">line</span> <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5, 10&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;30&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;190&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面第一个表示先走 5 像素实线，再走 5 像素的空白；第二个表示先走 5 像素实线，再走 10 像素空白。</p><p>计算 path 的长度：<code>path.getTotalLength()</code>，然后将 <code>stroke-dashoffset</code> 的值设置为该的长度，就能实现类似画画的效果。</p><h2 id="JS-动画"><a href="#JS-动画" class="headerlink" title="JS 动画"></a>JS 动画</h2><p>JS 可以通过操作 SVG、CSS、Canvas 等实现动画。</p><p>优点：</p><ul><li>使用灵活，同样在定义一个动画的 keyframe 序列时，可以根据不同的条件调节若干参数（JS 动画函数）改变动画方式。（CSS 会有非常多的代码冗余），对比于 CSS 的 keyframe 粒度更粗，CSS 本身的时间函数是有限的，这块 JS 可以弥补。</li><li>CSS 很难做到两个以上的状态转化。（要么使用关键帧，要么需要多个动画延时触发，再想到要对动画循环播放或暂停倒序等，复杂度极高）</li></ul><p>缺点:</p><ul><li>使用到 JS 运行时，调优方面不如 CSS 简单，CSS 调优方式固定。</li><li>对于性能和兼容性较差的浏览器，CSS 可以做到优雅降级，而 JS 需要额外的代码兼容。</li></ul><h2 id="对比与结论"><a href="#对比与结论" class="headerlink" title="对比与结论"></a>对比与结论</h2><ul><li>当 UI 元素采用较小的独立状态时，使用 CSS。</li><li>在需要对动画进行大量控制时，使用 JavaScript。</li><li>在特定的场景下可以使用 SVG，可以使用 CSS 或 JS 去操作 SVG 变化。</li></ul><h1 id="实现前端动画"><a href="#实现前端动画" class="headerlink" title="实现前端动画"></a>实现前端动画</h1><h2 id="animate-函数的实现"><a href="#animate-函数的实现" class="headerlink" title="animate 函数的实现"></a>animate 函数的实现</h2><p><strong>requestAnimationFrame VS setTimeout VS setInterval</strong></p><p>JavaScript 动画应该通过 <code>requestAnimationFrame</code> 实现。该内置方法允许设置回调函数以在<strong>浏览器准备重绘时</strong>运行，因此不容易丢帧，但是 <code>setTimeout</code> 和 <code>setInterval</code> 容易丢帧。通常这很快，确切的时间取决于浏览器。另外，当页面在后台时，根本没有重绘，所以回调不会运行，此时动画将被暂停并且不会消耗资源，这也比 <code>setTimeout</code> 和 <code>setInterval</code> 更优。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">&#123; easing, draw, duration &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为什么不使用 Date.new()？</span></span><br><span class="line">  <span class="comment">// 因为 performance.now() 会以恒定速度自增，精确到微秒级别，而 Date.now() 容易被篡改</span></span><br><span class="line">  <span class="keyword">const</span> start = performance.now();</span><br><span class="line">  <span class="comment">// 因为动画是连续的，执行完这个动画以后可能还有别的动画</span></span><br><span class="line">  <span class="comment">// 所以我们返回 Promise 以支持后续的顺序调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// timeFraction 是当前已经执行的时间与动画要持续的总时间的比值</span></span><br><span class="line">      <span class="comment">// progress 是一个介于 0 到 1 的值，表示执行绘画的进度</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果 timeFraction 大于或等于 1，说明时间已经超过 duration，执行完成</span></span><br><span class="line">      <span class="comment">// 直接把 progress 的最终值 1 传过去就行了</span></span><br><span class="line">      <span class="comment">// 否则的话，继续执行 requestAnimationFrame</span></span><br><span class="line">      <span class="keyword">let</span> timeFraction = (time - start) / duration;</span><br><span class="line">      <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        timeFraction = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> progress = easing(timeFraction);</span><br><span class="line">      draw(progress);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        requestAnimationFrame(animate);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw 绘制函数</span></span><br><span class="line"><span class="comment">// draw 是一支画笔，它会被反复调用</span></span><br><span class="line"><span class="comment">// 传入的参数是当前执行的进度，是一个介于 0 到 1 之间的值</span></span><br><span class="line"><span class="keyword">const</span> ball = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.ball&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> draw = <span class="function">(<span class="params">progress</span>) =&gt;</span> &#123;</span><br><span class="line">  ball.style.transfrom = <span class="string">`translate(<span class="subst">$&#123;progress&#125;</span>px, 0)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easing 缓动函数</span></span><br><span class="line"><span class="comment">// 修改动画执行的节奏</span></span><br><span class="line"><span class="keyword">const</span> easing = <span class="function">(<span class="params">timeFraction</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> timeFraction ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JS-动画的核心思想"><a href="#JS-动画的核心思想" class="headerlink" title="JS 动画的核心思想"></a>JS 动画的核心思想</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3159700498f41418f87469f348b591e~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这里 r 是距离，v 是速度，t 是时间。动画就是在开始状态和结束状态之间插值，这里的 r 可以简单理解为插值。</p><p>另外我们还需要通过比例尺实现物体的缩放，使得动画可以在显示屏中正常显示。</p><h2 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h2><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://codepen.io/jiangxiang/pen/rNmgVKK">动画演示</a></h3><ul><li>匀速直线</li><li>重力</li><li>摩擦力</li><li>平抛</li><li>旋转 + 平抛</li></ul><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>贝塞尔曲线生成网站：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cubic-bezier.com/">cubic-bezier.com</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/19/byte-fe-training-4-part-one/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/19/byte-fe-training-4-part-one/" class="post-title-link" itemprop="url">字节前端青训营第 4 天（上）</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-19 10:03:51 / 修改时间：17:36:59" itemprop="dateCreated datePublished" datetime="2022-01-19T10:03:51+08:00">2022-01-19</time> </span><span id="/2022/01/19/byte-fe-training-4-part-one/" class="post-meta-item leancloud_visitors" data-flag-title="字节前端青训营第 4 天（上）" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/19/byte-fe-training-4-part-one/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/19/byte-fe-training-4-part-one/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>892</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="React-的应用场景"><a href="#React-的应用场景" class="headerlink" title="React 的应用场景"></a>React 的应用场景</h1><ul><li>网页应用，Facebok，Instagram，Netflix 网页版</li><li>移动原生应用：Instagram，Discord，Oculus</li><li>桌面应用：结合 Electron</li><li>3D：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/pmndrs/react-three-fiber">react-three-fiber</a></li></ul><h1 id="React-的设计思路"><a href="#React-的设计思路" class="headerlink" title="React 的设计思路"></a>React 的设计思路</h1><h2 id="UI-编程的痛点"><a href="#UI-编程的痛点" class="headerlink" title="UI 编程的痛点"></a>UI 编程的痛点</h2><ul><li>状态更新，UI 不会自动更新，需要手动调用 dom</li><li>缺少代码层面的封装与隔离，没有组件化</li><li>UI 之间存在数据依赖关系，需要手动维护；如果数据依赖关系链太长，会出现 callback hell</li></ul><h2 id="转换式系统-amp-响应式系统"><a href="#转换式系统-amp-响应式系统" class="headerlink" title="转换式系统 &amp; 响应式系统"></a>转换式系统 &amp; 响应式系统</h2><p>转换式系统：给定输入，求解输出，如编译器，计算器<br>响应式系统：监听事件，由消息驱动</p><p>前端代码并不需要大量的计算，更多的是需要去处理一些事件（比如用户的点击）；另外当事件发生时，我们需要进行一些响应（比如改变界面）。这两个特点决定了转换式系统对于前端写起来是很难受的，我们需要一种新的方式。</p><p>依据上面的分析，我们对于 React 设计的期望也很容易得出：</p><ul><li>状态更新，UI 自动更新</li><li>前端代码组件化，可以复用，可以封装</li><li>状态之间</li></ul><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>组件是组件的组合 / 原子组件</li><li>组件内拥有状态，且外部不可见</li><li>父组件可以把状态传递给子组件</li></ul><h2 id="状态归属"><a href="#状态归属" class="headerlink" title="状态归属"></a>状态归属</h2><p>状态提升：当多个组件需要共享一个状态的时候，我们需要不断地提升状态，所以我们需要状态管理库。</p><p>注意 React 不是双向数据流，是单向的。<strong>子组件只是执行了父组件传递过来的函数，而没有把任何的状态传递回去给父组件。</strong>（函数在 Js 中是一等公民，所以可以作为一个变量传递）</p><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><ul><li>组件声明了状态以及 UI 的映射</li><li>组件有 state（内部状态）和 props（外部状态）两种状态</li><li>组件可以由其它组件拼装而成</li></ul><h1 id="状态管理库"><a href="#状态管理库" class="headerlink" title="状态管理库"></a>状态管理库</h1><p>使用状态管理库的弊端：组件的复用性降低了，一般使用于业务代码</p><p>常用的状态管理库有：</p><ul><li>redux</li><li>mobx</li><li>xstate</li><li>recoil</li><li>reduck（来源于 modern.js）</li></ul><p><strong>什么东西应该放到状态管理库？</strong><br>如果你觉得某个东西整个 APP 有多处可能用到的，就放进去，比如说用户头像，这样也可以减少我们发送的请求数。</p><h1 id="React-组件什么时候被渲染？"><a href="#React-组件什么时候被渲染？" class="headerlink" title="React 组件什么时候被渲染？"></a>React 组件什么时候被渲染？</h1><ul><li>首次渲染</li><li>props 变化</li><li>state 变化</li><li>context 变化</li></ul><h1 id="应用级框架科普"><a href="#应用级框架科普" class="headerlink" title="应用级框架科普"></a>应用级框架科普</h1><ul><li>Next.js</li><li>Modern.js</li><li>Blitz</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/18/why-we-need-hooks/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/18/why-we-need-hooks/" class="post-title-link" itemprop="url">为什么 React 要发明 Hooks</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-18 12:50:34" itemprop="dateCreated datePublished" datetime="2022-01-18T12:50:34+08:00">2022-01-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-19 16:40:12" itemprop="dateModified" datetime="2022-01-19T16:40:12+08:00">2022-01-19</time> </span><span id="/2022/01/18/why-we-need-hooks/" class="post-meta-item leancloud_visitors" data-flag-title="为什么 React 要发明 Hooks" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/18/why-we-need-hooks/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/18/why-we-need-hooks/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.4k</span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文为<a target="_blank" rel="noopener external nofollow noreferrer" href="https://time.geekbang.org/column/article/378311">React Hooks 核心原理与实战</a>阅读笔记</p><h1 id="React-组件的本质"><a href="#React-组件的本质" class="headerlink" title="React 组件的本质"></a>React 组件的本质</h1><p>我们可以把 UI 的展现看成一个<strong>函数</strong>的执行过程。其中，Model 是输入参数，函数的执行结果是 DOM 树，也就是 View。而 React 要保证的，就是每当 Model 发生变化时，函数会重新执行，并且生成新的 DOM 树，然后 React 再把新的 DOM 树以最优的方式更新到浏览器。</p><p><strong>所以我们是否真的有必要使用 class 来作为组件呢？</strong><br>事实上使用 class 是一种很牵强的做法，React 根本没有用到类的两个重要特性：</p><ul><li>React 组件之间是不会互相继承的。比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 来继承 Button。所以说，React 中其实是没有利用到 Class 的继承特性的。</li><li>所有 UI 都是由状态驱动的，因此很少会在外部去调用一个类实例（即组件）的方法。要知道，组件的所有方法都是在内部调用，或者作为生命周期方法被自动调用的。在使用类组件的时候，你从不需要去 new 一个对象来实现任何功能。</li></ul><p><strong>换句话说，class 并不是最好的组件表现形式，function 才是。</strong></p><h1 id="Hooks-的诞生"><a href="#Hooks-的诞生" class="headerlink" title="Hooks 的诞生"></a>Hooks 的诞生</h1><p>但是当时有一个局限是，函数组件无法存在内部状态，必须是纯函数，而且也无法提供完整的生命周期机制。</p><p>因此我们需要一个机制，能够把一个外部的数据绑定到函数的执行。<strong>当数据变化时，函数能够自动重新执行</strong>。</p><p><strong>于是有了 Hooks。</strong></p><p>在 React 中，Hooks 就是把某个目标结果<strong>钩到某个可能会变化的数据源或者事件源上</strong>，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p><p>对于函数组件，这个结果是最终的 DOM 树；对于 useCallback、useMemo 这样与缓存相关的组件，则是在依赖项发生变化时去更新缓存。</p><p>另外，有一点需要特别注意，Hooks 中被钩的对象，不仅可以是某个独立的数据源，也可以是另一个 Hook 执行的结果，这就带来了 Hooks 的最大好处：<strong>实现逻辑的复用</strong>。</p><h1 id="Hooks-实现逻辑复用"><a href="#Hooks-实现逻辑复用" class="headerlink" title="Hooks 实现逻辑复用"></a>Hooks 实现逻辑复用</h1><p>在之前的 React 使用中，有一点经常被大家诟病，就是非常难以实现逻辑的复用，必须借助于高阶组件等非常复杂的设计模式。但是高阶组件会产生冗余的组件节点，让调试变得困难。不过这些问题可以通过 Hooks 得到了很好的解决。所以如果有人问你 Hooks 有什么好处，那么最关键的答案就是<strong>简化了逻辑复用</strong>。</p><p>在 Hooks 出现之前，高阶组件几乎是 Class 组件中实现代码逻辑复用的唯一方式，其缺点其实比较显然：</p><ul><li>代码难理解，不直观，很多人甚至宁愿重复代码，也不愿用高阶组件。</li><li>会增加很多额外的组件节点。每一个高阶组件都会多一层节点，这就会给调试带来很大的负担。</li></ul><p>但现在我们可以通过 Hooks 的方式对外部数据进行封装，从而将其变成一个可绑定的数据源。</p><h1 id="Hooks-帮助实现关注点的分离"><a href="#Hooks-帮助实现关注点的分离" class="headerlink" title="Hooks 帮助实现关注点的分离"></a>Hooks 帮助实现关注点的分离</h1><p>除了逻辑复用之外，Hooks 能够带来的另外一大好处就是有助于关注分离，意思是说 Hooks 能够让针对同一个业务逻辑的代码尽可能聚合在一块儿。这是过去在 Class 组件中很难做到的。因为在 Class 组件中，你不得不把同一个业务逻辑的代码分散在类组件的不同生命周期的方法中。</p><p>在过去的 Class 组件中，我们需要在 <code>componentDidMount</code> 中监听事件，在 <code>componentWillUnmount</code> 中解绑事件。而在函数组件中，我们可以把所有逻辑写在一起。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/01/17/cross-origin/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/01/17/cross-origin/" class="post-title-link" itemprop="url">跨域解决方案</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-17 20:48:17" itemprop="dateCreated datePublished" datetime="2022-01-17T20:48:17+08:00">2022-01-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-21 16:43:05" itemprop="dateModified" datetime="2022-01-21T16:43:05+08:00">2022-01-21</time> </span><span id="/2022/01/17/cross-origin/" class="post-meta-item leancloud_visitors" data-flag-title="跨域解决方案" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/01/17/cross-origin/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/01/17/cross-origin/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.8k</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h1><p>浏览器同源策略是一个安全策略，其中同源指的是 <code>协议 + 域名 + 端口号</code> 三者相同，即使有两个不同的域名指向同一个 IP 地址，也不是同源的。同源策略可以一定程度上防止 XSS、CSRF 攻击。</p><p>一个域名的组成包括：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117211107.png"></p><p>在默认情况下 http 可以省略端口 80， https 可以省略端口 443。也就是说，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.baidu.com/">https://www.baidu.com</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.baidu.com/">https://www.baidu.com:443</a> 显然也是同源的，因为它们是一回事。</p><p>不符合同源策略导致的后果有：</p><ul><li>localStorage、sessionStorage、Cookie 等浏览器的内存无法跨域访问</li><li>DOM 节点无法进行跨域操作</li><li>Ajax 请求无法跨域请求</li></ul><p>但是有一些标签是允许跨域加载资源：</p><ul><li><code>&lt;img&gt;</code></li><li><code>&lt;link&gt;</code></li><li><code>&lt;script&gt;</code></li></ul><p>值得注意的几个要点有：</p><ul><li>如果是协议和端口造成的跨域问题，前端是无能为力的</li><li><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong></li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(<span class="string">&#x27;hello world&#x27;</span>));</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第一步：创建 xhr 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第三步：发送请求</span></span></span><br><span class="line"><span class="javascript">    xhr.send();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第四步：绑定事件</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// readState</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 0 表示未初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1 表示 open 完毕</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2 表示 send 完毕 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3 表示服务端返回了部分结果 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4 表示服务端返回了所有结果</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第五步：处理结果</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>果不其然报错了：<br><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117213331.png"></p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>JSONP，即 JSON with Padding，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。<br>JSONP 工作原理：在网页有一些标签天生就具有跨域能力，比如 <code>img</code> <code>link</code> <code>script</code> 等。JSONP 就是利用 <code>script</code> 标签的跨域能力来发送请求的。</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220117230214.png"><br>举个例子，客户端传入 a 和 b，服务端传回 a + b 的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; a, b, callback &#125; = query;</span><br><span class="line">    <span class="keyword">const</span> ans = <span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;<span class="subst">$&#123;ans&#125;</span>&#x27;)`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">ans</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;a + b =&#x27;</span>, ans);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> jsonp = <span class="function">(<span class="params">a, b, callback</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        script.src = <span class="string">`http://127.0.0.1:8000?a=<span class="subst">$&#123;a&#125;</span>&amp;b=<span class="subst">$&#123;b&#125;</span>&amp;callback=<span class="subst">$&#123;callback&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    jsonp(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;add&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缺点：需要前后端配合，只支持 get 请求。</p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>CORS 全称是 Cross-Orgin Resource Sharing，跨域资源共享。CORS 由后端开启，开启后前端就可以跨域访问后端。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。该属性表示哪些域名可以访问资源，如果设置为通配符 *，则表示所有网站都可以访问资源。类似的还有 <code>Access-Control-Allow-Methods</code>，表示允许的请求方法，<code>Access-Control-Allow-Headers</code>，表示允许的请求头类型。</p><p>设置 CORS 本身和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>只要同时满足以下条件的就是简单请求：</p><ol><li>请求方法是以下三者之一：</li></ol><ul><li>GET</li><li>POST</li><li>HEAD</li></ul><ol start="2"><li>允许人为设置的字段仅限以下几种：</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type（有额外限制）</li></ul><ol start="3"><li>Content-Type 取值为以下三者之一：</li></ol><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><ol start="4"><li><p>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</p></li><li><p>请求中没有使用 ReadableStream 对象。</p></li></ol><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>不是简单请求的请求就是复杂请求。<strong>复杂请求</strong>必须首先使用 <code>OPTIONS</code> 请求方法发起一个<strong>预检请求</strong>到服务器，以获知服务器是否允许该实际请求。预检请求的使用，可以避免跨域请求对服务器的用户数据产生预期之外的影响。</p><p>代码示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第一步：创建 xhr 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第二步：初始化，设置请求方法和 url，注意此处 url 必须写完整</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000?a=1&amp;b=2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第三步：发送请求</span></span></span><br><span class="line"><span class="javascript">    xhr.send();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第四步：绑定事件</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// readState</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 0 表示未初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1 表示 open 完毕</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2 表示 send 完毕 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3 表示服务端返回了部分结果 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4 表示服务端返回了所有结果</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第五步：处理结果</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">query</span>: &#123; a, b &#125; &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>Websocket 属于应用层协议，它基于 TCP 传输协议，并复用 http 的握手通道。<br>相比于 http 协议，它的优点是：</p><ul><li>支持双向通信，客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据</li><li>有更好的二进制支持</li><li>支持拓展</li></ul><p>因为这种方式本质没有使用 http 的响应头, 因此也没有跨域的限制。</p><p><strong>那么为什么 WebSocket 可以跨域呢？</strong><br>因为 WebSocket 根本不属于同源策略，而且它本身就有意被设计成可以跨域的一个手段。由于历史原因，跨域检测一直是由浏览器端来做，但是 WebSocket 出现以后，对于 WebSocket 的跨域检测工作就交给了服务端，浏览器仍然会带上一个 Origin 跨域请求头，服务端则根据这个请求头判断此次跨域 WebSocket 请求是否合法。</p><p>依然以 a + b 问题举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端 http://127.0.0.1:5500/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">ws</span>(<span class="params">a, b</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://127.0.0.1:8000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            socket.send(<span class="built_in">JSON</span>.stringify(&#123; a, b &#125;));</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    ws(<span class="number">1</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket.Server(&#123; port &#125;);</span><br><span class="line">ws.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    obj.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data.toString());</span><br><span class="line">        <span class="keyword">const</span> &#123; a, b &#125; = data;</span><br><span class="line">        obj.send(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Node-接口代理"><a href="#Node-接口代理" class="headerlink" title="Node 接口代理"></a>Node 接口代理</h1><p>同源策略只在浏览器存在，无法限制后端。也就是说前端与后端之间会受同源策略影响，但是后端与后端之间不会受到限制。所以可以通过 Node 做一层接口代理，先访问已经设置了 CORS 的后端 1，再让后端 1 去访问后端 2，获取数据后传给后端 1，最后再让后端 1 把数据传回给前端。</p><p>客户端代码同上，把请求端口改成 8888 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端 1 http://127.0.0.1:8888</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; methods = <span class="string">&#x27;GET&#x27;</span>, headers &#125; = req;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给后端 2 发送请求</span></span><br><span class="line">    http.request(&#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="string">&#x27;8000&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">`/?<span class="subst">$&#123;querystring.stringify(query)&#125;</span>`</span>,</span><br><span class="line">        methods,</span><br><span class="line">        headers</span><br><span class="line">    &#125;, <span class="function"><span class="params">proxyRes</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把从后端 2 获取的数据传回给前端</span></span><br><span class="line">        proxyRes.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">            res.end(chunk.toString());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).end()</span><br><span class="line">&#125;).listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端 2 http://127.0.0.1:8000</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开启 CORS</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的域名，也可设置 * 表示允许所有域名</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>,</span><br><span class="line">        <span class="comment">//跨域允许的请求方法，也可设置 * 表示允许所有方法</span></span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>,</span><br><span class="line">        <span class="comment">//允许的请求头类型</span></span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">query</span>: &#123; a, b &#125; &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;<span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)&#125;</span>`</span>);</span><br><span class="line">&#125;).listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening on port &#x27;</span> + port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p>实现原理类似于上面提到的 Node 接口代理，需要你搭建一个中转 Nginx 服务器，用于转发请求。使用 Nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 Nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器的性能。</p><p>先根据<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/diaojw090/article/details/89135073">Nginx安装教程</a>进行 Nginx 的安装。<br>然后修改 conf 目录下的 nginx.conf 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 8888;</span><br><span class="line">    server_name  127.0.0.1;</span><br><span class="line"> </span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>此时客户端请求 8888 端口，就不会跨域了。</p><p>参考资料：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7017614708832206878">https://juejin.cn/post/7017614708832206878</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844904126246027278">https://juejin.cn/post/6844904126246027278</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844903767226351623">https://juejin.cn/post/6844903767226351623</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/9a8d793ec52a">https://www.jianshu.com/p/9a8d793ec52a</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a><br>公众号前端点线面</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Flower F" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">Flower F</p><div class="site-description" itemprop="description">一个算法学不好的前端爱好者博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">116</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/flower-f" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;flower-f" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"></span> <span class="author" itemprop="copyrightHolder">Flower F</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">270k</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共94.4k字</span></div></div></footer></div><script color="34,34,34" opacity="0.5" zindex="-1" count="200" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"KDfducB8SxPnkLaWp3IDrYkW-gzGzoHsz",appKey:"CfgFpbeT1UKlX7K2k9fQnuI6",placeholder:"留下你来过的痕迹~",avatar:"",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/dynamic_bg.js"></script>