---
title: 回文数
date: 2021-12-11 16:07:56
tags: [算法, codetop]
copyright: true
---
题目链接：
https://leetcode-cn.com/problems/palindrome-number/
解法分析：
1. 首先是我的非常 low 的题解，将数字转换成字符串然后判断。
```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    const str = x.toString();
    for(let i = 0, j = str.length - 1; i <= j; i++, j--) {
        if(str[i] !== str[j]) {
            return false;
        }
    }
    return true;
};
```
这种解法存在的问题是：需要额外的非常量空间来存储字符串。

2. 官方题解：
```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    // 特殊情况处理：
    // 1. 负数必定不是回文数。
    // 2. 如果数字的最后一位是 0，为了使该数字为回文，
    // 则其第一位数字也应该是 0，但是多位数首位不为 0
    // 因此只有 0 本身才满足这一属性
    if (x < 0 || (x % 10 === 0 && x !== 0)) {
        return false;
    }

    // 每次进行取余操作 % 10，取出最低的数字：y = x % 10
    // 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y
    
    // 例如，对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，
    // 我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，
    // 122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，
    // 1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

    // 边界判断：由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，
    // 当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。
    let revertedNumber = 0;
    while (x > revertedNumber) {
        revertedNumber = revertedNumber * 10 + x % 10;
        x = Math.floor(x / 10);
    }

    // 当数字长度为奇数时，我们可以通过 revertedNumber / 10 去除处于中位的数字。
    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
    return x === revertedNumber || x === Math.floor(revertedNumber / 10);
};
```
参考题解：
1. 作者：LeetCode-Solution
   链接：
   https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/
   来源：力扣（LeetCode）
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
2. 作者：cxywushixiong
   链接：
   https://leetcode-cn.com/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/
   来源：力扣（LeetCode）
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。