<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"flower-f.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="本文是 Build Your Own React 的翻译兼阅读笔记 createElementReact 的每一个 element 包含的内容为 type 和 props。 1234567const element &#x3D; &amp;#123;  type: &quot;h1&quot;,  props: &amp;#123;    title: &quot;foo&quot;,    children: &amp;quot"><meta property="og:type" content="article"><meta property="og:title" content="react 核心原理"><meta property="og:url" content="https://flower-f.github.io/2022/02/16/react-core/index.html"><meta property="og:site_name" content="My Front End Blog"><meta property="og:description" content="本文是 Build Your Own React 的翻译兼阅读笔记 createElementReact 的每一个 element 包含的内容为 type 和 props。 1234567const element &#x3D; &amp;#123;  type: &quot;h1&quot;,  props: &amp;#123;    title: &quot;foo&quot;,    children: &amp;quot"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123303.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123804.png"><meta property="article:published_time" content="2022-02-16T08:42:28.000Z"><meta property="article:modified_time" content="2022-02-16T08:43:12.005Z"><meta property="article:author" content="Flower F"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123303.png"><link rel="canonical" href="https://flower-f.github.io/2022/02/16/react-core/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>react 核心原理 | My Front End Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="My Front End Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Flower-F" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><div class="bg_content"><canvas id="canvas"></canvas></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">My Front End Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">From Flower-F</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时光轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flower-f.github.io/2022/02/16/react-core/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Flower F"><meta itemprop="description" content="一个算法学不好的前端爱好者博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Front End Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">react 核心原理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-16 16:42:28 / 修改时间：16:43:12" itemprop="dateCreated datePublished" datetime="2022-02-16T16:42:28+08:00">2022-02-16</time> </span><span id="/2022/02/16/react-core/" class="post-meta-item leancloud_visitors" data-flag-title="react 核心原理" title="阅读量"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读量：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/02/16/react-core/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/02/16/react-core/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文是 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://pomb.us/build-your-own-react/">Build Your Own React</a> 的翻译兼阅读笔记</p><h1 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h1><p>React 的每一个 element 包含的内容为 type 和 props。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>, <span class="comment">// 一个特殊属性，通常是很多 elements 组成的数组</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把上述内容渲染为 dom，我们需要以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line"><span class="comment">// 把 props 的所有属性传递给节点</span></span><br><span class="line">node.title = element.props.title;</span><br><span class="line"><span class="comment">// 因为这里的 child 比较简单，所以我们用 textNode 代替</span></span><br><span class="line"><span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">textNode.nodeValue = element.props.children;</span><br><span class="line"><span class="comment">// 把 child 作为 node 的孩子</span></span><br><span class="line">node.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 node 插入容器</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">container.appendChild(node);</span><br></pre></td></tr></table></figure><p>这里默认 <code>dom</code> 代表真实的 dom 元素，而 <code>element</code> 代表 react 元素</p><p>现在让我们尝试创造一个自己的 createElement。我们需要做的就是把 JSX 转换为一个 object。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比方说，</p><p>createElement(“div”) 结果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123; <span class="attr">children</span>: [] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createElement(“div”, null, a) 结果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;ype: &quot;</span>div<span class="string">&quot;,</span></span><br><span class="line"><span class="string">  props: &#123; children: [a] &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>createElement(“div”, null, a, b) 结果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123; <span class="attr">children</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到 children 其实不一定是 object 类型，我们需要为 children 再创建一个特殊类型 TEXT_ELEMENT。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 createElement 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function"><span class="params">child</span> =&gt;</span> (</span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span> ? child : createTextElement(child)</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更有逼格而且摆脱 React 的束缚，我们要起一个很装逼的名字 ———— Didact。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>, <span class="comment">// type</span></span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="string">&quot;foo&quot;</span>&#125;, <span class="comment">// props</span></span><br><span class="line">  <span class="comment">// children</span></span><br><span class="line">  Didact.createElement(<span class="string">&#x27;a&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;bar&#x27;</span>), </span><br><span class="line">  Didact.createElement(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">ReactDOM.render(element, container);</span><br></pre></td></tr></table></figure><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =  element.type == <span class="string">&#x27;TEXT_ELEMENT&#x27;</span> ? <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>) : <span class="built_in">document</span>.createElem(element.type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个函数，用于判断键值是否为 children</span></span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&#x27;children&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props).filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = element.props.name;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归渲染</span></span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> render(child, dom));</span><br><span class="line"></span><br><span class="line">  container.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://codesandbox.io/s/didact-2-k6rbj">目前前两步的代码在 codesandbox 的地址</a></p><h1 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h1><p>目前代码其实有一个很大的问题，一旦开始 render，就会不停递归直至渲染完整棵树。如果这棵树非常大的话，他就会长时间占用主线程，导致卡顿。这时候如果浏览器希望做一些更高优先级的事情，比如先去接收用户的输入，将会无法进行，直至渲染完成。</p><p>所以我们需要把渲染流程分成多个小单元，在我们渲染完成每一个小单元之后，我们可以让浏览器打断我们的渲染，只要它有别的高优先级任务需要完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>; <span class="comment">// 下一个单元是否需要渲染</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">// 是否应该让路</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当下一个单元需要被渲染，且不需要让路的时候，就继续渲染</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    <span class="comment">// performUnitOfWork 会执行当前的渲染，并返回下一个 unit</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当主线程空闲的时候浏览器会执行回调函数 workLoop</span></span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次执行</span></span><br><span class="line">requestIdleCallback(workLoop);</span><br></pre></td></tr></table></figure><p>需要注意的是 React 现在不再使用 <code>requestIdleCallback</code> 了。取而代之的是 <code>scheduler package</code>，但这对于我们理解原理没有太大影响。</p><p>requestIdleCallback 还会给我们一个 deadline 参数，我们可以用它来检查在浏览器需要再次获得主线程的控制权之前，我们还能剩下多少时间。</p><h1 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h1><p>为了组织 unit 的结构我们需要一个数据结构叫做 fiber tree。</p><p>每一个元素会拥有一个 fiber，而每一个 fiber 会成为 work 的一个 unit。</p><p>比如说我们要渲染一棵如下的树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123303.png"></p><p>在渲染的时候我们会创建 root fiber，并把它设置为 nextUnitOfWork。剩下我们需要在 performUnitOfWork 函数中对 fiber 做以下三件事：</p><ol><li>把节点挂载到 dom 树</li><li>为节点的 child 创建 fiber</li><li>选择下一个 unit</li></ol><p>使用 fiber 数据结构的目的就是为了更简单地找到下一个 unit。所以每一个 fiber 和它的第一个孩子、以及紧邻它的兄弟之间都会直接相连。如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Flower-F/picture@main/img/20220216123804.png"></p><p>当我们完成了 fiber 上的渲染任务，如果这个 fiber 有 child，这个 child 就会成为下一个 unit。比如说对于上面的例子，div 渲染完成后就轮到 h1 了。</p><p>如果当前 fiber 没有 child，就会把紧贴的兄弟节点作为下一个 unit。比如上面例子中的 p，它没有 child 了，所以会把兄弟 a 作为下一个 unit。</p><p>如果当前 fiber 没有 child，也没有 sibling，我们就去找它的 uncle，也就是 parent 的兄弟。比如说 a，既没有 child 也没有下一个兄弟了，只能回去找它爹 h1 的兄弟 h2。</p><p>同理，如果它爹也没有兄弟，就继续找它爹的爹，如此遍历直到我们到达 root。当到达 root 也就意味着完成了 render。</p><p>现在我们将其编写成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container, <span class="comment">// 初始化设置为 root</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">// 是否应该让路</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当下一个单元需要被渲染，且不需要让路的时候，就继续渲染</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    <span class="comment">// performUnitOfWork 会执行当前的渲染，并返回下一个 unit</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当主线程空闲的时候浏览器会执行回调函数 workLoop</span></span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. create a new fiber for each child</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.type,</span><br><span class="line">      <span class="attr">props</span>: element.props,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 fiber 挂载到树上，具体要作为 child 还是 sibling 取决于它是第一个节点还是后来的节点</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. search and return the next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h1><p>现在我们又遇到了一个新问题，现在我们每个 unit 渲染时都会把一个 dom 挂载到树上，而浏览器可以随时打断我们的渲染。这也就意味着，如果只有部分 unit 完成了渲染，用户将看到不完整的 UI。这不是我们所想要的。</p><p>所以我们需要把挂载 dom 的部分从原来的 render 代码中删除。取而代之的持续追踪 fiber 的根，我们将其命名为 wipRoot。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>当我们完成渲染之后，也就是没有 next unit 的时候，我们直接把整棵树挂载到 dom 上。</p><p>这一阶段我们叫做 commitRoot。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  domParent.appendChild(fiber.dom);</span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reconciliation-调和"><a href="#Reconciliation-调和" class="headerlink" title="Reconciliation 调和"></a>Reconciliation 调和</h1><p>目前为止我们的所有操作都是针对于添加节点到 dom 中，那么如果我们要删除或更新节点呢？</p><p>这时候我们就需要比对 fiber 中元素和当前元素的情况。</p><p>所以我们需要一个变量来存储最新 commit 的 fiber，我们将其称为 currentRoot。</p><p>我们还要给每个 fiber 提供一个候选项 alternate，这个是一个直达旧的 fiber 的 link。</p><p>我们设置一个函数 reconcileChildren，用来调和旧的 fiber 和新的 react elements。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate?.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">       <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type === oldFiber.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新旧节点类型相同，对 element 创建新的 fiber，并且复用旧的 dom，但是用的是 element 上的 props</span></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">// 更新节点属性</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: oldFiber.type, <span class="comment">/// 复用</span></span><br><span class="line">        <span class="attr">props</span>: element.props, <span class="comment">// 用新的</span></span><br><span class="line">        <span class="attr">dom</span>: oldFiber.dom, <span class="comment">// 复用</span></span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&#x27;UPDATE&#x27;</span>, <span class="comment">// 这个属性会在  commit 的时候用到</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于需要生成新 DOM 节点的 fiber，我们标记 effectTag 为 PLACEMENT</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// 添加新节点</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: element.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&#x27;PLACEMENT&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于需要删除的节点，我们不会生成 fiber，而是会在 oldFiber 上添加标记。当我们 commit 整棵 fiber 树的时候，并不会遍历旧的 fiber，而是把 fiber 的变更提交上去。</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// 删除旧节点</span></span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代整个 react elements 的同时，我们也要迭代旧的 fiber 节点，即 wipFiber.alternate。</p><p>现在我们要比较 oldFiber 和 element 之间的差异。</p><p>比较的步骤如下：</p><ul><li>新旧节点类型相同，复用旧的 dom，只修改上面的属性。</li><li>节点类型不同，而且有新的 element，我们需要创建一个新的 dom 节点</li><li>类型不同，且 oldFiber 存在，需要删除旧节点</li></ul><p>React 会通过属性 key 来优化调和步骤，key 可以用来检查 elements 数组中的子组件是否仅仅只是更换了位置。</p><p>因此我们需要一个数组来保存要移除的 dom 节点。</p><p>修改 render 函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>修改 commitWork 函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果标记为 PLACEMENT，那么在其父亲节点的 DOM 节点上添加该 fiber 的 DOM。</span></span><br><span class="line">  <span class="comment">// 如果标记为 DELETION，则删除节点</span></span><br><span class="line">  <span class="comment">// 如果标记为 UPDATE，我们需要更新已经存在的旧 DOM 节点的属性值</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&#x27;PLACEMENT&#x27;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们实现 updateDom 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除旧属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps).filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加新属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps).filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom.name = nextProps.name;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种比较特殊的属性值是事件监听，这里假设以 on 开头的就是事件监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br></pre></td></tr></table></figure><p>对于事件监听我们需要做以下处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除原来的事件</span></span><br><span class="line"><span class="built_in">Object</span>.keys(prevProps).filter(isEvent)</span><br><span class="line">  .filter(<span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.removeEventListener(eventType, prevProps.name);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新的事件监听</span></span><br><span class="line"><span class="built_in">Object</span>.keys(nextProps).filter(isEvent)</span><br><span class="line">  .filter(isNew(prevProps, nextProps))</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.addEventListener(eventType, nextProps.name);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="Function-Components"><a href="#Function-Components" class="headerlink" title="Function Components"></a>Function Components</h1><p>下一步我们要支持函数组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Didact.render(element, container);</span><br></pre></td></tr></table></figure><p>这个 jsx 语法应该被转换为以下的 js 语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Hi &quot;</span>,</span><br><span class="line">    props.name</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数组件与之前的语法有两个不同之处：</p><ul><li>函数组件的 fiber 没有 dom</li><li>子节点由函数运行得到，而不是直接从 props 获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 fiber 类型为函数时，我们使用不同的函数来进行更新。在 updateHostComponent 我们按照之前的方法更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunctionComponent = fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line"><span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">  updateFunctionComponent(fiber);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  updateHostComponent(fiber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数组件中我们通过执行函数来获得 children。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于前面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>fiber.type 就是 App 函数，当执行函数的时候，就会返回 h1 元素。</p><p>一旦我们拿到了这个子节点，剩下的调和就跟之前一致，我们不需要修改任何东西了。</p><p>接下来修改 commitWork 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找 dom 节点的父节点的时候我们需要往上遍历 fiber 节点，直到找到有 dom 节点的 fiber 节点</span></span><br><span class="line">​  <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&#x27;PLACEMENT&#x27;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&#x27;UPDATE&#x27;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&#x27;DELETION&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 移除节点也同样需要找到该 fiber 下第一个有 dom 节点的 fiber 节点</span></span><br><span class="line">    domParent.removeChild(fiber, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>最后一步我们来给函数组件添加 state。我们把示例组件设置为经典的计数器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">      Count: &#123;state&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.hooks = [];</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对应的 fiber 上加上 hooks 数组以支持我们在同一个函数组件中多次调用 useState。然后我们记录当前 hook 的序号。</p><p>当函数组件调用 useState，我们查看 fiber 对应的 alternate 字段下的旧 fiber 是否存在旧 hook、以及hook 的序号用以记录是该组件下的第几个 useState。</p><p>如果存在旧的 hook，我们将旧的 hook 值拷贝一份到新的 hook。 如果不存在，就将 state 初始化。</p><p>然后在 fiber 上添加新 hook，hook 序号会进行自增，然后返回状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.state : initial,</span><br><span class="line">    <span class="attr">queue</span>: [], <span class="comment">// 添加一个队列，用于存储 action</span></span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下一次渲染的时候，我们才会执行 action，我们把所有的 action 从旧的 hook 队列中取出，然后将其一个个调用得到新的 hook state，因此最后返回的 state 就已经是更新好的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = oldHook ? oldHook.queue : [];</span><br><span class="line">actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  hook.state = action(hook.state)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  hook.queue.push(action);</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: currentRoot.dom,</span><br><span class="line">    <span class="attr">props</span>: currentRoot.props,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">  deletions = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useState 还需要返回一个可以更新状态的函数，我们定义 setState，它接收一个 action。（在 Counter 的例子中， action 是自增 state 的函数）</p><p>最终完整的 mini-react 代码链接在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://codesandbox.io/s/didact-8-21ost">https://codesandbox.io/s/didact-8-21ost</a></p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2022/02/16/react-core/">react 核心原理</a></p><p><span>文章作者:</span>Flower-F</p><p><span>发布时间:</span>2022年02月16日 - 16:42</p><p><span>最后更新:</span>2022年02月16日 - 16:43</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束，感谢您的阅读-------------</div></div></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/02/16/js-dnd/" rel="prev" title="使用原生 js 实现拖拽排序"><i class="fa fa-chevron-left"></i> 使用原生 js 实现拖拽排序</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#createElement"><span class="nav-number">1.</span> <span class="nav-text">createElement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#render"><span class="nav-number">2.</span> <span class="nav-text">render</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Concurrent-Mode"><span class="nav-number">3.</span> <span class="nav-text">Concurrent Mode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fibers"><span class="nav-number">4.</span> <span class="nav-text">Fibers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#commitRoot"><span class="nav-number">5.</span> <span class="nav-text">commitRoot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reconciliation-%E8%B0%83%E5%92%8C"><span class="nav-number">6.</span> <span class="nav-text">Reconciliation 调和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Function-Components"><span class="nav-number">7.</span> <span class="nav-text">Function Components</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hooks"><span class="nav-number">8.</span> <span class="nav-text">Hooks</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Flower F" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">Flower F</p><div class="site-description" itemprop="description">一个算法学不好的前端爱好者博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">138</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/flower-f" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;flower-f" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"></span> <span class="author" itemprop="copyrightHolder">Flower F</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">289k</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共98.6k字</span></div></div></footer></div><script color="34,34,34" opacity="0.5" zindex="-1" count="200" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"KDfducB8SxPnkLaWp3IDrYkW-gzGzoHsz",appKey:"CfgFpbeT1UKlX7K2k9fQnuI6",placeholder:"留下你来过的痕迹~",avatar:"",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/dynamic_bg.js"></script>